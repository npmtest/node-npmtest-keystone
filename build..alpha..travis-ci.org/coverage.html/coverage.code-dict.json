{"/home/travis/build/npmtest/node-npmtest-keystone/test.js":"/* istanbul instrument in package npmtest_keystone */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-keystone/lib.npmtest_keystone.js":"/* istanbul instrument in package npmtest_keystone */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_keystone = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_keystone = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-keystone/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-keystone && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_keystone */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_keystone\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_keystone.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_keystone.rollup.js'] =\n            local.assetsDict['/assets.npmtest_keystone.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_keystone.__dirname + '/lib.npmtest_keystone.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/index.js":"var _ = require('underscore');\nvar express = require('express');\nvar fs = require('fs');\nvar grappling = require('grappling-hook');\nvar path = require('path');\nvar utils = require('keystone-utils');\n\n/**\n * Don't use process.cwd() as it breaks module encapsulation\n * Instead, let's use module.parent if it's present, or the module itself if there is no parent (probably testing keystone directly if that's the case)\n * This way, the consuming app/module can be an embedded node_module and path resolutions will still work\n * (process.cwd() breaks module encapsulation if the consuming app/module is itself a node_module)\n */\nvar moduleRoot = (function(_rootPath) {\n\tvar parts = _rootPath.split(path.sep);\n\tparts.pop(); //get rid of /node_modules from the end of the path\n\treturn parts.join(path.sep);\n})(module.parent ? module.parent.paths[0] : module.paths[0]);\n\n\n/**\n * Keystone Class\n *\n * @api public\n */\nvar Keystone = function() {\n\tgrappling.mixin(this).allowHooks('pre:static', 'pre:bodyparser', 'pre:session', 'pre:routes', 'pre:render', 'updates', 'signout', 'signin', 'pre:logger');\n\tthis.lists = {};\n\tthis.paths = {};\n\tthis._options = {\n\t\t'name': 'Keystone',\n\t\t'brand': 'Keystone',\n\t\t'compress': true,\n\t\t'headless': false,\n\t\t'logger': ':method :url :status :response-time ms',\n\t\t'auto update': false,\n\t\t'model prefix': null,\n\t\t'module root': moduleRoot,\n\t\t'frame guard': 'sameorigin'\n\t};\n\tthis._redirects = {};\n\n\t// expose express\n\tthis.express = express;\n\n\t// init environment defaults\n\tthis.set('env', process.env.NODE_ENV || 'development');\n\n\tthis.set('port', process.env.PORT || process.env.OPENSHIFT_NODEJS_PORT);\n\tthis.set('host', process.env.HOST || process.env.IP || process.env.OPENSHIFT_NODEJS_IP);\n\tthis.set('listen', process.env.LISTEN);\n\n\tthis.set('ssl', process.env.SSL);\n\tthis.set('ssl port', process.env.SSL_PORT);\n\tthis.set('ssl host', process.env.SSL_HOST || process.env.SSL_IP);\n\tthis.set('ssl key', process.env.SSL_KEY);\n\tthis.set('ssl cert', process.env.SSL_CERT);\n\n\tthis.set('cookie secret', process.env.COOKIE_SECRET);\n\tthis.set('cookie signin', (this.get('env') === 'development') ? true : false);\n\n\tthis.set('embedly api key', process.env.EMBEDLY_API_KEY || process.env.EMBEDLY_APIKEY);\n\tthis.set('mandrill api key', process.env.MANDRILL_API_KEY || process.env.MANDRILL_APIKEY);\n\tthis.set('mandrill username', process.env.MANDRILL_USERNAME);\n\tthis.set('google api key', process.env.GOOGLE_BROWSER_KEY);\n\tthis.set('google server api key', process.env.GOOGLE_SERVER_KEY);\n\tthis.set('ga property', process.env.GA_PROPERTY);\n\tthis.set('ga domain', process.env.GA_DOMAIN);\n\tthis.set('chartbeat property', process.env.CHARTBEAT_PROPERTY);\n\tthis.set('chartbeat domain', process.env.CHARTBEAT_DOMAIN);\n\tthis.set('allowed ip ranges', process.env.ALLOWED_IP_RANGES);\n\n\tif (process.env.S3_BUCKET && process.env.S3_KEY && process.env.S3_SECRET) {\n\t\tthis.set('s3 config', { bucket: process.env.S3_BUCKET, key: process.env.S3_KEY, secret: process.env.S3_SECRET, region: process.env.S3_REGION });\n\t}\n\n\tif (process.env.AZURE_STORAGE_ACCOUNT && process.env.AZURE_STORAGE_ACCESS_KEY) {\n\t\tthis.set('azurefile config', { account: process.env.AZURE_STORAGE_ACCOUNT, key: process.env.AZURE_STORAGE_ACCESS_KEY });\n\t}\n\n\tif (process.env.CLOUDINARY_URL) {\n\t\t// process.env.CLOUDINARY_URL is processed by the cloudinary package when this is set\n\t\tthis.set('cloudinary config', true);\n\t}\n\n\t// Attach middleware packages, bound to this instance\n\tthis.middleware = {\n\t\tapi: require('./lib/middleware/api')(this),\n\t\tcors: require('./lib/middleware/cors')(this)\n\t};\n};\n\n_.extend(Keystone.prototype, require('./lib/core/options')());\n\n\nKeystone.prototype.prefixModel = function (key) {\n\tvar modelPrefix = this.get('model prefix');\n\n\tif (modelPrefix) {\n\t\tkey = modelPrefix + '_' + key;\n\t}\n\n\treturn require('mongoose/lib/utils').toCollectionName(key);\n};\n\n/* Attach core functionality to Keystone.prototype */\nKeystone.prototype.bindEmailTestRoutes = require('./lib/core/bindEmailTestRoutes');\nKeystone.prototype.connect = require('./lib/core/connect');\nKeystone.prototype.createItems = require('./lib/core/createItems');\nKeystone.prototype.getOrphanedLists = require('./lib/core/getOrphanedLists');\nKeystone.prototype.importer = require('./lib/core/importer');\nKeystone.prototype.init = require('./lib/core/init');\nKeystone.prototype.initNav = require('./lib/core/initNav');\nKeystone.prototype.list = require('./lib/core/list');\nKeystone.prototype.mount = require('./lib/core/mount');\nKeystone.prototype.populateRelated = require('./lib/core/populateRelated');\nKeystone.prototype.redirect = require('./lib/core/redirect');\nKeystone.prototype.render = require('./lib/core/render');\nKeystone.prototype.routes = require('./lib/core/routes');\nKeystone.prototype.start = require('./lib/core/start');\nKeystone.prototype.wrapHTMLError = require('./lib/core/wrapHTMLError');\n\n/* Expose Admin UI App */\nKeystone.prototype.adminApp = {\n\tstaticRouter: require('./admin/app/static')\n};\n\n/* Legacy Attach Mechanisms */\nKeystone.prototype.static = function(app) {\n\tif (!this.get('headless')) {\n\t\tapp.use('/keystone', Keystone.prototype.adminApp.staticRouter);\n\t}\n};\n\n/**\n * The exports object is an instance of Keystone.\n *\n * @api public\n */\nvar keystone = module.exports = exports = new Keystone();\n\n// Expose modules and Classes\nkeystone.Email = require('./lib/email');\nkeystone.Field = require('./fields/types/Type');\nkeystone.Field.Types = require('./lib/fieldTypes');\nkeystone.Keystone = Keystone;\nkeystone.List = require('./lib/list');\nkeystone.View = require('./lib/view');\n\nkeystone.content = require('./lib/content');\nkeystone.security = {\n\tcsrf: require('./lib/security/csrf')\n};\nkeystone.utils = utils;\n\n/**\n * returns all .js modules (recursively) in the path specified, relative\n * to the module root (where the keystone project is being consumed from).\n *\n * ####Example:\n *\n *     var models = keystone.import('models');\n *\n * @param {String} dirname\n * @api public\n */\n\nKeystone.prototype.import = function(dirname) {\n\n\tvar initialPath = path.join(this.get('module root'), dirname);\n\n\tvar doImport = function(fromPath) {\n\n\t\tvar imported = {};\n\n\t\tfs.readdirSync(fromPath).forEach(function(name) {\n\n\t\t\tvar fsPath = path.join(fromPath, name),\n\t\t\tinfo = fs.statSync(fsPath);\n\n\t\t\t// recur\n\t\t\tif (info.isDirectory()) {\n\t\t\t\timported[name] = doImport(fsPath);\n\t\t\t} else {\n\t\t\t\t// only import files that we can `require`\n\t\t\t\tvar ext = path.extname(name);\n\t\t\t\tvar base = path.basename(name, ext);\n\t\t\t\tif (require.extensions[ext]) {\n\t\t\t\t\timported[base] = require(fsPath);\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\n\t\treturn imported;\n\t};\n\n\treturn doImport(initialPath);\n};\n\n\n/**\n * Applies Application updates\n */\n\nKeystone.prototype.applyUpdates = function(callback) {\n\tvar self = this;\n\tself.callHook('pre:updates', function(err){\n\t\tif(err){\n\t\t\tcallback(err);\n\t\t}\n\t\trequire('./lib/updates').apply(function(err){\n\t\t\tif(err){\n\t\t\t\tcallback(err);\n\t\t\t}\n\t\t\tself.callHook('post:updates', callback);\n\t\t});\n\t});\n};\n\n\n/**\n * Logs a configuration error to the console\n *\n * @api public\n */\n\nKeystone.prototype.console = {};\nKeystone.prototype.console.err = function(type, msg) {\n\tif (keystone.get('logger')) {\n\t\tvar dashes = '\\n------------------------------------------------\\n';\n\t\tconsole.log(dashes + 'KeystoneJS: ' + type + ':\\n\\n' + msg + dashes);\n\t}\n};\n\n/**\n * Keystone version\n *\n * @api public\n */\n\nkeystone.version = require('./package.json').version;\n\n\n// Expose Modules\nkeystone.session = require('./lib/session');\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone-utils/index.js":"exports = module.exports = require('./lib/index');\nexports.htmlStringify = require('html-stringify');\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone-utils/lib/index.js":"/* eslint no-unused-vars:0 */\n\n// Credits:\n// ========\n//\n// Some utils borrowed from / inspired by mongoose/utils.js\n// see https://github.com/LearnBoost/mongoose\n//\n// HTML Entity encode / decode is based on code in node-html-to-text\n// see https://github.com/werk85/node-html-to-text\n\nvar _slug = require('slug');\nvar inflect = require('i')();\n\nvar limax;\ntry {\n\tlimax = require('limax');\n} catch(e) {}\n\n// HTML Entities for Text <> HTML conversion\nvar htmlEntities = require('./htmlEntities');\nvar htmlEntitiesMap = {};\nvar htmlEntitiesRegExp = '';\n\n(function () {\n\tfor (var i in htmlEntities) {\n\t\tvar ent = String.fromCharCode(htmlEntities[i]);\n\t\thtmlEntitiesMap[ent] = i;\n\t\thtmlEntitiesRegExp += '|' + ent;\n\t}\n\thtmlEntitiesRegExp = new RegExp(htmlEntitiesRegExp.substr(1), 'g');\n})();\n\n// Diacritics support\nvar diacritics = require('./diacritics');\n// Cyrillic transliteration\nvar transliteration = require('./transliteration.cyr');\n\n// Constants for distance calculation\nvar RADIUS_KM = 6371;\nvar RADIUS_MILES = 3959;\n\nfunction compact(arr) {\n\treturn arr.filter(function(v) {\n\t\treturn !!v;\n\t});\n}\n\nfunction deepClone(obj) {\n\tobj = obj || {};\n\treturn JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Determines if `arg` is a function.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n * @api public\n */\n\nvar isFunction = exports.isFunction = function isFunction (arg) {\n\treturn typeof arg === 'function';\n};\n\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n * @api public\n */\n\nvar isObject = exports.isObject = function isObject (arg) {\n\treturn Object.prototype.toString.call(arg) === '[object Object]';\n};\n\n/**\n * Determines if `arg` looks like a valid mongo ObjectId\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n * @api public\n */\n\nvar isValidObjectId = exports.isValidObjectId = function isValidObjectId (arg) {\n\tvar len = arg.length;\n\tif (len === 12 || len === 24) {\n\t\treturn /^[0-9a-fA-F]+$/.test(arg);\n\t} else {\n\t\treturn false;\n\t}\n};\n\n/**\n * Determines if `arg` is an array.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n * @api public\n */\n\nvar isArray = exports.isArray = function isArray (arg) {\n\treturn Array.isArray(arg);\n};\n\n/**\n * Determines if `arg` is a date.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n * @api public\n */\n\nvar isDate = exports.isDate = function isDate (arg) {\n\treturn Object.prototype.toString.call(arg) === '[object Date]';\n};\n\n/**\n * Determines if `arg` is a string.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n * @api public\n */\n\nvar isString = exports.isString = function isString (arg) {\n\treturn typeof arg === 'string';\n};\n\n/**\n * Determines if `arg` is a number.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n * @api public\n */\n\nvar isNumber = exports.isNumber = function isNumber (arg) {\n\treturn typeof arg === 'number';\n};\n\n/**\n * Make sure an email address looks valid.\n * May cause false-negatives in extremely rare cases, see\n * http://www.regular-expressions.info/email.html\n *\n * @param {String} str\n * @return {String}\n * @api public\n */\n\nvar isEmail = exports.isEmail = function isEmail (str) {\n\treturn /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.['a-z0-9!#$%&*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(str);\n}; // ' // sublime syntax hilighter fix\n\n/**\n * Determines if `arg` is a base64 encoded data URI.\n *\n * @param {String} arg\n * @return {Boolean}\n * @api public\n */\n\nvar isDataURL = exports.isDataURL = function isDataURL (str) {\n\tif (typeof str !== 'string') return false;\n\tvar isDataURLRegex = /^\\s*data:([a-z]+\\/[a-z0-9\\-\\+]+(;[a-z\\-]+\\=[a-z0-9\\-]+)?)?(;base64)?,[a-z0-9\\!\\$\\&\\'\\,\\(\\)\\*\\+\\,\\;\\=\\-\\.\\_\\~\\:\\@\\/\\?\\%\\s]*\\s*$/i;\n\treturn !!str.match(isDataURLRegex);\n};\n\n/**\n * Applies options to a defaults object.\n *\n * @param {Object} defaults (will be modified by reference)\n * @param {Object} options (will be assigned)\n * @return {Object} merged defaults and options\n * @api public\n */\n\nvar options = exports.options = function options (defaults, ops) {\n\tdefaults = defaults || {};\n\tops = ops || {};\n\tObject.keys(ops).forEach(function (key) {\n\t\tdefaults[key] = ops[key];\n\t});\n\treturn defaults;\n};\n\n/**\n * Creates a map of options\n *\n * @param {Array} options\n * @param {String} property to map\n * @param {Boolean} clone the options?\n * @return {Object} the map object\n * @api public\n */\n\nvar optionsMap = exports.optionsMap = function optionsMap (arr, property, clone) {\n\tif (arguments.length === 2 && typeof property === 'boolean') {\n\t\tclone = property;\n\t\tproperty = undefined;\n\t}\n\tvar obj = {};\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar prop = (property) ? arr[i][property] : arr[i];\n\t\tif (clone) {\n\t\t\tprop = deepClone(prop);\n\t\t}\n\t\tobj[arr[i].value] = prop;\n\t}\n\treturn obj;\n};\n\n/**\n * No operation\n */\nexports.noop = function() {};\n\n/**\n * Defers a function invocation with `process.nextTick()` and invokes it with\n * the rest of the arguments. Less Zalgo with less code.\n *\n * @param {Function} function to call\n */\n\nexports.defer = function defer (fn) {\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\tprocess.nextTick(function () { fn.apply(null, args); });\n};\n\n/**\n * Recursively binds method properties of an object to a scope\n * and returns a new object containing the bound methods\n *\n * @param {Object} object with method properties, can be nested in other objects\n * @param {Object} scope to bind as `this`\n * @return {Object} a new object containing the bound methods\n * @api public\n */\n\nvar bindMethods = exports.bindMethods = function bindMethods (obj, scope) {\n\tvar bound = {};\n\tfor (var prop in obj) {\n\t\tif (typeof obj[prop] === 'function') {\n\t\t\tbound[prop] = obj[prop].bind(scope);\n\t\t} else if (isObject(obj[prop])) {\n\t\t\tbound[prop] = bindMethods(obj[prop], scope);\n\t\t}\n\t}\n\treturn bound;\n};\n\n/**\n * Generates a 'random' string of characters to the specified length.\n *\n * @param {Number or Array}   len      the length of string to generate, can be a range (Array), Defaults to 10.\n * @param {String}            chars    characters to include in the string, defaults to `0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz`\n * @return {String}\n * @api public\n */\n\nvar randomString = exports.randomString = require('randomkey');\n\n/**\n * Converts a string to a number, accepting human-friendly input, e.g.\n * - 1,432\n * - $1432\n * - 2.5\n *\n * @param {String} input\n * @return {Number} number\n * @api public\n */\n\nvar number = exports.number = function number (str) {\n\treturn parseFloat(String(str).replace(/[^\\-0-9\\.]/g, ''));\n};\n\n/**\n * Escapes a string to be safely converted to a regular expression\n *\n * @param {String} string\n * @return {String} escaped string\n * @api public\n */\n\nvar escapeRegExp = exports.escapeRegExp = function escapeRegExp (str) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\treturn str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n};\n\n/**\n * Escapes a string to be safely used as a literal Javascript string\n *\n * @param {String} string\n * @return {String} escaped string\n * @api public\n */\n\nvar escapeString = exports.escapeString = function escapeString (str) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\treturn str.replace(/[\\\\'\"]/g, '\\\\$&');\n};\n\n/**\n * Strips diacritics from a string, replacing them with their simple equivalents\n *\n * @param {String} string\n * @return {String} stripped string\n * @api public\n */\n\nvar stripDiacritics = exports.stripDiacritics = function stripDiacritics (str) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\tvar rtn = [];\n\tfor (var i = 0; i < str.length; i++) {\n\t\tvar c = str.charAt(i);\n\t\trtn.push(diacritics[c] || c);\n\t}\n\treturn rtn.join('');\n};\n\n/**\n * Transliterates Russian and Ukrainian words from cyrillic to latin.\n *\n * @param  {String} word\n * @return {String} transliterated word\n * @api public\n */\nvar transliterate = exports.transliterate = function transliterate (str) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\tvar rtn = [];\n\t// applying лил│-zgh rule\n\tstr = str.replace(transliteration.regexp.Zgh, 'Zgh');\n\tstr = str.replace(transliteration.regexp.zgh, 'zgh');\n\t// replace characters with equivalent maps\n\tfor (var i = 0; i < str.length; i++) {\n\t\tvar character = str[i];\n\t\tvar latinCharacter = transliteration.characterMap[character];\n\t\trtn.push((latinCharacter || latinCharacter === '') ? latinCharacter : character);\n\t}\n\treturn rtn.join('');\n};\n\n/**\n * Generates a slug from a string. Word breaks are hyphenated.\n *\n * You can optionally provide a custom separator.\n *\n * @param {String} str\n * @param {String} sep (defaults to '-')\n * @param {Hash} options (defaults to {})\n * @return {String} slug\n * @api public\n */\n\nvar slug = exports.slug = function slug (str, sep, options) {\n\tif (!limax) {\n\t\treturn _slug(str,sep).toLowerCase();\n\t}\n\toptions = options || {};\n\tsep = sep || '-';\n\treturn limax(str, { tone: false, lang: options.locale, separator: sep });\n};\n\n/**\n * Converts a string to its singular form\n *\n * @param {String} str\n * @return {String} singular form of str\n * @api public\n */\n\nvar singular = exports.singular = function singular (str) {\n\treturn inflect.singularize(str);\n};\n\n/**\n * Displays the singular or plural of a string based on a number\n * or number of items in an array.\n *\n * If arity is 1, returns the plural form of the word.\n *\n * @param {String} count\n * @param {String} singular string\n * @param {String} plural string\n * @return {String} singular or plural, * is replaced with count\n * @api public\n */\n\nvar plural = exports.plural = function plural (count, sn, pl) {\n\tif (arguments.length === 1) {\n\t\treturn inflect.pluralize(count);\n\t}\n\tif (typeof sn !== 'string') sn = '';\n\tif (!pl) {\n\t\tpl = inflect.pluralize(sn);\n\t}\n\tif (typeof count === 'string') {\n\t\tcount = Number(count);\n\t} else if (typeof count !== 'number') {\n\t\tcount = Object.keys(count).length;\n\t}\n\treturn (count === 1 ? sn : pl).replace('*', count);\n};\n\n/**\n * Converts the first letter in a string to uppercase\n *\n * @param {String} str\n * @return {String} Str\n * @api public\n */\n\nvar upcase = exports.upcase = function upcase (str) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\treturn (str.substr(0, 1).toUpperCase() + str.substr(1));\n};\n\n/**\n * Converts the first letter in a string to lowercase\n *\n * @param {String} Str\n * @return {String} str\n * @api public\n */\n\nvar downcase = exports.downcase = function downcase (str) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\treturn (str.substr(0, 1).toLowerCase() + str.substr(1));\n};\n\n/**\n * Converts a string to title case\n *\n * @param {String} str\n * @return {String} Title Case form of str\n * @api public\n */\n\nvar titlecase = exports.titlecase = function titlecase (str) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\tstr = str.replace(/([a-z])([A-Z])/g, '$1 $2');\n\tvar parts = str.split(/\\s|_|\\-/);\n\tfor (var i = 0; i < parts.length; i++) {\n\t\tif (parts[i] && !/^[A-Z0-9]+$/.test(parts[i])) {\n\t\t\tparts[i] = upcase(parts[i]);\n\t\t}\n\t}\n\treturn compact(parts).join(' ');\n};\n\n/**\n * Converts a string to camel case\n *\n * @param {String} str\n * @param {Boolean} lowercaseFirstWord\n * @return {String} camel-case form of str\n * @api public\n */\n\nvar camelcase = exports.camelcase = function camelcase (str, lc) {\n\treturn inflect.camelize(str, !(lc));\n};\n\n/**\n * Decodes HTML Entities in a string\n *\n * @param {String}\n * @return {String}\n * @api public\n */\n\nvar decodeHTMLEntities = exports.decodeHTMLEntities = function decodeHTMLEntities (str) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\treturn str.replace(/&([^;&\\s]+);/g, function (match, ent) {\n\t\treturn String.fromCharCode(ent[0] !== '#' ? htmlEntities[ent] : ent[1] === 'x' ? parseInt(ent.substr(2), 16) : parseInt(ent.substr(1), 10));\n\t});\n};\n\n/**\n * Encodes HTML Entities in a string\n *\n * @param {String}\n * @return {String}\n * @api public\n */\n\nvar encodeHTMLEntities = exports.encodeHTMLEntities = function encodeHTMLEntities (str) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\treturn str.replace(htmlEntitiesRegExp, function (match) {\n\t\treturn '&' + htmlEntitiesMap[match] + ';';\n\t});\n};\n\n/**\n * Takes `obj`, `JSON.stringify`s it and escapes illegal JS but valid JSON unicode\n * characters.\n *\n * @param {Object} obj\n * @return {String}\n * @apu public\n */\n\nvar stringify = exports.stringify = function stringify (obj) {\n\treturn JSON.stringify(obj).replace(/[\\u000A\\u000D\\u2028\\u2029]/g, function (c) {\n\t\treturn '\\\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);\n\t});\n};\n\n/**\n * Converts text to HTML (line breaks to <br>)\n *\n * @param {String} str\n * @return {String}\n * @api public\n */\n\nvar textToHTML = exports.textToHTML = function textToHTML (str) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\treturn encodeHTMLEntities(str).replace(/\\n/g, '<br>');\n};\n\n/**\n * Ultra simple converter to turn HTML into text.\n *\n * Really only useful when you need a lightweight way to remove html from a string\n * before cropping it, so you don't end up with partial tags or an invalid DOM\n * structure.\n *\n * It will convert `br`, `p`, `div`, `li`, `td`, `th` tags to single line-breaks.\n * All other tags are stripped.\n *\n * Multiple line breaks are then compressed to a single line break, and leading /\n * trailing white space is stripped.\n *\n * For a more sophisticated use-case, you should check out the `to-markdown` and\n * `html-to-text` packages on npm.\n *\n * @param {String} str\n * @return {String}\n * @api public\n */\n\nvar htmlToText = exports.htmlToText = function htmlToText (str) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\t// remove all source-code line-breaks first\n\tstr = str.replace(/\\n/g, '');\n\t// turn non-breaking spaces into normal spaces\n\tstr = str.replace(/&nbsp;/g, ' ');\n\t// <br> tags become single line-breaks\n\tstr = str.replace(/<br>/gi, '\\n');\n\t// <p>, <li>, <td> and <th> tags become double line-breaks\n\tstr = str.replace(/<(?:p|li|td|th)[^>]*>/gi, '\\n');\n\t// strip all other tags (including closing tags)\n\tstr = str.replace(/<[^>]*>/g, '');\n\t// compress white space\n\tstr = str.replace(/(\\s)\\s+/g, '$1');\n\t// remove leading or trailing spaces\n\tstr = str.replace(/^\\s+|\\s+$/g, '');\n\treturn decodeHTMLEntities(str);\n};\n\n/**\n * Crops a string to the specified length.\n *\n * You can optionally a string to append (only appended if the original string was longer\n * than the specified length).\n *\n * If preserveWords is true, the length is extended to the end of the last word that would\n * have been cropped.\n *\n * @param {String} string to crop\n * @param {Number} length to crop to\n * @param {String} string to append\n * @param {Boolean} whether to preserve the last word in full\n * @return {String} cropped string\n * @api public\n */\n\nvar cropString = exports.cropString = function cropString (str, length, append, preserveWords) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\tif (typeof append === 'boolean') {\n\t\tpreserveWords = append;\n\t\tappend = null;\n\t}\n\tstr = String(str);\n\tif (str.length <= length) return str;\n\tvar cropTo = length;\n\tif (preserveWords) {\n\t\tvar r = str.substr(cropTo);\n\t\tvar word = r.match(/^\\w+/);\n\t\tif (word && word.length) {\n\t\t\tcropTo += word[0].length;\n\t\t}\n\t}\n\tvar rtn = str.substr(0, cropTo);\n\treturn (rtn.length < str.length && append) ? rtn + append : rtn;\n};\n\n/**\n * Crops an HTML string safely by converting it to text, cropping it, then converting it\n * back to HTML. Also prevents cross-site attacks by stripping tags.\n*/\n\nvar cropHTMLString = exports.cropHTMLString = function cropHTMLString (str, length, append, preserveWords) {\n\treturn textToHTML(cropString(htmlToText(str), length, append, preserveWords));\n};\n\n/**\n * Converts a key to a label.\n *\n * @param {String} key\n * @return {String}\n * @api public\n */\n\nvar keyToLabel = exports.keyToLabel = function keyToLabel (str) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\tstr = str.replace(/([a-z])([A-Z])/g, '$1 $2');\n\tstr = str.replace(/([0-9])([a-zA-Z])/g, '$1 $2');\n\tstr = str.replace(/([a-zA-Z])([0-9])/g, '$1 $2');\n\tvar parts = str.split(/\\s|\\.|_|-|:|;|([A-z\\u00C0-\\u00ff]+)/);\n\tfor (var i = 0; i < parts.length; i++) {\n\t\tif (parts[i] && !/^[A-Z0-9]+$/.test(parts[i])) {\n\t\t\tparts[i] = upcase(parts[i]);\n\t\t}\n\t}\n\treturn compact(parts).join(' ');\n};\n\n/**\n * Converts a key to a path. Like slug(keyToLabel(str)) but\n * optionally converts the last word to a plural.\n *\n * @param {String} key\n * @return {String}\n * @api public\n */\n\nvar keyToPath = exports.keyToPath = function keyToPath (str, plural) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\tvar parts = slug(keyToLabel(str)).split('-');\n\tif (parts.length && plural) {\n\t\tparts[parts.length - 1] = inflect.pluralize(parts[parts.length - 1]);\n\t}\n\treturn parts.join('-');\n};\n\n/**\n * Converts a key to a property. Like keyToPath but converts\n * to headlessCamelCase instead of dash-separated\n *\n * @param {String} key\n * @return {String}\n * @api public\n */\n\nvar keyToProperty = exports.keyToProperty = function keyToProperty (str, plural) {\n\tif (str && str.toString) str = str.toString();\n\tif (!isString(str) || !str.length) return '';\n\tvar parts = slug(keyToLabel(str)).split('-');\n\tif (parts.length && plural) {\n\t\tparts[parts.length - 1] = inflect.pluralize(parts[parts.length - 1]);\n\t}\n\tfor (var i = 1; i < parts.length; i++) {\n\t\tparts[i] = upcase(parts[i]);\n\t}\n\treturn parts.join('');\n};\n\n/**\n * Distance calculation function\n *\n * See http://en.wikipedia.org/wiki/Haversine_formula\n *\n * @param {Array} point1\n * @param {Array} point2\n * @return {Number} distance in radians\n * @api public\n */\n\nvar calculateDistance = exports.calculateDistance = function calculateDistance (point1, point2) {\n\tvar dLng = (point2[0] - point1[0]) * Math.PI / 180;\n\tvar dLat = (point2[1] - point1[1]) * Math.PI / 180;\n\tvar lat1 = (point1[1]) * Math.PI / 180;\n\tvar lat2 = (point2[1]) * Math.PI / 180;\n\tvar a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.sin(dLng / 2) * Math.sin(dLng / 2) * Math.cos(lat1) * Math.cos(lat2);\n\tvar c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\treturn c;\n};\n\n/**\n * Returns the distance between two [lat,lng] points in kilometres\n *\n * @param {Array} point1\n * @param {Array} point2\n * @return {Number} distance in kilometres\n * @api public\n */\n\nexports.kmBetween = function kmBetween (point1, point2) {\n\treturn calculateDistance(point1, point2) * RADIUS_KM;\n};\n\n/**\n * Returns the distance between two [lat,lng] points in miles\n *\n * @param {Array} point1\n * @param {Array} point2\n * @return {Number} distance in miles\n * @api public\n */\n\nexports.milesBetween = function milesBetween (point1, point2) {\n\treturn calculateDistance(point1, point2) * RADIUS_MILES;\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone-utils/lib/htmlEntities.js":"exports = module.exports = {\n\tapos: 0x0027, quot: 0x0022, amp: 0x0026, lt: 0x003C, gt: 0x003E, nbsp: 0x00A0, iexcl: 0x00A1, cent: 0x00A2, pound: 0x00A3,\n\tcurren: 0x00A4, yen: 0x00A5, brvbar: 0x00A6, sect: 0x00A7, uml: 0x00A8, copy: 0x00A9, ordf: 0x00AA, laquo: 0x00AB,\n\tnot: 0x00AC, shy: 0x00AD, reg: 0x00AE, macr: 0x00AF, deg: 0x00B0, plusmn: 0x00B1, sup2: 0x00B2, sup3: 0x00B3,\n\tacute: 0x00B4, micro: 0x00B5, para: 0x00B6, middot: 0x00B7, cedil: 0x00B8, sup1: 0x00B9, ordm: 0x00BA, raquo: 0x00BB,\n\tfrac14: 0x00BC, frac12: 0x00BD, frac34: 0x00BE, iquest: 0x00BF, Agrave: 0x00C0, Aacute: 0x00C1, Acirc: 0x00C2, Atilde: 0x00C3,\n\tAuml: 0x00C4, Aring: 0x00C5, AElig: 0x00C6, Ccedil: 0x00C7, Egrave: 0x00C8, Eacute: 0x00C9, Ecirc: 0x00CA, Euml: 0x00CB,\n\tIgrave: 0x00CC, Iacute: 0x00CD, Icirc: 0x00CE, Iuml: 0x00CF, ETH: 0x00D0, Ntilde: 0x00D1, Ograve: 0x00D2, Oacute: 0x00D3,\n\tOcirc: 0x00D4, Otilde: 0x00D5, Ouml: 0x00D6, times: 0x00D7, Oslash: 0x00D8, Ugrave: 0x00D9, Uacute: 0x00DA, Ucirc: 0x00DB,\n\tUuml: 0x00DC, Yacute: 0x00DD, THORN: 0x00DE, szlig: 0x00DF, agrave: 0x00E0, aacute: 0x00E1, acirc: 0x00E2, atilde: 0x00E3,\n\tauml: 0x00E4, aring: 0x00E5, aelig: 0x00E6, ccedil: 0x00E7, egrave: 0x00E8, eacute: 0x00E9, ecirc: 0x00EA, euml: 0x00EB,\n\tigrave: 0x00EC, iacute: 0x00ED, icirc: 0x00EE, iuml: 0x00EF, eth: 0x00F0, ntilde: 0x00F1, ograve: 0x00F2, oacute: 0x00F3,\n\tocirc: 0x00F4, otilde: 0x00F5, ouml: 0x00F6, divide: 0x00F7, oslash: 0x00F8, ugrave: 0x00F9, uacute: 0x00FA, ucirc: 0x00FB,\n\tuuml: 0x00FC, yacute: 0x00FD, thorn: 0x00FE, yuml: 0x00FF, OElig: 0x0152, oelig: 0x0153, Scaron: 0x0160, scaron: 0x0161,\n\tYuml: 0x0178, fnof: 0x0192, circ: 0x02C6, tilde: 0x02DC, Alpha: 0x0391, Beta: 0x0392, Gamma: 0x0393, Delta: 0x0394,\n\tEpsilon: 0x0395, Zeta: 0x0396, Eta: 0x0397, Theta: 0x0398, Iota: 0x0399, Kappa: 0x039A, Lambda: 0x039B, Mu: 0x039C,\n\tNu: 0x039D, Xi: 0x039E, Omicron: 0x039F, Pi: 0x03A0, Rho: 0x03A1, Sigma: 0x03A3, Tau: 0x03A4, Upsilon: 0x03A5,\n\tPhi: 0x03A6, Chi: 0x03A7, Psi: 0x03A8, Omega: 0x03A9, alpha: 0x03B1, beta: 0x03B2, gamma: 0x03B3, delta: 0x03B4,\n\tepsilon: 0x03B5, zeta: 0x03B6, eta: 0x03B7, theta: 0x03B8, iota: 0x03B9, kappa: 0x03BA, lambda: 0x03BB, mu: 0x03BC,\n\tnu: 0x03BD, xi: 0x03BE, omicron: 0x03BF, pi: 0x03C0, rho: 0x03C1, sigmaf: 0x03C2, sigma: 0x03C3, tau: 0x03C4,\n\tupsilon: 0x03C5, phi: 0x03C6, chi: 0x03C7, psi: 0x03C8, omega: 0x03C9, thetasym: 0x03D1, upsih: 0x03D2, piv: 0x03D6,\n\tensp: 0x2002, emsp: 0x2003, thinsp: 0x2009, zwnj: 0x200C, zwj: 0x200D, lrm: 0x200E, rlm: 0x200F, ndash: 0x2013,\n\tmdash: 0x2014, lsquo: 0x2018, rsquo: 0x2019, sbquo: 0x201A, ldquo: 0x201C, rdquo: 0x201D, bdquo: 0x201E, dagger: 0x2020,\n\tDagger: 0x2021, bull: 0x2022, hellip: 0x2026, permil: 0x2030, prime: 0x2032, Prime: 0x2033, lsaquo: 0x2039, rsaquo: 0x203A,\n\toline: 0x203E, frasl: 0x2044, euro: 0x20AC, image: 0x2111, weierp: 0x2118, real: 0x211C, trade: 0x2122, alefsym: 0x2135,\n\tlarr: 0x2190, uarr: 0x2191, rarr: 0x2192, darr: 0x2193, harr: 0x2194, crarr: 0x21B5, lArr: 0x21D0, uArr: 0x21D1,\n\trArr: 0x21D2, dArr: 0x21D3, hArr: 0x21D4, forall: 0x2200, part: 0x2202, exist: 0x2203, empty: 0x2205, nabla: 0x2207,\n\tisin: 0x2208, notin: 0x2209, ni: 0x220B, prod: 0x220F, sum: 0x2211, minus: 0x2212, lowast: 0x2217, radic: 0x221A,\n\tprop: 0x221D, infin: 0x221E, ang: 0x2220, and: 0x2227, or: 0x2228, cap: 0x2229, cup: 0x222A, 'int': 0x222B,\n\tthere4: 0x2234, sim: 0x223C, cong: 0x2245, asymp: 0x2248, ne: 0x2260, equiv: 0x2261, le: 0x2264, ge: 0x2265,\n\tsub: 0x2282, sup: 0x2283, nsub: 0x2284, sube: 0x2286, supe: 0x2287, oplus: 0x2295, otimes: 0x2297, perp: 0x22A5,\n\tsdot: 0x22C5, lceil: 0x2308, rceil: 0x2309, lfloor: 0x230A, rfloor: 0x230B, lang: 0x2329, rang: 0x232A, loz: 0x25CA,\n\tspades: 0x2660, clubs: 0x2663, hearts: 0x2665, diams: 0x2666\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone-utils/lib/diacritics.js":"exports = module.exports = {\n\t'\\u24B6': 'A', '\\uFF21': 'A', '\\u00C0': 'A', '\\u00C1': 'A', '\\u00C2': 'A', '\\u1EA6': 'A', '\\u1EA4': 'A', '\\u1EAA': 'A', '\\u1EA8': 'A',\n\t'\\u00C3': 'A', '\\u0100': 'A', '\\u0102': 'A', '\\u1EB0': 'A', '\\u1EAE': 'A', '\\u1EB4': 'A', '\\u1EB2': 'A', '\\u0226': 'A', '\\u01E0': 'A',\n\t'\\u00C4': 'A', '\\u01DE': 'A', '\\u1EA2': 'A', '\\u00C5': 'A', '\\u01FA': 'A', '\\u01CD': 'A', '\\u0200': 'A', '\\u0202': 'A', '\\u1EA0': 'A',\n\t'\\u1EAC': 'A', '\\u1EB6': 'A', '\\u1E00': 'A', '\\u0104': 'A', '\\u023A': 'A', '\\u2C6F': 'A', '\\uA732': 'AA', '\\u00C6': 'AE', '\\u01FC': 'AE',\n\t'\\u01E2': 'AE', '\\uA734': 'AO', '\\uA736': 'AU', '\\uA738': 'AV', '\\uA73A': 'AV', '\\uA73C': 'AY', '\\u24B7': 'B', '\\uFF22': 'B', '\\u1E02': 'B',\n\t'\\u1E04': 'B', '\\u1E06': 'B', '\\u0243': 'B', '\\u0182': 'B', '\\u0181': 'B', '\\u24B8': 'C', '\\uFF23': 'C', '\\u0106': 'C', '\\u0108': 'C',\n\t'\\u010A': 'C', '\\u010C': 'C', '\\u00C7': 'C', '\\u1E08': 'C', '\\u0187': 'C', '\\u023B': 'C', '\\uA73E': 'C', '\\u24B9': 'D', '\\uFF24': 'D',\n\t'\\u1E0A': 'D', '\\u010E': 'D', '\\u1E0C': 'D', '\\u1E10': 'D', '\\u1E12': 'D', '\\u1E0E': 'D', '\\u0110': 'D', '\\u018B': 'D', '\\u018A': 'D',\n\t'\\u0189': 'D', '\\uA779': 'D', '\\u01F1': 'DZ', '\\u01C4': 'DZ', '\\u01F2': 'Dz', '\\u01C5': 'Dz', '\\u24BA': 'E', '\\uFF25': 'E', '\\u00C8': 'E',\n\t'\\u00C9': 'E', '\\u00CA': 'E', '\\u1EC0': 'E', '\\u1EBE': 'E', '\\u1EC4': 'E', '\\u1EC2': 'E', '\\u1EBC': 'E', '\\u0112': 'E', '\\u1E14': 'E',\n\t'\\u1E16': 'E', '\\u0114': 'E', '\\u0116': 'E', '\\u00CB': 'E', '\\u1EBA': 'E', '\\u011A': 'E', '\\u0204': 'E', '\\u0206': 'E', '\\u1EB8': 'E',\n\t'\\u1EC6': 'E', '\\u0228': 'E', '\\u1E1C': 'E', '\\u0118': 'E', '\\u1E18': 'E', '\\u1E1A': 'E', '\\u0190': 'E', '\\u018E': 'E', '\\u24BB': 'F',\n\t'\\uFF26': 'F', '\\u1E1E': 'F', '\\u0191': 'F', '\\uA77B': 'F', '\\u24BC': 'G', '\\uFF27': 'G', '\\u01F4': 'G', '\\u011C': 'G', '\\u1E20': 'G',\n\t'\\u011E': 'G', '\\u0120': 'G', '\\u01E6': 'G', '\\u0122': 'G', '\\u01E4': 'G', '\\u0193': 'G', '\\uA7A0': 'G', '\\uA77D': 'G', '\\uA77E': 'G',\n\t'\\u24BD': 'H', '\\uFF28': 'H', '\\u0124': 'H', '\\u1E22': 'H', '\\u1E26': 'H', '\\u021E': 'H', '\\u1E24': 'H', '\\u1E28': 'H', '\\u1E2A': 'H',\n\t'\\u0126': 'H', '\\u2C67': 'H', '\\u2C75': 'H', '\\uA78D': 'H', '\\u24BE': 'I', '\\uFF29': 'I', '\\u00CC': 'I', '\\u00CD': 'I', '\\u00CE': 'I',\n\t'\\u0128': 'I', '\\u012A': 'I', '\\u012C': 'I', '\\u0130': 'I', '\\u00CF': 'I', '\\u1E2E': 'I', '\\u1EC8': 'I', '\\u01CF': 'I', '\\u0208': 'I',\n\t'\\u020A': 'I', '\\u1ECA': 'I', '\\u012E': 'I', '\\u1E2C': 'I', '\\u0197': 'I', '\\u24BF': 'J', '\\uFF2A': 'J', '\\u0134': 'J', '\\u0248': 'J',\n\t'\\u24C0': 'K', '\\uFF2B': 'K', '\\u1E30': 'K', '\\u01E8': 'K', '\\u1E32': 'K', '\\u0136': 'K', '\\u1E34': 'K', '\\u0198': 'K', '\\u2C69': 'K',\n\t'\\uA740': 'K', '\\uA742': 'K', '\\uA744': 'K', '\\uA7A2': 'K', '\\u24C1': 'L', '\\uFF2C': 'L', '\\u013F': 'L', '\\u0139': 'L', '\\u013D': 'L',\n\t'\\u1E36': 'L', '\\u1E38': 'L', '\\u013B': 'L', '\\u1E3C': 'L', '\\u1E3A': 'L', '\\u0141': 'L', '\\u023D': 'L', '\\u2C62': 'L', '\\u2C60': 'L',\n\t'\\uA748': 'L', '\\uA746': 'L', '\\uA780': 'L', '\\u01C7': 'LJ', '\\u01C8': 'Lj', '\\u24C2': 'M', '\\uFF2D': 'M', '\\u1E3E': 'M', '\\u1E40': 'M',\n\t'\\u1E42': 'M', '\\u2C6E': 'M', '\\u019C': 'M', '\\u24C3': 'N', '\\uFF2E': 'N', '\\u01F8': 'N', '\\u0143': 'N', '\\u00D1': 'N', '\\u1E44': 'N',\n\t'\\u0147': 'N', '\\u1E46': 'N', '\\u0145': 'N', '\\u1E4A': 'N', '\\u1E48': 'N', '\\u0220': 'N', '\\u019D': 'N', '\\uA790': 'N', '\\uA7A4': 'N',\n\t'\\u01CA': 'NJ', '\\u01CB': 'Nj', '\\u24C4': 'O', '\\uFF2F': 'O', '\\u00D2': 'O', '\\u00D3': 'O', '\\u00D4': 'O', '\\u1ED2': 'O', '\\u1ED0': 'O',\n\t'\\u1ED6': 'O', '\\u1ED4': 'O', '\\u00D5': 'O', '\\u1E4C': 'O', '\\u022C': 'O', '\\u1E4E': 'O', '\\u014C': 'O', '\\u1E50': 'O', '\\u1E52': 'O',\n\t'\\u014E': 'O', '\\u022E': 'O', '\\u0230': 'O', '\\u00D6': 'O', '\\u022A': 'O', '\\u1ECE': 'O', '\\u0150': 'O', '\\u01D1': 'O', '\\u020C': 'O',\n\t'\\u020E': 'O', '\\u01A0': 'O', '\\u1EDC': 'O', '\\u1EDA': 'O', '\\u1EE0': 'O', '\\u1EDE': 'O', '\\u1EE2': 'O', '\\u1ECC': 'O', '\\u1ED8': 'O',\n\t'\\u01EA': 'O', '\\u01EC': 'O', '\\u00D8': 'O', '\\u01FE': 'O', '\\u0186': 'O', '\\u019F': 'O', '\\uA74A': 'O', '\\uA74C': 'O', '\\u01A2': 'OI',\n\t'\\uA74E': 'OO', '\\u0222': 'OU', '\\u24C5': 'P', '\\uFF30': 'P', '\\u1E54': 'P', '\\u1E56': 'P', '\\u01A4': 'P', '\\u2C63': 'P', '\\uA750': 'P',\n\t'\\uA752': 'P', '\\uA754': 'P', '\\u24C6': 'Q', '\\uFF31': 'Q', '\\uA756': 'Q', '\\uA758': 'Q', '\\u024A': 'Q', '\\u24C7': 'R', '\\uFF32': 'R',\n\t'\\u0154': 'R', '\\u1E58': 'R', '\\u0158': 'R', '\\u0210': 'R', '\\u0212': 'R', '\\u1E5A': 'R', '\\u1E5C': 'R', '\\u0156': 'R', '\\u1E5E': 'R',\n\t'\\u024C': 'R', '\\u2C64': 'R', '\\uA75A': 'R', '\\uA7A6': 'R', '\\uA782': 'R', '\\u24C8': 'S', '\\uFF33': 'S', '\\u1E9E': 'S', '\\u015A': 'S',\n\t'\\u1E64': 'S', '\\u015C': 'S', '\\u1E60': 'S', '\\u0160': 'S', '\\u1E66': 'S', '\\u1E62': 'S', '\\u1E68': 'S', '\\u0218': 'S', '\\u015E': 'S',\n\t'\\u2C7E': 'S', '\\uA7A8': 'S', '\\uA784': 'S', '\\u24C9': 'T', '\\uFF34': 'T', '\\u1E6A': 'T', '\\u0164': 'T', '\\u1E6C': 'T', '\\u021A': 'T',\n\t'\\u0162': 'T', '\\u1E70': 'T', '\\u1E6E': 'T', '\\u0166': 'T', '\\u01AC': 'T', '\\u01AE': 'T', '\\u023E': 'T', '\\uA786': 'T', '\\uA728': 'TZ',\n\t'\\u24CA': 'U', '\\uFF35': 'U', '\\u00D9': 'U', '\\u00DA': 'U', '\\u00DB': 'U', '\\u0168': 'U', '\\u1E78': 'U', '\\u016A': 'U', '\\u1E7A': 'U',\n\t'\\u016C': 'U', '\\u00DC': 'U', '\\u01DB': 'U', '\\u01D7': 'U', '\\u01D5': 'U', '\\u01D9': 'U', '\\u1EE6': 'U', '\\u016E': 'U', '\\u0170': 'U',\n\t'\\u01D3': 'U', '\\u0214': 'U', '\\u0216': 'U', '\\u01AF': 'U', '\\u1EEA': 'U', '\\u1EE8': 'U', '\\u1EEE': 'U', '\\u1EEC': 'U', '\\u1EF0': 'U',\n\t'\\u1EE4': 'U', '\\u1E72': 'U', '\\u0172': 'U', '\\u1E76': 'U', '\\u1E74': 'U', '\\u0244': 'U', '\\u24CB': 'V', '\\uFF36': 'V', '\\u1E7C': 'V',\n\t'\\u1E7E': 'V', '\\u01B2': 'V', '\\uA75E': 'V', '\\u0245': 'V', '\\uA760': 'VY', '\\u24CC': 'W', '\\uFF37': 'W', '\\u1E80': 'W', '\\u1E82': 'W',\n\t'\\u0174': 'W', '\\u1E86': 'W', '\\u1E84': 'W', '\\u1E88': 'W', '\\u2C72': 'W', '\\u24CD': 'X', '\\uFF38': 'X', '\\u1E8A': 'X', '\\u1E8C': 'X',\n\t'\\u24CE': 'Y', '\\uFF39': 'Y', '\\u1EF2': 'Y', '\\u00DD': 'Y', '\\u0176': 'Y', '\\u1EF8': 'Y', '\\u0232': 'Y', '\\u1E8E': 'Y', '\\u0178': 'Y',\n\t'\\u1EF6': 'Y', '\\u1EF4': 'Y', '\\u01B3': 'Y', '\\u024E': 'Y', '\\u1EFE': 'Y', '\\u24CF': 'Z', '\\uFF3A': 'Z', '\\u0179': 'Z', '\\u1E90': 'Z',\n\t'\\u017B': 'Z', '\\u017D': 'Z', '\\u1E92': 'Z', '\\u1E94': 'Z', '\\u01B5': 'Z', '\\u0224': 'Z', '\\u2C7F': 'Z', '\\u2C6B': 'Z', '\\uA762': 'Z',\n\t'\\u24D0': 'a', '\\uFF41': 'a', '\\u1E9A': 'a', '\\u00E0': 'a', '\\u00E1': 'a', '\\u00E2': 'a', '\\u1EA7': 'a', '\\u1EA5': 'a', '\\u1EAB': 'a',\n\t'\\u1EA9': 'a', '\\u00E3': 'a', '\\u0101': 'a', '\\u0103': 'a', '\\u1EB1': 'a', '\\u1EAF': 'a', '\\u1EB5': 'a', '\\u1EB3': 'a', '\\u0227': 'a',\n\t'\\u01E1': 'a', '\\u00E4': 'a', '\\u01DF': 'a', '\\u1EA3': 'a', '\\u00E5': 'a', '\\u01FB': 'a', '\\u01CE': 'a', '\\u0201': 'a', '\\u0203': 'a',\n\t'\\u1EA1': 'a', '\\u1EAD': 'a', '\\u1EB7': 'a', '\\u1E01': 'a', '\\u0105': 'a', '\\u2C65': 'a', '\\u0250': 'a', '\\uA733': 'aa', '\\u00E6': 'ae',\n\t'\\u01FD': 'ae', '\\u01E3': 'ae', '\\uA735': 'ao', '\\uA737': 'au', '\\uA739': 'av', '\\uA73B': 'av', '\\uA73D': 'ay', '\\u24D1': 'b', '\\uFF42': 'b',\n\t'\\u1E03': 'b', '\\u1E05': 'b', '\\u1E07': 'b', '\\u0180': 'b', '\\u0183': 'b', '\\u0253': 'b', '\\u24D2': 'c', '\\uFF43': 'c', '\\u0107': 'c',\n\t'\\u0109': 'c', '\\u010B': 'c', '\\u010D': 'c', '\\u00E7': 'c', '\\u1E09': 'c', '\\u0188': 'c', '\\u023C': 'c', '\\uA73F': 'c', '\\u2184': 'c',\n\t'\\u24D3': 'd', '\\uFF44': 'd', '\\u1E0B': 'd', '\\u010F': 'd', '\\u1E0D': 'd', '\\u1E11': 'd', '\\u1E13': 'd', '\\u1E0F': 'd', '\\u0111': 'd',\n\t'\\u018C': 'd', '\\u0256': 'd', '\\u0257': 'd', '\\uA77A': 'd', '\\u01F3': 'dz', '\\u01C6': 'dz', '\\u24D4': 'e', '\\uFF45': 'e', '\\u00E8': 'e',\n\t'\\u00E9': 'e', '\\u00EA': 'e', '\\u1EC1': 'e', '\\u1EBF': 'e', '\\u1EC5': 'e', '\\u1EC3': 'e', '\\u1EBD': 'e', '\\u0113': 'e', '\\u1E15': 'e',\n\t'\\u1E17': 'e', '\\u0115': 'e', '\\u0117': 'e', '\\u00EB': 'e', '\\u1EBB': 'e', '\\u011B': 'e', '\\u0205': 'e', '\\u0207': 'e', '\\u1EB9': 'e',\n\t'\\u1EC7': 'e', '\\u0229': 'e', '\\u1E1D': 'e', '\\u0119': 'e', '\\u1E19': 'e', '\\u1E1B': 'e', '\\u0247': 'e', '\\u025B': 'e', '\\u01DD': 'e',\n\t'\\u24D5': 'f', '\\uFF46': 'f', '\\u1E1F': 'f', '\\u0192': 'f', '\\uA77C': 'f', '\\u24D6': 'g', '\\uFF47': 'g', '\\u01F5': 'g', '\\u011D': 'g',\n\t'\\u1E21': 'g', '\\u011F': 'g', '\\u0121': 'g', '\\u01E7': 'g', '\\u0123': 'g', '\\u01E5': 'g', '\\u0260': 'g', '\\uA7A1': 'g', '\\u1D79': 'g',\n\t'\\uA77F': 'g', '\\u24D7': 'h', '\\uFF48': 'h', '\\u0125': 'h', '\\u1E23': 'h', '\\u1E27': 'h', '\\u021F': 'h', '\\u1E25': 'h', '\\u1E29': 'h',\n\t'\\u1E2B': 'h', '\\u1E96': 'h', '\\u0127': 'h', '\\u2C68': 'h', '\\u2C76': 'h', '\\u0265': 'h', '\\u0195': 'hv', '\\u24D8': 'i', '\\uFF49': 'i',\n\t'\\u00EC': 'i', '\\u00ED': 'i', '\\u00EE': 'i', '\\u0129': 'i', '\\u012B': 'i', '\\u012D': 'i', '\\u00EF': 'i', '\\u1E2F': 'i', '\\u1EC9': 'i',\n\t'\\u01D0': 'i', '\\u0209': 'i', '\\u020B': 'i', '\\u1ECB': 'i', '\\u012F': 'i', '\\u1E2D': 'i', '\\u0268': 'i', '\\u0131': 'i', '\\u24D9': 'j',\n\t'\\uFF4A': 'j', '\\u0135': 'j', '\\u01F0': 'j', '\\u0249': 'j', '\\u24DA': 'k', '\\uFF4B': 'k', '\\u1E31': 'k', '\\u01E9': 'k', '\\u1E33': 'k',\n\t'\\u0137': 'k', '\\u1E35': 'k', '\\u0199': 'k', '\\u2C6A': 'k', '\\uA741': 'k', '\\uA743': 'k', '\\uA745': 'k', '\\uA7A3': 'k', '\\u24DB': 'l',\n\t'\\uFF4C': 'l', '\\u0140': 'l', '\\u013A': 'l', '\\u013E': 'l', '\\u1E37': 'l', '\\u1E39': 'l', '\\u013C': 'l', '\\u1E3D': 'l', '\\u1E3B': 'l',\n\t'\\u017F': 'l', '\\u0142': 'l', '\\u019A': 'l', '\\u026B': 'l', '\\u2C61': 'l', '\\uA749': 'l', '\\uA781': 'l', '\\uA747': 'l', '\\u01C9': 'lj',\n\t'\\u24DC': 'm', '\\uFF4D': 'm', '\\u1E3F': 'm', '\\u1E41': 'm', '\\u1E43': 'm', '\\u0271': 'm', '\\u026F': 'm', '\\u24DD': 'n', '\\uFF4E': 'n',\n\t'\\u01F9': 'n', '\\u0144': 'n', '\\u00F1': 'n', '\\u1E45': 'n', '\\u0148': 'n', '\\u1E47': 'n', '\\u0146': 'n', '\\u1E4B': 'n', '\\u1E49': 'n',\n\t'\\u019E': 'n', '\\u0272': 'n', '\\u0149': 'n', '\\uA791': 'n', '\\uA7A5': 'n', '\\u01CC': 'nj', '\\u24DE': 'o', '\\uFF4F': 'o', '\\u00F2': 'o',\n\t'\\u00F3': 'o', '\\u00F4': 'o', '\\u1ED3': 'o', '\\u1ED1': 'o', '\\u1ED7': 'o', '\\u1ED5': 'o', '\\u00F5': 'o', '\\u1E4D': 'o', '\\u022D': 'o',\n\t'\\u1E4F': 'o', '\\u014D': 'o', '\\u1E51': 'o', '\\u1E53': 'o', '\\u014F': 'o', '\\u022F': 'o', '\\u0231': 'o', '\\u00F6': 'o', '\\u022B': 'o',\n\t'\\u1ECF': 'o', '\\u0151': 'o', '\\u01D2': 'o', '\\u020D': 'o', '\\u020F': 'o', '\\u01A1': 'o', '\\u1EDD': 'o', '\\u1EDB': 'o', '\\u1EE1': 'o',\n\t'\\u1EDF': 'o', '\\u1EE3': 'o', '\\u1ECD': 'o', '\\u1ED9': 'o', '\\u01EB': 'o', '\\u01ED': 'o', '\\u00F8': 'o', '\\u01FF': 'o', '\\u0254': 'o',\n\t'\\uA74B': 'o', '\\uA74D': 'o', '\\u0275': 'o', '\\u01A3': 'oi', '\\u0223': 'ou', '\\uA74F': 'oo', '\\u24DF': 'p', '\\uFF50': 'p', '\\u1E55': 'p',\n\t'\\u1E57': 'p', '\\u01A5': 'p', '\\u1D7D': 'p', '\\uA751': 'p', '\\uA753': 'p', '\\uA755': 'p', '\\u24E0': 'q', '\\uFF51': 'q', '\\u024B': 'q',\n\t'\\uA757': 'q', '\\uA759': 'q', '\\u24E1': 'r', '\\uFF52': 'r', '\\u0155': 'r', '\\u1E59': 'r', '\\u0159': 'r', '\\u0211': 'r', '\\u0213': 'r',\n\t'\\u1E5B': 'r', '\\u1E5D': 'r', '\\u0157': 'r', '\\u1E5F': 'r', '\\u024D': 'r', '\\u027D': 'r', '\\uA75B': 'r', '\\uA7A7': 'r', '\\uA783': 'r',\n\t'\\u24E2': 's', '\\uFF53': 's', '\\u00DF': 's', '\\u015B': 's', '\\u1E65': 's', '\\u015D': 's', '\\u1E61': 's', '\\u0161': 's', '\\u1E67': 's',\n\t'\\u1E63': 's', '\\u1E69': 's', '\\u0219': 's', '\\u015F': 's', '\\u023F': 's', '\\uA7A9': 's', '\\uA785': 's', '\\u1E9B': 's', '\\u24E3': 't',\n\t'\\uFF54': 't', '\\u1E6B': 't', '\\u1E97': 't', '\\u0165': 't', '\\u1E6D': 't', '\\u021B': 't', '\\u0163': 't', '\\u1E71': 't', '\\u1E6F': 't',\n\t'\\u0167': 't', '\\u01AD': 't', '\\u0288': 't', '\\u2C66': 't', '\\uA787': 't', '\\uA729': 'tz', '\\u24E4': 'u', '\\uFF55': 'u', '\\u00F9': 'u',\n\t'\\u00FA': 'u', '\\u00FB': 'u', '\\u0169': 'u', '\\u1E79': 'u', '\\u016B': 'u', '\\u1E7B': 'u', '\\u016D': 'u', '\\u00FC': 'u', '\\u01DC': 'u',\n\t'\\u01D8': 'u', '\\u01D6': 'u', '\\u01DA': 'u', '\\u1EE7': 'u', '\\u016F': 'u', '\\u0171': 'u', '\\u01D4': 'u', '\\u0215': 'u', '\\u0217': 'u',\n\t'\\u01B0': 'u', '\\u1EEB': 'u', '\\u1EE9': 'u', '\\u1EEF': 'u', '\\u1EED': 'u', '\\u1EF1': 'u', '\\u1EE5': 'u', '\\u1E73': 'u', '\\u0173': 'u',\n\t'\\u1E77': 'u', '\\u1E75': 'u', '\\u0289': 'u', '\\u24E5': 'v', '\\uFF56': 'v', '\\u1E7D': 'v', '\\u1E7F': 'v', '\\u028B': 'v', '\\uA75F': 'v',\n\t'\\u028C': 'v', '\\uA761': 'vy', '\\u24E6': 'w', '\\uFF57': 'w', '\\u1E81': 'w', '\\u1E83': 'w', '\\u0175': 'w', '\\u1E87': 'w', '\\u1E85': 'w',\n\t'\\u1E98': 'w', '\\u1E89': 'w', '\\u2C73': 'w', '\\u24E7': 'x', '\\uFF58': 'x', '\\u1E8B': 'x', '\\u1E8D': 'x', '\\u24E8': 'y', '\\uFF59': 'y',\n\t'\\u1EF3': 'y', '\\u00FD': 'y', '\\u0177': 'y', '\\u1EF9': 'y', '\\u0233': 'y', '\\u1E8F': 'y', '\\u00FF': 'y', '\\u1EF7': 'y', '\\u1E99': 'y',\n\t'\\u1EF5': 'y', '\\u01B4': 'y', '\\u024F': 'y', '\\u1EFF': 'y', '\\u24E9': 'z', '\\uFF5A': 'z', '\\u017A': 'z', '\\u1E91': 'z', '\\u017C': 'z',\n\t'\\u017E': 'z', '\\u1E93': 'z', '\\u1E95': 'z', '\\u01B6': 'z', '\\u0225': 'z', '\\u0240': 'z', '\\u2C6C': 'z', '\\uA763': 'z'\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone-utils/lib/transliteration.cyr.js":"/*\n* Copyright (c) 2013 Alexander Prozorov (staltec@gmail.com)\n* https://github.com/Staltec/transliteration\n*\n* Copyright (c) 2011-2012 Anton Podviaznikov (anton@podviaznikov.com) by fork from https://github.com/podviaznikov/ua.transliteration\n*\n* Copyright (c) 2011 Enginimation Studio (http://enginimation.com).\n*\n* Copyright (c) 2014 Jed Watson (adaptation for keystone-utils)\n*\n* May be freely distributed under the MIT license.\n*\n*/\n\nexports.characterMap = {\n\t'лљ': 'A',\n\t'л░': 'a',\n\t'лЉ': 'B',\n\t'л▒': 'b',\n\t'лњ': 'V',\n\t'л▓': 'v',\n\t'лЊ': 'G',\t// russian\n\t'л│': 'g',\t// russian\n\t'мљ': 'G',\n\t'мЉ': 'g',\n\t'лћ': 'D',\n\t'л┤': 'd',\n\t'лЋ': 'E',\n\t'лх': 'e',\n\t'лЂ': 'E',\n\t'ЛЉ': 'e',\n\t'лё': 'Ye',\t// just on the word beginning\n\t'Лћ': 'ie',\n\t'лќ': 'Zh',\n\t'лХ': 'zh',\n\t'лЌ': 'Z',\n\t'ли': 'z',\n\t'лў': 'Y',\n\t'лИ': 'y',\n\t'лє': 'I',\n\t'Лќ': 'i',\n\t'лЄ': 'Yi',\t// just on the word beginning\n\t'ЛЌ': 'i',\n\t'лЎ': 'Y',\t// just on the word beginning\n\t'л╣': 'i',\n\t'лџ': 'K',\n\t'л║': 'k',\n\t'лЏ': 'L',\n\t'л╗': 'l',\n\t'лю': 'M',\n\t'л╝': 'm',\n\t'лЮ': 'N',\n\t'лй': 'n',\n\t'лъ': 'O',\n\t'лЙ': 'o',\n\t'лЪ': 'P',\n\t'л┐': 'p',\n\t'ла': 'R',\n\t'Лђ': 'r',\n\t'лА': 'S',\n\t'ЛЂ': 's',\n\t'лб': 'T',\n\t'Лѓ': 't',\n\t'лБ': 'U',\n\t'ЛЃ': 'u',\n\t'лц': 'F',\n\t'Лё': 'f',\n\t'лЦ': 'Kh',\n\t'ЛЁ': 'kh',\n\t'лд': 'Ts',\n\t'Лє': 'ts',\n\t'лД': 'Ch',\n\t'ЛЄ': 'ch',\n\t'ле': 'Sh',\n\t'Лѕ': 'sh',\n\t'лЕ': 'Shch',\n\t'ЛЅ': 'shch',\n\t'лФ': 'Y',\n\t'ЛІ': 'y',\n\t'лГ': 'E',\n\t'ЛЇ': 'e',\n\t'л«': 'Yu',\t// just on the word beginning\n\t'Лј': 'iu',\n\t'л»': 'Ya',\t// just on the word beginning\n\t'ЛЈ': 'ia',\n\t'лг': '',\t// not transliterated\n\t'Лї': '',\t// not transliterated\n\t'лф': '',\t// not transliterated\n\t'Лі': '',\t// not transliterated\n\t\"'\": ''\t\t// not transliterated\n};\n\nexports.regexp = {\n\tZgh: new RegExp('лЌл│', 'g'),\n\tzgh: new RegExp('лил│', 'g')\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/options.js":"var _ = require('underscore');\nvar callerId = require('caller-id');\nvar cloudinary = require('cloudinary');\nvar debug = require('debug')('keystone:core:options');\nvar mandrillapi = require('mandrill-api');\nvar path = require('path');\nvar url = require('url');\nvar utils = require('keystone-utils');\n\nfunction options() {\n\t\n\tvar exports = {};\n\n\t/**\n\t * This file contains methods specific to dealing with Keystone's options.\n\t * All exports are added to the Keystone.prototype\n\t */\n\n\t// Deprecated options that have been mapped to new keys\n\tvar remappedOptions = {\n\t\t'signin success': 'signin redirect',\n\t\t'signout': 'signout url'\n\t};\n\n\t// Determines if path is absolute or relative\n\tfunction isAbsolutePath(value) {\n\t\treturn path.resolve(value) === path.normalize(value).replace(new RegExp(path.sep + '$'), '');\n\t}\n\n\t/**\n\t * Sets keystone options\n\t *\n\t * ####Example:\n\t *\n\t *     keystone.set('user model', 'User') // sets the 'user model' option to `User`\n\t *\n\t * @param {String} key\n\t * @param {String} value\n\t * @api public\n\t */\n\texports.set = function(key, value) {\n\n\t\tif (arguments.length === 1) {\n\t\t\treturn this._options[key];\n\t\t}\n\t\t\n\t\tif (remappedOptions[key]) {\n\t\t\tif (this.get('logger')) {\n\t\t\t\tconsole.log('\\nWarning: the `' + key + '` option has been deprecated. Please use `' + remappedOptions[key] + '` instead.\\n\\n' +\n\t\t\t\t\t'Support for `' + key + '` will be removed in a future version.');\n\t\t\t}\n\t\t\tkey = remappedOptions[key];\n\t\t}\n\n\t\tswitch (key) {\n\t\t\t// warn on deprecated/old/invalid settings\n\t\t\tcase 'less middleware options':\n\t\t\tcase 'less parser options':\n\t\t\tcase 'less compiler options':\n\t\t\t\tif (this.get('logger')) {\n\t\t\t\t\tconsole.log('\\nWarning: less-middleware has changed the way it handles options, and ' +\n\t\t\t\t\t\t'\\n`' + key + '` is no longer supported. You should simply use `less options` now;' +\n\t\t\t\t\t\t'\\nsee https://github.com/emberfeather/less.js-middleware for details.');\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t\t// handle special settings\n\t\t\tcase 'cloudinary config':\n\t\t\t\tif (_.isString(value)) {\n\t\t\t\t\tvar parts = url.parse(value, true);\n\t\t\t\t\tvar auth = parts.auth ? parts.auth.split(':') : [];\n\t\t\t\t\tvalue = {\n\t\t\t\t\t\tcloud_name: parts.host,\n\t\t\t\t\t\tapi_key: auth[0],\n\t\t\t\t\t\tapi_secret: auth[1],\n\t\t\t\t\t\tprivate_cdn: parts.pathname != null,\n\t\t\t\t\t\tsecure_distribution: parts.pathname && parts.pathname.substring(1)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (_.isObject(value)) {\n\t\t\t\t\tcloudinary.config(value);\n\t\t\t\t}\n\t\t\t\tvalue = cloudinary.config();\n\t\t\tbreak;\n\t\t\tcase 'mandrill api key':\n\t\t\t\tif (value) {\n\t\t\t\t\tdebug('found mandril key');\n\t\t\t\t\tthis.mandrillAPI = new mandrillapi.Mandrill(value);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'auth':\n\t\t\t\tif (value === true && !this.get('session')) {\n\t\t\t\t\tdebug('setting session for auth');\n\t\t\t\t\tthis.set('session', true);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'nav':\n\t\t\t\tdebug('setting nav');\n\t\t\t\tthis.nav = this.initNav(value);\n\t\t\tbreak;\n\t\t\tcase 'mongo':\n\t\t\t\tif ('string' !== typeof value) {\n\t\t\t\t\tif (Array.isArray(value) && (value.length === 2 || value.length === 3)) {\n\t\t\t\t\t\tconsole.log('\\nWarning: using an array for the `mongo` option has been deprecated.\\nPlease use a mongodb connection string, e.g. mongodb://localhost/db_name instead.\\n\\n' +\n\t\t\t\t\t\t\t'Support for arrays as the `mongo` setting will be removed in a future version.');\n\t\t\t\t\t\tvalue = (value.length === 2) ? 'mongodb://' + value[0] + '/' + value[1] : 'mongodb://' + value[0] + ':' + value[2] + '/' + value[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('\\nInvalid Configuration:\\nThe `mongo` option must be a mongodb connection string, e.g. mongodb://localhost/db_name\\n');\n\t\t\t\t\t\tprocess.exit(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'module root':\n\t\t\t\t// if relative path is used, resolve it based on the caller's path\n\t\t\t\tif (!isAbsolutePath(value)) {\n\t\t\t\t\tvar caller = callerId.getData();\n\t\t\t\t\tvalue = path.resolve(path.dirname(caller.filePath), value);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'app':\n\t\t\t\tthis.app = value;\n\t\t\tbreak;\n\t\t\tcase 'mongoose':\n\t\t\t\tthis.mongoose = value;\n\t\t\tbreak;\n\t\t\tcase 'frame guard':\n\t\t\t\tvar validFrameGuardOptions = ['deny', 'sameorigin'];\n\n\t\t\t\tif (value === true) {\n\t\t\t\t\tvalue = 'deny';\n\t\t\t\t}\n\t\t\t\tif (utils.isString(value)) {\n\t\t\t\t\tvalue = value.toLowerCase();\n\t\t\t\t\tif (validFrameGuardOptions.indexOf(value) < 0) {\n\t\t\t\t\t\tvalue = false;\n\t\t\t\t\t}\n\t\t\t\t} else if ('boolean' !== typeof value) {\n\t\t\t\t\tvalue = false;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tthis._options[key] = value;\n\t\treturn this;\n\t};\n\n\n\t/**\n\t * Sets multiple keystone options.\n\t *\n\t * ####Example:\n\t *\n\t *     keystone.options({test: value}) // sets the 'test' option to `value`\n\t *\n\t * @param {Object} options\n\t * @api public\n\t */\n\n\texports.options = function(options) {\n\t\tif (!arguments.length) {\n\t\t\treturn this._options;\n\t\t}\n\t\tif (utils.isObject(options)) {\n\t\t\tdebug('settings options');\n\t\t\tvar keys = Object.keys(options),\n\t\t\t\ti = keys.length,\n\t\t\t\tk;\n\t\t\twhile (i--) {\n\t\t\t\tk = keys[i];\n\t\t\t\tthis.set(k, options[k]);\n\t\t\t}\n\t\t}\n\t\treturn this._options;\n\t};\n\n\n\t/**\n\t * Gets keystone options\n\t *\n\t * ####Example:\n\t *\n\t *     keystone.get('test') // returns the 'test' value\n\t *\n\t * @param {String} key\n\t * @api public\n\t */\n\n\texports.get = exports.set;\n\n\t/**\n\t * Gets an expanded path option, expanded to include moduleRoot if it is relative\n\t *\n\t * ####Example:\n\t *\n\t *     keystone.get('pathOption', 'defaultValue')\n\t *\n\t * @param {String} key\n\t * @param {String} defaultValue\n\t * @api public\n\t */\n\n\texports.getPath = function(key, defaultValue) {\n\t\treturn this.expandPath(this.get(key) || defaultValue);\n\t};\n\n\t/**\n\t * Expands a path to include moduleRoot if it is relative\n\t *\n\t * @param {String} pathValue\n\t * @api public\n\t */\n\n\texports.expandPath = function(pathValue) {\n\t\tpathValue = ('string' === typeof pathValue && pathValue.substr(0, 1) !== path.sep && pathValue.substr(1, 2) !== ':\\\\')\n\t\t\t? path.join(this.get('module root'), pathValue)\n\t\t\t: pathValue;\n\t\treturn pathValue;\n\t};\n\t\n\treturn exports;\n\t\n}\n\nmodule.exports = options;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/bindEmailTestRoutes.js":"var _ = require('underscore');\n\nfunction bindEmailTestRoutes(app, emails) {\n\t\n\tvar keystone = this;\n\t\n\tvar handleError = function(req, res, err) {\n\t\tif (res.err) {\n\t\t\tres.err(err);\n\t\t} else {\n\t\t\t// TODO: Nicer default error handler\n\t\t\tres.status(500).send(JSON.stringify(err));\n\t\t}\n\t};\n\t\n\t// TODO: Index of email tests, and custom email test 404's (currently bounces to list 404)\n\t\n\t_.each(emails, function(vars, key) {\n\t\t\n\t\tvar render = function(err, req, res, locals) {// eslint-disable-line no-unused-vars, handle-callback-err\n\t\t\tnew keystone.Email(key).render(locals, function(err, email) {\n\t\t\t\tif (err) {\n\t\t\t\t\thandleError(req, res, err);\n\t\t\t\t} else {\n\t\t\t\t\tres.send(email.html);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\t\n\t\tapp.get('/keystone/test-email/' + key, function(req, res) {\n\t\t\tif ('function' === typeof vars) {\n\t\t\t\tvars(req, res, function(err, locals) {\n\t\t\t\t\trender(err, req, res, locals);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\trender(null, req, res, vars);\n\t\t\t}\n\t\t});\n\t\t\n\t});\n\t\n\treturn this;\n\t\n}\n\nmodule.exports = bindEmailTestRoutes;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/connect.js":"/**\n * Connects keystone to the application's mongoose instance.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *\n *     keystone.connect(mongoose);\n *\n * @param {Object} connections\n * @api public\n */\n\nvar debug = require('debug')('keystone:core:connect');\n\nfunction connect() {\n\tvar warningMsg = 'keystone.connect() is now deprecated and will not be available in future versions of KeystoneJS\\n' +\n\t\t'It has been replaced with the Keystone \"app\" and \"mongoose\" options.\\n' +\n\t\t'Due to changes in Express 4, \"keystone.connect()\" no longer works as expected.\\n\\n' +\n\t\t'See http://localhost:8080/docs/configuration#options-project for more information.';\n\n\tthis.console.err('Deprecation Warning', warningMsg);\n\n\t// detect type of each argument\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tif (arguments[i].constructor.name === 'Mongoose') {\n\t\t\tdebug('detected mongoose');\n\t\t\tthis.mongoose = arguments[i];\n\t\t} else if (arguments[i].name === 'app') {\n\t\t\tdebug('detected express app');\n\t\t\tthis.app = arguments[i];\n\t\t}\n\t}\n\treturn this;\n}\n\nmodule.exports = connect;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/createItems.js":"/**\n* Creates multiple items in one or more Lists\n*/\n\nvar _ = require('underscore');\nvar async = require('async');\nvar debug = require('debug')('keystone:core:createItems');\nvar utils = require('keystone-utils');\n\nfunction createItems(data, ops, callback) {\n\t\n\tvar keystone = this;\n\t\n\tvar options = {\n\t\tverbose: false,\n\t\tstrict: true,\n\t\trefs: null\n\t};\n\t\n\tvar dashes = '------------------------------------------------';\n\t\n\tif (!_.isObject(data)) {\n\t\tthrow new Error('keystone.createItems() requires a data object as the first argument.');\n\t}\n\t\n\tif (_.isObject(ops)) {\n\t\t_.extend(options, ops);\n\t}\n\t\n\tif (_.isFunction(ops)) {\n\t\tcallback = ops;\n\t}\n\t\n\tvar lists = _.keys(data),\n\t\trefs = options.refs || {},\n\t\tstats = {};\n\n\t// logger function\n\tfunction writeLog(data) {\n\t\tconsole.log(keystone.get('name') + ': ' + data);\n\t}\n\n\tasync.waterfall([\n\t\t\n\t\t// create items\n\t\tfunction(next) {\n\t\t\tdebug('create items');\n\t\t\tasync.eachSeries(lists, function(key, doneList) {\n\t\t\t\t\n\t\t\t\tvar list = keystone.list(key),\n\t\t\t\t\trelationshipPaths = _.where(list.fields, { type: 'relationship' }).map(function(i) { return i.path; });\n\t\t\t\t\n\t\t\t\tif (!list) {\n\t\t\t\t\tif (options.strict) {\n\t\t\t\t\t\treturn doneList({\n\t\t\t\t\t\t\ttype: 'invalid list',\n\t\t\t\t\t\t\tmessage: 'List key ' + key + ' is invalid.'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (options.verbose) {\n\t\t\t\t\t\twriteLog('Skipping invalid list: ' + key);\n\t\t\t\t\t}\n\t\t\t\t\treturn doneList();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!refs[list.key]) {\n\t\t\t\t\trefs[list.key] = {};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstats[list.key] = {\n\t\t\t\t\tsingular: list.singular,\n\t\t\t\t\tplural: list.plural,\n\t\t\t\t\tcreated: 0,\n\t\t\t\t\twarnings: 0\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tvar itemsProcessed = 0,\n\t\t\t\t\ttotalItems = data[key].length;\n\t\t\t\t\n\t\t\t\tif (options.verbose) {\n\t\t\t\t\twriteLog(dashes);\n\t\t\t\t\twriteLog('Processing list: ' + key);\n\t\t\t\t\twriteLog('Items to create: ' + totalItems);\n\t\t\t\t\twriteLog(dashes);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tasync.eachSeries(data[key], function(data, doneItem) {\n\t\t\t\t\t\n\t\t\t\t\titemsProcessed++;\n\t\t\t\t\t\n\t\t\t\t\t// Evaluate function properties to allow generated values (excluding relationships)\n\t\t\t\t\t_.keys(data).forEach(function(i) {\n\t\t\t\t\t\tif (_.isFunction(data[i]) && relationshipPaths.indexOf(i) === -1) {\n\t\t\t\t\t\t\tdata[i] = data[i]();\n\t\t\t\t\t\t\tif (options.verbose) {\n\t\t\t\t\t\t\t\twriteLog('Generated dynamic value for [' + i + ']: ' + data[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tvar doc = data.__doc = new list.model();\n\t\t\t\t\t\n\t\t\t\t\tif (data.__ref) {\n\t\t\t\t\t\trefs[list.key][data.__ref] = doc;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_.each(list.fields, function(field) {\n\t\t\t\t\t\t// skip relationship fields on the first pass.\n\t\t\t\t\t\tif (field.type !== 'relationship') {\n\t\t\t\t\t\t\tfield.updateItem(doc, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tif (options.verbose) {\n\t\t\t\t\t\tvar documentName = list.getDocumentName(doc);\n\t\t\t\t\t\twriteLog('Creating item [' + itemsProcessed + ' of ' + totalItems + '] - ' + documentName);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdoc.save(function(err) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\terr.model = key;\n\t\t\t\t\t\t\terr.data = data;\n\t\t\t\t\t\t\tdebug('error saving ', key);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstats[list.key].created++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdoneItem(err);\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t}, doneList);\n\t\t\t\t\n\t\t\t}, next);\n\t\t},\n\t\t\n\t\t// link items\n\t\tfunction(next) {\n\t\t\t\n\t\t\tasync.each(lists, function(key, doneList) {\n\t\t\t\t\n\t\t\t\tvar list = keystone.list(key),\n\t\t\t\t\trelationships = _.where(list.fields, { type: 'relationship' });\n\t\t\t\t\n\t\t\t\tif (!list || !relationships.length) {\n\t\t\t\t\treturn doneList();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar itemsProcessed = 0,\n\t\t\t\t\ttotalItems = data[key].length;\n\t\t\t\t\n\t\t\t\tif (options.verbose) {\n\t\t\t\t\twriteLog(dashes);\n\t\t\t\t\twriteLog('Processing relationships for: ' + key);\n\t\t\t\t\twriteLog('Items to process: ' + totalItems);\n\t\t\t\t\twriteLog(dashes);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tasync.each(data[key], function(srcData, doneItem) {\n\t\t\t\t\t\n\t\t\t\t\tvar doc = srcData.__doc,\n\t\t\t\t\t\trelationshipsUpdated = 0;\n\t\t\t\t\t\n\t\t\t\t\titemsProcessed++;\n\t\t\t\t\t\n\t\t\t\t\tif (options.verbose) {\n\t\t\t\t\t\tvar documentName = list.getDocumentName(doc);\n\t\t\t\t\t\twriteLog('Processing item [' + itemsProcessed + ' of ' + totalItems + '] - ' + documentName);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tasync.each(relationships, function(field, doneField) {\n\t\t\t\t\t\n\t\t\t\t\t\tvar fieldValue = null,\n\t\t\t\t\t\t\trefsLookup = null;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!field.path) {\n\t\t\t\t\t\t\twriteLog('WARNING:  Invalid relationship (undefined list path) [List: ' + key + ']');\n\t\t\t\t\t\t\tstats[list.key].warnings++;\n\t\t\t\t\t\t\treturn doneField();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfieldValue = srcData[field.path];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!field.refList) {\n\t\t\t\t\t\t\tif (fieldValue) {\n\t\t\t\t\t\t\t\twriteLog('WARNING:  Invalid relationship (undefined reference list) [list: ' + key + '] [path: ' + fieldValue + ']');\n\t\t\t\t\t\t\t\tstats[list.key].warnings++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn doneField();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!field.refList.key) {\n\t\t\t\t\t\t\twriteLog('WARNING:  Invalid relationship (undefined ref list key) [list: ' + key + '] [field.refList: ' + field.refList + '] [fieldValue: ' + fieldValue + ']');\n\t\t\t\t\t\t\tstats[list.key].warnings++;\n\t\t\t\t\t\t\treturn doneField();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trefsLookup = refs[field.refList.key];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!fieldValue) {\n\t\t\t\t\t\t\treturn doneField();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// populate relationships from saved refs\n\t\t\t\t\t\tif (_.isFunction(fieldValue)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\trelationshipsUpdated++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar fn = fieldValue,\n\t\t\t\t\t\t\t\targsRegExp = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m,\n\t\t\t\t\t\t\t\tlists = fn.toString().match(argsRegExp)[1].split(',').map(function(i) { return i.trim(); }),\n\t\t\t\t\t\t\t\targs = lists.map(function(i) {\n\t\t\t\t\t\t\t\t\treturn keystone.list(i);\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\tquery = fn.apply(keystone, args);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tquery.exec(function(err, results) {\n\t\t\t\t\t\t\t\tif (err) { debug('error ', err); }\n\t\t\t\t\t\t\t\tif (field.many) {\n\t\t\t\t\t\t\t\t\tdoc.set(field.path, results || []);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdoc.set(field.path, (results && results.length) ? results[0] : undefined);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdoneField(err);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (_.isArray(fieldValue)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (field.many) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tvar refsArr = _.compact(fieldValue.map(function(ref) {\n\t\t\t\t\t\t\t\t\treturn refsLookup && refsLookup[ref] ? refsLookup[ref].id : undefined;\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (options.strict && refsArr.length !== fieldValue.length) {\n\t\t\t\t\t\t\t\t\treturn doneField({\n\t\t\t\t\t\t\t\t\t\ttype: 'invalid ref',\n\t\t\t\t\t\t\t\t\t\tsrcData: srcData,\n\t\t\t\t\t\t\t\t\t\tmessage: 'Relationship ' + list.key + '.' + field.path + ' contains an invalid reference.'\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\trelationshipsUpdated++;\n\t\t\t\t\t\t\t\tdoc.set(field.path, refsArr);\n\t\t\t\t\t\t\t\tdoneField();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn doneField({\n\t\t\t\t\t\t\t\t\ttype: 'invalid data',\n\t\t\t\t\t\t\t\t\tsrcData: srcData,\n\t\t\t\t\t\t\t\t\tmessage: 'Single-value relationship ' + list.key + '.' + field.path + ' provided as an array.'\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (_.isString(fieldValue)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar refItem = refsLookup && refsLookup[fieldValue];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (!refItem) {\n\t\t\t\t\t\t\t\treturn options.strict ? doneField({\n\t\t\t\t\t\t\t\t\ttype: 'invalid ref',\n\t\t\t\t\t\t\t\t\tsrcData: srcData,\n\t\t\t\t\t\t\t\t\tmessage: 'Relationship ' + list.key + '.' + field.path + ' contains an invalid reference: \"' + fieldValue + '\".'\n\t\t\t\t\t\t\t\t}) : doneField();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\trelationshipsUpdated++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdoc.set(field.path, field.many ? [refItem.id] : refItem.id);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdoneField();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (fieldValue && fieldValue.id) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\trelationshipsUpdated++;\n\t\t\t\t\t\t\tdoc.set(field.path, field.many ? [fieldValue.id] : fieldValue.id);\n\t\t\t\t\t\t\tdoneField();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn doneField({\n\t\t\t\t\t\t\t\ttype: 'invalid data',\n\t\t\t\t\t\t\t\tsrcData: srcData,\n\t\t\t\t\t\t\t\tmessage: 'Relationship ' + list.key + '.' + field.path + ' contains an invalid data type.'\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}, function(err) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tdebug('error ', err);\n\t\t\t\t\t\t\treturn doneItem(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (options.verbose) {\n\t\t\t\t\t\t\twriteLog('Populated ' + utils.plural(relationshipsUpdated, '* relationship', '* relationships') + '.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (relationshipsUpdated) {\n\t\t\t\t\t\t\tdoc.save(doneItem);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdoneItem();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t}, doneList);\n\t\t\t\t\n\t\t\t}, next);\n\t\t}\n\t\t\n\t], function(err) {\n\n\t\tif (err) {\n\t\t\tconsole.error(err);\n\t\t\tif ('stack' in err) {\n\t\t\t\tconsole.trace(err.stack);\n\t\t\t}\n\t\t\treturn callback && callback(err);\n\t\t}\n\n\t\tvar msg = '\\nSuccessfully created:\\n';\n\t\t_.each(stats, function(list) {\n\t\t\tmsg += '\\n*   ' + utils.plural(list.created, '* ' + list.singular, '* ' + list.plural);\n\t\t\tif (list.warnings) {\n\t\t\t\tmsg += '\\n    ' + utils.plural(list.warnings, '* warning', '* warnings');\n\t\t\t}\n\t\t});\n\t\tstats.message = msg + '\\n';\n\t\t\n\t\tcallback(null, stats);\n\t\t\n\t});\n\t\n}\n\nmodule.exports = createItems;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/getOrphanedLists.js":"var _ = require('underscore');\n\n/**\n * Retrieves orphaned lists (those not in a nav section)\n */\n\nfunction getOrphanedLists() {\n\tif (!this.nav) {\n\t\treturn [];\n\t}\n\treturn _.filter(this.lists, function(list, key) {\n\t\tif (list.get('hidden')) return false;\n\t\treturn (!this.nav.by.list[key]) ? list : false;\n\t}.bind(this));\n}\n\nmodule.exports = getOrphanedLists;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/importer.js":"var fs = require('fs');\nvar debug = require('debug')('keystone:core:importer');\nvar path = require('path');\n\n/**\n * Returns a function that looks in a specified path relative to the current\n * directory, and returns all .js modules it (recursively).\n *\n * ####Example:\n *\n *     var importRoutes = keystone.importer(__dirname);\n *\n *     var routes = {\n *         site: importRoutes('./site'),\n *         api: importRoutes('./api')\n *     };\n *\n * @param {String} rel__dirname\n * @api public\n */\n\nfunction dispatchImporter(rel__dirname) {\n\t\n\tfunction importer(from) {\n\t\tdebug('importing ', from);\n\t\tvar imported = {};\n\t\tvar joinPath = function() {\n\t\t\treturn '.' + path.sep + path.join.apply(path, arguments);\n\t\t};\n\t\t\n\t\tvar fsPath = joinPath(path.relative(process.cwd(), rel__dirname), from);\n\t\tfs.readdirSync(fsPath).forEach(function(name) {\n\t\t\tvar info = fs.statSync(path.join(fsPath, name));\n\t\t\tdebug('recur');\n\t\t\tif (info.isDirectory()) {\n\t\t\t\timported[name] = importer(joinPath(from, name));\n\t\t\t} else {\n\t\t\t\t// only import files that we can `require`\n\t\t\t\tvar ext = path.extname(name);\n\t\t\t\tvar base = path.basename(name, ext);\n\t\t\t\tif (require.extensions[ext]) {\n\t\t\t\t\timported[base] = require(path.join(rel__dirname, from, name));\n\t\t\t\t} else {\n\t\t\t\t\tdebug('cannot require ', ext);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn imported;\n\t}\n\t\n\treturn importer;\n\t\n}\n\nmodule.exports = dispatchImporter;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/init.js":"/**\n * Initialises Keystone in encapsulated mode.\n *\n * Creates an Express app and configures it if none has been connected.\n *\n * Also connects to the default mongoose instance if none has been connected.\n *\n * Accepts an options argument.\n *\n * Returns `this` to allow chaining.\n *\n * @param {Object} options\n * @api public\n */\n\nvar debug = require('debug')('keystone:core:init');\n\nfunction init(options) {\n\tdebug('initializing app');\n\tthis.options(options);\n\t\n\tif (!this.app) {\n\t\tthis.set('app', require('express')());\n\t}\n\t\n\tif (!this.mongoose) {\n\t\tthis.set('mongoose', require('mongoose'));\n\t}\n\t\n\treturn this;\n\t\n}\n\nmodule.exports = init;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/initNav.js":"/**\n * Initialises Keystone's internal nav config\n *\n * @param {Object} nav\n * @api private\n */\n\nvar _ = require('underscore');\nvar debug = require('debug')('keystone:core:initNav');\nvar utils = require('keystone-utils');\n\nfunction initNav(sections) {\n\tdebug('init nav');\n\tvar keystone = this;\n\t\n\tvar nav = {\n\t\tsections: [],\n\t\tby: {\n\t\t\tlist: {},\n\t\t\tsection: {}\n\t\t}\n\t};\n\t\n\tif (!sections) {\n\t\tsections = {};\n\t\tnav.flat = true;\n\t\t_.each(this.lists, function(list) {\n\t\t\tif (list.get('hidden')) return;\n\t\t\tsections[list.path] = [list.path];\n\t\t});\n\t}\n\t\n\t_.each(sections, function(section, key) {\n\t\tif ('string' === typeof section) {\n\t\t\tsection = [section];\n\t\t}\n\t\tsection = {\n\t\t\tlists: section,\n\t\t\tlabel: nav.flat ? keystone.list(section[0]).label : utils.keyToLabel(key)\n\t\t};\n\t\tsection.key = key;\n\t\tsection.lists = _.map(section.lists, function(i) {\n\t\t\tif (_.isString(i)) {\n\t\t\t\tvar list = keystone.list(i);\n\t\t\t\tif (!list) {\n\t\t\t\t\tthrow new Error('Invalid Keystone Option (nav): list ' + i + ' has not been defined.\\n');\n\t\t\t\t}\n\t\t\t\tif (list.get('hidden')) {\n\t\t\t\t\tthrow new Error('Invalid Keystone Option (nav): list ' + i + ' is hidden.\\n');\n\t\t\t\t}\n\t\t\t\tnav.by.list[list.key] = section;\n\t\t\t\treturn {\n\t\t\t\t\tkey: list.key,\n\t\t\t\t\tlabel: list.label,\n\t\t\t\t\tpath: list.path\n\t\t\t\t};\n\t\t\t} else if (_.isObject(i)) {\n\t\t\t\tif (!_.has(i, 'key')) {\n\t\t\t\t\tthrow new Error('Invalid Keystone Option (nav): object ' + i + ' requires a \"key\" property.\\n');\n\t\t\t\t}\n\t\t\t\ti.label = i.label || utils.keyToLabel(key);\n\t\t\t\ti.path = i.path || utils.keyToPath(key);\n\t\t\t\ti.external = true;\n\t\t\t\tnav.by.list[i.key] = section;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tthrow new Error('Invalid Keystone Option (nav): ' + i + ' is in an unrecognized format.\\n');\n\t\t});\n\t\tif (section.lists.length) {\n\t\t\tnav.sections.push(section);\n\t\t\tnav.by.section[section.key] = section;\n\t\t}\n\t});\n\t\n\treturn nav;\n}\n\nmodule.exports = initNav;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/list.js":"/**\n * Registers or retrieves a list\n */\n\nfunction list(arg) {\n\tif (arg && arg.constructor === this.List) {\n\t\tthis.lists[arg.key] = arg;\n\t\tthis.paths[arg.path] = arg.key;\n\t\treturn arg;\n\t}\n\tvar ret = this.lists[arg] || this.lists[this.paths[arg]];\n\tif (!ret) throw new ReferenceError('Unknown keystone list ' + JSON.stringify(arg));\n\treturn ret;\n}\n\nmodule.exports = list;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/mount.js":"/**\n * Configures a Keystone app in encapsulated mode, but does not start it.\n *\n * Connects to the database and runs updates and then calls back.\n *\n * This is the code-path to use if you'd like to mount the keystone app as a sub-app in another express application.\n *\n *   var app = express();\n *\n *   //...do your normal express setup stuff, add middleware and routes (but not static content or error handling middleware yet)\n *\n *   keystone.mount('/content', app, function() {\n *\t //put your app's static content and error handling middleware here and start your server\n *   });\n *\n * Events are fired during initialisation to allow customisation, including:\n *\n *   - onMount\n *\n * If the events argument is a function, it is assumed to be the mounted event.\n *\n *\n * ####Options:\n *\n * Keystone supports the following options specifically for running in encapsulated mode (with no embedded server):\n *\n *   - name\n *   - port\n *   - views\n *   - view engine\n *   - compress\n *   - favico\n *   - less\n *   - static\n *   - headless\n *   - logger\n *   - cookie secret\n *   - session\n *   - 404\n *   - 500\n *   - routes\n *   - locals\n *   - auto update\n *\n *\n * @api public\n */\n\nvar _ = require('underscore');\nvar debug = require('debug')('keystone:core:mount');\nvar P = require('bluebird');\nvar express = require('express');\nvar path = require('path');\nvar utils = require('keystone-utils');\nvar favicon = require('serve-favicon');\nvar morgan = require('morgan');\nvar methodOverride = require('method-override');\nvar session = require('express-session');\nvar multer = require('multer');\nvar bodyParser = require('body-parser');\nvar cookieParser = require('cookie-parser');\nvar compression = require('compression');\n\nvar dashes = '\\n------------------------------------------------\\n';\n\nfunction mount(mountPath, parentApp, events) {\n  debug('mounting');\n\t// Validate the express app instance\n\n\tif (!this.app) {\n\t\tconsole.error('\\nKeystoneJS Initialisaton Error:\\n\\napp must be initialised. Call keystone.init() or keystone.connect(new Express()) first.\\n');\n\t\tprocess.exit(1);\n\t}\n\n\t// Localise references to this for closures\n\n\tvar keystone = this;\n\tvar app = this.app;\n\n\t// this.nativeApp indicates keystone has been mounted natively\n\t// (not as part of a custom middleware stack)\n\t//\n\tthis.nativeApp = true;\n\n\t// Initialise the mongo connection url\n\n\tif (!this.get('mongo')) {\n\t\tvar dbName = this.get('db name') || utils.slug(this.get('name'));\n\t\tvar dbUrl = process.env.MONGO_URI || process.env.MONGO_URL || process.env.MONGODB_URL || process.env.MONGOLAB_URI || process.env.MONGOLAB_URL || (process.env.OPENSHIFT_MONGODB_DB_URL || 'mongodb://localhost/') + dbName;\n\t\tdebug('setting DB URI to : ' + dbUrl);\n\t\tthis.set('mongo', dbUrl);\n\t}\n\n\t// Initialise and validate session options\n\n\tif (!this.get('cookie secret')) {\n\t\tconsole.error('\\nKeystoneJS Configuration Error:\\n\\nPlease provide a `cookie secret` value for session encryption.\\n');\n\t\tprocess.exit(1);\n\t}\n\n\tvar sessionOptions = this.get('session options');\n\n\tif (!_.isObject(sessionOptions)) {\n\t\tsessionOptions = {};\n\t}\n\n\tif (!sessionOptions.key) {\n\t\tsessionOptions.key = 'keystone.sid';\n\t}\n\n\t_.defaults(sessionOptions, {\n\t\tresave: false,\n\t\tsecret: this.get('cookie secret'),\n\t\tsaveUninitialized: false\n\t});\n\n\tsessionOptions.cookieParser = cookieParser(this.get('cookie secret'));\n\n\tvar sessionStore = this.get('session store');\n\n\tvar sessionStorePromise;\n\n\tif (typeof sessionStore === 'function') {\n\t\tsessionOptions.store = sessionStore(session);\n\t} else if (sessionStore) {\n\n\t\tvar sessionStoreOptions = this.get('session store options') || {};\n\n\t\t// Perform any session store specific configuration or exit on an unsupported session store\n\n\t\tif (sessionStore === 'mongo') {\n\t\t\tsessionStore = 'connect-mongo';\n\t\t} else if (sessionStore === 'redis') {\n\t\t\tsessionStore = 'connect-redis';\n\t\t}\n\n\t\tswitch (sessionStore) {\n\t\t\tcase 'connect-mongo':\n\t\t\t\tdebug('using mongo for session store');\n\t\t\t\tif (process.version.substr(0, 4) === 'v0.1') {\n\t\t\t\t\tsessionStore = 'connect-mongo/es5';\n\t\t\t\t}\n\t\t\t\t_.defaults(sessionStoreOptions, {\n\t\t\t\t\tcollection: 'app_sessions',\n\t\t\t\t\turl: this.get('mongo')\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'connect-mongostore':\n\t\t\t\tdebug('using connect-mongostore for session store');\n\t\t\t\t_.defaults(sessionStoreOptions, {\n\t\t\t\t\tcollection: 'app_sessions'\n\t\t\t\t});\n\t\t\t\tif (!sessionStoreOptions.db) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'\\nERROR: connect-mongostore requires `session store options` to be set.' +\n\t\t\t\t\t\t'\\n' +\n\t\t\t\t\t\t'\\nSee http://keystonejs.com/docs/configuration#options-database for details.' +\n\t\t\t\t\t'\\n');\n\t\t\t\t\tprocess.exit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'connect-redis':\n\t\t\t\tdebug('using redis for session store');\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error(\n\t\t\t\t\t'\\nERROR: unsupported session store ' + sessionStore + '.' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\\nSee http://keystonejs.com/docs/configuration#options-database for details.' +\n\t\t\t\t'\\n');\n\t\t\t\tprocess.exit(1);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Initialize the session store\n\t\ttry {\n\t\t\tvar SessionStore = require(sessionStore)(session);\n\t\t\tsessionStorePromise = new P(function(resolve) {\n\t\t\t\tsessionOptions.store = new SessionStore(sessionStoreOptions, resolve);\n\t\t\t\tsessionOptions.store.on('connect', resolve);\n\t\t\t\tsessionOptions.store.on('connected', resolve);\n\t\t\t\tsessionOptions.store.on('disconnect', function() {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'\\nThere was an error connecting to the ' + sessionStore + ' session store.' +\n\t\t\t\t\t'\\n');\n\t\t\t\t\tprocess.exit(1);\n\t\t\t\t});\n\t\t\t});\n\t\t} catch(e) {\n\t\t\tif (e.code === 'MODULE_NOT_FOUND') {\n\t\t\t\tconsole.error(\n\t\t\t\t\t'\\n' + e.toString() +\n\t\t\t\t\t'\\nTo use ' + this.get('session store') + ' as a `session store` option, run:' +\n\t\t\t\t\t'\\nnpm install ' + sessionStore + ' --save' +\n\t\t\t\t'\\n');\n\t\t\t\tprocess.exit(1);\n\t\t\t} else {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}\n\n\t// expose initialised session and options\n\tthis.set('session options', sessionOptions);\n\tthis.set('express session', session(sessionOptions));\n\n\n\t// wrangle arguments\n\tif (arguments.length === 1) {\n\t\tevents = arguments[0];\n\t\tmountPath = null;\n\t}\n\n\tif ('function' === typeof events) {\n\t\tevents = { onMount: events };\n\t}\n\n\tif (!events) events = {};\n\n\t/* Express sub-app mounting to external app at a mount point (if specified) */\n\n\tif (mountPath) {\n\t\t//fix root-relative keystone urls for assets (gets around having to re-write all the keystone templates)\n\t\tparentApp.all(/^\\/keystone($|\\/.*)/, function(req, res, next) {\n\t\t\treq.url = (mountPath + req.url).replace(new RegExp(/\\/\\//, 'g'), '/');\n\t\t\tnext();\n\t\t});\n\n\t\tparentApp.use(mountPath, app);\n\t}\n\n\t/* Keystone's encapsulated Express App Setup */\n\n\t// Allow usage of custom view engines\n\tif (this.get('custom engine')) {\n\t\tapp.engine(this.get('view engine'), this.get('custom engine'));\n\t}\n\n\t// Set location of view templates and view engine\n\tapp.set('views', this.getPath('views') || path.sep + 'views');\n\tapp.set('view engine', this.get('view engine'));\n\n\t// Apply locals\n\tif (utils.isObject(this.get('locals'))) {\n\t\t_.extend(app.locals, this.get('locals'));\n\t}\n\n\t// Indent HTML everywhere, except production\n\tif (this.get('env') !== 'production' && app.locals.pretty === undefined) {\n\t\tapp.locals.pretty = true;\n\t}\n\n\t// Default view caching logic\n\tapp.set('view cache', this.get('env') === 'production' ? true : false);\n\n\t// Setup view caching from app settings\n\tif (this.get('view cache') !== undefined) {\n\t\tapp.set('view cache', this.get('view cache'));\n\t}\n\n\t// Compress response bodies\n\tif (this.get('compress')) {\n\t\tapp.use(compression());\n\t}\n\n\t// Pre static config\n\tif ('function' === typeof this.get('pre:static')) {\n\t\tdebug('configuring pre:static middleware');\n\t\tthis.get('pre:static')(app);\n\t}\n\tapp.use(function(req, res, next) {\n\t\tkeystone.callHook('pre:static', req, res, next);\n\t});\n\n\t// Serve static assets\n\n\tif (this.get('favico')) {\n\t\tapp.use(favicon(this.getPath('favico')));\n\t}\n\n\t// unless the headless option is set (which disables the Admin UI),\n\t// add the Admin UI's Static Router for public resources\n\tif (!this.get('headless')) {\n\t\tapp.use('/keystone', require('../../admin/app/static'));\n\t}\n\n\t// the less option can be a single path, or array of paths\n\t// when set, we configure the less middleware\n\n\tvar lessPaths = this.get('less');\n\tvar lessOptions = this.get('less options') || {};\n\n\tif (_.isString(lessPaths)) {\n\t\tlessPaths = [lessPaths];\n\t}\n\n\tif (_.isArray(lessPaths)) {\n\t\t_.each(lessPaths, function(value) {\n\t\t\tapp.use(require('less-middleware')(this.expandPath(value), lessOptions));\n\t\t}, this);\n\t}\n\n\t// the sass option can be a single path, or array of paths\n\t// when set, we configure the node-sass middleware\n\n\tvar sassPaths = this.get('sass'),\n\t\tsassOptions = this.get('sass options') || {};\n\n\tif (_.isString(sassPaths)) {\n\t\tsassPaths = [sassPaths];\n\t}\n\n\tif (_.isArray(sassPaths)) {\n\t\tvar sassMiddleware;\n\t\ttry {\n\t\t\tdebug('adding sass');\n\t\t\tsassMiddleware = require('node-sass-middleware');\n\t\t} catch(e) {\n\t\t\tif (e.code === 'MODULE_NOT_FOUND') {\n\t\t\t\tconsole.error(\n\t\t\t\t\t'\\nERROR: node-sass not found.\\n' +\n\t\t\t\t\t'\\nPlease install the node-sass-middleware from npm to use the `sass` option.' +\n\t\t\t\t\t'\\nYou can do this by running \"npm install node-sass-middleware --save\".\\n'\n\t\t\t\t);\n\t\t\t\tprocess.exit(1);\n\t\t\t} else {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\t_.each(sassPaths, function(value) {\n\t\t\tapp.use(sassMiddleware(_.extend({\n\t\t\t\tsrc: this.expandPath(value),\n\t\t\t\tdest: this.expandPath(value),\n\t\t\t\toutputStyle: this.get('env') === 'production' ? 'compressed' : 'nested'\n\t\t\t}, sassOptions)));\n\t\t}, this);\n\t}\n\n\t// the static option can be a single path, or array of paths\n\t// when set, we configure the express static middleware\n\n\tvar staticPaths = this.get('static');\n\tvar staticOptions = this.get('static options');\n\n\tif (_.isString(staticPaths)) {\n\t\tstaticPaths = [staticPaths];\n\t}\n\n\tif (_.isArray(staticPaths)) {\n\t\t_.each(staticPaths, function(value) {\n\t\t\tapp.use(express.static(this.expandPath(value), staticOptions));\n\t\t}, this);\n\t}\n\n\t// Log dynamic requests\n\tif (this.get('logger')) {\n\t\tdebug('adding request logger');\n\t\tapp.use(morgan(this.get('logger'), this.get('logger options')));\n\t}\n\n\t// If the user wants to define their own middleware for logging,\n\t// they should be able to\n\tif (keystone.get('logging middleware')) {\n\t\tapp.use(keystone.get('logging middleware'));\n\t}\n\n\t// We should also allow custom logging middleware to exist in the normal middleware flow\n\tapp.use(function(req, res, next) {\n\t\tkeystone.callHook('pre:logger', req, res, next);\n\t});\n\n\t// Pre bodyparser middleware\n\tif ('function' === typeof this.get('pre:bodyparser')) {\n\t\tdebug('configuring pre:bodyparser middleware');\n\t\tthis.get('pre:bodyparser')(app);\n\t}\n\tapp.use(function(req, res, next) {\n\t\tkeystone.callHook('pre:bodyparser', req, res, next);\n\t});\n\n\t// Set up body options and cookie parser\n\tvar bodyParserParams = {};\n\n\tif (this.get('file limit')) {\n\t\tdebug('adding file limit');\n\t\tbodyParserParams.limit = this.get('file limit');\n\t}\n\n\tapp.use(bodyParser.json(bodyParserParams));\n\tbodyParserParams.extended = true;\n\tapp.use(bodyParser.urlencoded(bodyParserParams));\n\tapp.use(methodOverride());\n\tapp.use(sessionOptions.cookieParser);\n\n\t// Pre session config\n\tif ('function' === typeof this.get('pre:session')) {\n\t\tdebug('configuring pre:session middleware');\n\t\tthis.get('pre:session')(app);\n\t}\n\tapp.use(function(req, res, next) {\n\t\tkeystone.callHook('pre:session', req, res, next);\n\t});\n\n\tapp.use(this.get('express session'));\n\tapp.use(multer({\n\t\tincludeEmptyFields: true\n\t}));\n\tapp.use(require('connect-flash')());\n\n\tif (this.get('session') === true) {\n\t\tapp.use(this.session.persist);\n\t} else if ('function' === typeof this.get('session')) {\n\t\tapp.use(this.get('session'));\n\t}\n\n\t// Add 'X-Frame-Options' to response header for ClickJacking protection\n\tif (this.get('frame guard')) {\n\t\tdebug('enabling frame guard');\n\t\tapp.use(require('../security/frameGuard')(this));\n\t}\n\n\t// Process 'X-Forwarded-For' request header\n\tif (this.get('trust proxy') === true) {\n\t\tdebug('enabling trusted proxy');\n\t\tapp.enable('trust proxy');\n\t} else {\n\t\tapp.disable('trust proxy');\n\t}\n\n\t// Check for IP range restrictions\n\tif (this.get('allowed ip ranges')) {\n\t\tif (!app.get('trust proxy')) {\n\t\t\tconsole.log(\n\t\t\t\t'KeystoneJS Initialisaton Error:\\n\\n' +\n\t\t\t\t'to set IP range restrictions the \"trust proxy\" setting must be enabled.\\n\\n'\n\t\t\t);\n\t\t\tprocess.exit(1);\n\t\t}\n\t\tdebug('adding IP ranges', this.get('allowed ip ranges'));\n\t\tvar ipRangeMiddleware = require('../security/ipRangeRestrict')(\n\t\t\tthis.get('allowed ip ranges'),\n\t\t\tthis.wrapHTMLError\n\t\t);\n\t\tthis.pre('routes', ipRangeMiddleware);\n\t}\n\n\t// Pre route config\n\n\t// Pre session config\n\tif ('function' === typeof this.get('pre:routes')) {\n\t\tdebug('configuring pre:routes middleware');\n\t\tthis.get('pre:routes')(app);\n\t}\n\tapp.use(function(req, res, next) {\n\t\tkeystone.callHook('pre:routes', req, res, next);\n\t});\n\n\t// unless the headless option is set (which disables the Admin UI),\n\t// include the Admin UI route handlers\n\tif (!this.get('headless')) {\n\t\tdebug('adding keystone routes to express app');\n\t\tthis.routes(app);\n\t}\n\n\n\t// Configure application routes\n\tif ('function' === typeof this.get('routes')) {\n\t\tdebug('configuring app routes');\n\t\tthis.get('routes')(app);\n\t}\n\n\t//prepare the error handlers; they should be called last\n\tvar setHandlers = function () {\n\n\t\t// Handle redirects before 404s\n\t\tif (Object.keys(keystone._redirects).length) {\n\t\t\tapp.use(function(req, res, next) {\n\t\t\t\tif (keystone._redirects[req.path]) {\n\t\t\t\t\tres.redirect(keystone._redirects[req.path]);\n\t\t\t\t} else {\n\t\t\t\t\tnext();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Handle 404 (no route matched) errors\n\t\tvar default404Handler = function(req, res, next) {// eslint-disable-line no-unused-vars\n\t\t\tres.status(404).send(keystone.wrapHTMLError('Sorry, no page could be found at this address (404)'));\n\t\t};\n\n\t\tapp.use(function(req, res, next) {\n\t\t\tvar err404 = keystone.get('404');\n\t\t\tif (err404) {\n\t\t\t\ttry {\n\t\t\t\t\tif ('function' === typeof err404) {\n\t\t\t\t\t\terr404(req, res, next);\n\t\t\t\t\t} else if ('string' === typeof err404) {\n\t\t\t\t\t\tres.status(404).render(err404);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (keystone.get('logger')) {\n\t\t\t\t\t\t\tconsole.log(dashes + 'Error handling 404 (not found): Invalid type (' + (typeof err404) + ') for 404 setting.' + dashes);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault404Handler(req, res, next);\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t\tif (keystone.get('logger')) {\n\t\t\t\t\t\tconsole.log(dashes + 'Error handling 404 (not found):');\n\t\t\t\t\t\tconsole.log(e);\n\t\t\t\t\t\tconsole.log(dashes);\n\t\t\t\t\t}\n\t\t\t\t\tdefault404Handler(req, res, next);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdefault404Handler(req, res, next);\n\t\t\t}\n\t\t});\n\n\t\t// Handle other errors\n\n\t\tvar default500Handler = function(err, req, res, next) {// eslint-disable-line no-unused-vars\n\n\t\t\tif (keystone.get('logger')) {\n\t\t\t\tif (err instanceof Error) {\n\t\t\t\t\tconsole.log((err.type ? err.type + ' ' : '') + 'Error thrown for request: ' + req.url);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log('Error thrown for request: ' + req.url);\n\t\t\t\t}\n\t\t\t\tconsole.log(err.stack || err);\n\t\t\t}\n\n\t\t\tvar msg = '';\n\n\t\t\tif (keystone.get('env') === 'development') {\n\n\t\t\t\tif (err instanceof Error) {\n\t\t\t\t\tif (err.type) {\n\t\t\t\t\t\tmsg += '<h2>' + err.type + '</h2>';\n\t\t\t\t\t}\n\t\t\t\t\tmsg += utils.textToHTML(err.message);\n\t\t\t\t} else if ('object' === typeof err) {\n\t\t\t\t\tmsg += '<code>' + JSON.stringify(err) + '</code>';\n\t\t\t\t} else if (err) {\n\t\t\t\t\tmsg += err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tres.status(500).send(keystone.wrapHTMLError('Sorry, an error occurred loading the page (500)', msg));\n\t\t};\n\n\t\tapp.use(function(err, req, res, next) {\n\n\t\t\tvar err500 = keystone.get('500');\n\n\t\t\tif (err500) {\n\t\t\t\ttry {\n\t\t\t\t\tif ('function' === typeof err500) {\n\t\t\t\t\t\terr500(err, req, res, next);\n\t\t\t\t\t} else if ('string' === typeof err500) {\n\t\t\t\t\t\tres.locals.err = err;\n\t\t\t\t\t\tres.status(500).render(err500);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (keystone.get('logger')) {\n\t\t\t\t\t\t\tconsole.log(dashes + 'Error handling 500 (error): Invalid type (' + (typeof err500) + ') for 500 setting.' + dashes);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault500Handler(err, req, res, next);\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t\tif (keystone.get('logger')) {\n\t\t\t\t\t\tconsole.log(dashes + 'Error handling 500 (error):');\n\t\t\t\t\t\tconsole.log(e);\n\t\t\t\t\t\tconsole.log(dashes);\n\t\t\t\t\t}\n\t\t\t\t\tdefault500Handler(err, req, res, next);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdefault500Handler(err, req, res, next);\n\t\t\t}\n\n\t\t});\n\t};\n\n\t// Connect to database\n\n\tvar mongoConnectionOpen = false;\n\n\t// support replica sets for mongoose\n\tif (this.get('mongo replica set')){\n\t\tdebug('setting up mongo replica set');\n\t\tvar replicaData = this.get('mongo replica set');\n\t\tvar replica = '';\n\n\t\tvar credentials = (replicaData.username && replicaData.password) ? replicaData.username + ':' + replicaData.password + '@' : '';\n\n\t\treplicaData.db.servers.forEach(function (server) {\n\t\t\treplica += 'mongodb://' + credentials + server.host + ':' + server.port + '/' + replicaData.db.name + ',';\n\t\t});\n\n\t\tvar options = {\n\t\t\tauth: { authSource: replicaData.authSource },\n\t\t\treplset: {\n\t\t\t\trs_name: replicaData.db.replicaSetOptions.rs_name,\n\t\t\t\treadPreference: replicaData.db.replicaSetOptions.readPreference\n\t\t\t}\n\t\t};\n\n\t\tdebug('connecting to replicate set');\n\t\tthis.mongoose.connect(replica, options);\n\n\t} else {\n\t\tdebug('connecting to mongo');\n\t\tthis.mongoose.connect(this.get('mongo'));\n\n\t}\n\n\tthis.mongoose.connection.on('error', function(err) {\n\n\t\tif (keystone.get('logger')) {\n\t\t\tconsole.log('------------------------------------------------');\n\t\t\tconsole.log('Mongo Error:\\n');\n\t\t\tconsole.log(err);\n\t\t}\n\n\t\tif (mongoConnectionOpen) {\n\t\t\tif (err.name === 'ValidationError') return;\n\t\t\tthrow err;\n\t\t} else {\n\t\t\tthrow new Error('KeystoneJS (' + keystone.get('name') + ') failed to start');\n\t\t}\n\n\t}).on('open', function() {\n\n\t\tdebug('mongo connection open');\n\t\tmongoConnectionOpen = true;\n\n\t\tvar mounted = function() {\n\t\t\tevents.onMount && events.onMount();// eslint-disable-line no-unused-expressions\n\t\t\tsetHandlers();\n\t\t};\n\n\t\tvar connected = function() {\n\t\t\tif (keystone.get('auto update')) {\n\t\t\t\tdebug('applying auto update');\n\t\t\t\tkeystone.applyUpdates(mounted);\n\t\t\t} else {\n\t\t\t\tmounted();\n\t\t\t}\n\t\t};\n\n\t\tif (sessionStorePromise) {\n\t\t\tsessionStorePromise.then(connected);\n\t\t} else {\n\t\t\tconnected();\n\t\t}\n\n\t});\n}\n\nmodule.exports = mount;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/populateRelated.js":"var async = require('async');\n\n/**\n * Populates relationships on a document or array of documents\n *\n * WARNING: This is currently highly inefficient and should only be used in development, or for\n * small data sets. There are lots of things that can be done to improve performance... later.\n *\n * @api public\n */\n\nfunction populateRelated(docs, relationships, callback) {\n\t\n\tif (Array.isArray(docs)) {\n\t\tasync.each(docs, function(doc, done) {\n\t\t\tdoc.populateRelated(relationships, done);\n\t\t}, callback);\n\t} else if (docs && docs.populateRelated) {\n\t\tdocs.populateRelated(relationships, callback);\n\t} else {\n\t\tcallback();\n\t}\n\n}\n\nmodule.exports = populateRelated;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/redirect.js":"var _ = require('underscore');\nvar debug = require('debug')('keystone:core:redirect');\nvar utils = require('keystone-utils');\n\n/**\n * Adds one or more redirections (urls that are redirected when no matching\n * routes are found, before treating the request as a 404)\n *\n * #### Example:\n * \t\tkeystone.redirect('/old-route', 'new-route');\n *\n * \t\t// or\n *\n * \t\tkeystone.redirect({\n * \t\t\t'old-route': 'new-route'\n * \t\t});\n */\n\nfunction redirect() {\n\tdebug('handling redirect');\n\tif (arguments.length === 1 && utils.isObject(arguments[0])) {\n\t\t_.extend(this._redirects, arguments[0]);\n\t} else if (arguments.length === 2 && 'string' === typeof arguments[0] && 'string' === typeof arguments[1]) {\n\t\tthis._redirects[arguments[0]] = arguments[1];\n\t}\n\t\n\treturn this;\n\t\n}\n\nmodule.exports = redirect;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/render.js":"var _ = require('underscore');\nvar cloudinary = require('cloudinary');\nvar debug = require('debug')('keystone:core:render');\nvar fs = require('fs');\nvar jade = require('jade');\nvar moment = require('moment');\nvar numeral = require('numeral');\nvar utils = require('keystone-utils');\n\n/**\n * Renders a Keystone View\n *\n * @api private\n */\n\nvar templateCache = {};\n\nfunction render(req, res, view, ext) {\n\n\tvar keystone = this;\n\n\tvar templatePath = __dirname + '/../../templates/views/' + view + '.jade';\n\n\tdebug('rendering ' + templatePath);\n\n\tvar jadeOptions = {\n\t\tfilename: templatePath,\n\t\tpretty: keystone.get('env') !== 'production'\n\t};\n\n\t// TODO: Allow custom basePath for extensions... like this or similar\n\t// if (keystone.get('extensions')) {\n\t// \tjadeOptions.basedir = keystone.getPath('extensions') + '/templates';\n\t// }\n\n\tvar compileTemplate = function() {\n\t\tdebug('compiling');\n\t\treturn jade.compile(fs.readFileSync(templatePath, 'utf8'), jadeOptions);\n\t};\n\n\tvar template = keystone.get('viewCache')\n\t\t? templateCache[view] || (templateCache[view] = compileTemplate())\n\t\t: compileTemplate();\n\n\tif (!res.req.flash) {\n\t\tconsole.error('\\nKeystoneJS Runtime Error:\\n\\napp must have flash middleware installed. Try adding \"connect-flash\" to your express instance.\\n');\n\t\tprocess.exit(1);\n\t}\n\tvar flashMessages = {\n\t\tinfo: res.req.flash('info'),\n\t\tsuccess: res.req.flash('success'),\n\t\twarning: res.req.flash('warning'),\n\t\terror: res.req.flash('error'),\n\t\thilight: res.req.flash('hilight')\n\t};\n\n\tvar locals = {\n\t\t_: _,\n\t\tmoment: moment,\n\t\tnumeral: numeral,\n\t\tenv: keystone.get('env'),\n\t\tbrand: keystone.get('brand'),\n\t\tappversion : keystone.get('appversion'),\n\t\tnav: keystone.nav,\n\t\tmessages: _.any(flashMessages, function(msgs) { return msgs.length; }) ? flashMessages : false,\n\t\tlists: keystone.lists,\n\t\tjs: 'javascript:;',// eslint-disable-line no-script-url\n\t\tutils: utils,\n\t\tUser: keystone.lists[keystone.get('user model')],\n\t\tuser: req.user,\n\t\ttitle: 'Keystone',\n\t\tsignout: keystone.get('signout url'),\n\t\tbackUrl: keystone.get('back url') || '/',\n\t\tsection: {},\n\t\tversion: keystone.version,\n\t\tcsrf_header_key: keystone.security.csrf.CSRF_HEADER_KEY,\n\t\tcsrf_token_key: keystone.security.csrf.TOKEN_KEY,\n\t\tcsrf_token_value: keystone.security.csrf.getToken(req, res),\n\t\tcsrf_query: '&' + keystone.security.csrf.TOKEN_KEY + '=' + keystone.security.csrf.getToken(req, res),\n\t\tga: {\n\t\t\tproperty: keystone.get('ga property'),\n\t\t\tdomain: keystone.get('ga domain')\n\t\t},\n\t\twysiwygOptions: {\n\t\t\tenableImages: keystone.get('wysiwyg images') ? true : false,\n\t\t\tenableCloudinaryUploads: keystone.get('wysiwyg cloudinary images') ? true : false,\n\t\t\tadditionalButtons: keystone.get('wysiwyg additional buttons') || '',\n\t\t\tadditionalPlugins: keystone.get('wysiwyg additional plugins') || '',\n\t\t\tadditionalOptions: keystone.get('wysiwyg additional options') || {},\n\t\t\toverrideToolbar: keystone.get('wysiwyg override toolbar'),\n\t\t\tskin: keystone.get('wysiwyg skin') || 'keystone',\n\t\t\tmenubar: keystone.get('wysiwyg menubar'),\n\t\t\timportcss: keystone.get('wysiwyg importcss') || ''\n\t\t}\n\t};\n\n\t// optional extensions to the local scope\n\t_.extend(locals, ext);\n\n\t// add cloudinary locals if configured\n\tif (keystone.get('cloudinary config')) {\n\t\ttry {\n\t\t\tdebug('adding cloudinary locals');\n\t\t\tvar cloudinaryUpload = cloudinary.uploader.direct_upload();\n\t\t\tlocals.cloudinary = {\n\t\t\t\tcloud_name: keystone.get('cloudinary config').cloud_name,\n\t\t\t\tapi_key: keystone.get('cloudinary config').api_key,\n\t\t\t\ttimestamp: cloudinaryUpload.hidden_fields.timestamp,\n\t\t\t\tsignature: cloudinaryUpload.hidden_fields.signature,\n\t\t\t\tprefix: keystone.get('cloudinary prefix') || '',\n\t\t\t\tfolders: keystone.get('cloudinary folders'),\n\t\t\t\tuploader: cloudinary.uploader\n\t\t\t};\n\t\t\tlocals.cloudinary_js_config = cloudinary.cloudinary_js_config();\n\t\t} catch(e) {\n\t\t\tif (e === 'Must supply api_key') {\n\t\t\t\tthrow new Error('Invalid Cloudinary Config Provided\\n\\n' +\n\t\t\t\t\t'See http://keystonejs.com/docs/configuration/#services-cloudinary for more information.');\n\t\t\t} else {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}\n\n\t// fieldLocals defines locals that are provided to each field's `render` method\n\tlocals.fieldLocals = _.pick(locals, '_', 'moment', 'numeral', 'env', 'js', 'utils', 'user', 'cloudinary');\n\n\tvar html = template(_.extend(locals, ext));\n\n\tdebug('sending down html');\n\tres.send(html);\n}\n\nmodule.exports = render;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/routes.js":"var debug = require('debug')('keystone:core:routes');\n\n/**\n * Adds bindings for the keystone routes\n *\n * ####Example:\n *\n *     var app = express();\n *     app.use(...); // middleware, routes, etc. should come before keystone is initialised\n *     keystone.routes(app);\n *\n * @param {Express()} app\n * @api public\n */\nfunction routes(app) {\n\tthis.app = app;\n\tvar keystone = this;\n\n\t// ensure keystone nav has been initialised\n\tif (!this.nav) {\n\t\tdebug('setting up nav');\n\t\tthis.nav = this.initNav();\n\t}\n\n\t// Cache compiled view templates if we are in Production mode\n\tthis.set('view cache', this.get('env') === 'production');\n\n\t// Session API\n\t// TODO: this should respect keystone auth options\n\tapp.get('/keystone/api/session', require('../../admin/api/session/get'));\n\tapp.post('/keystone/api/session/signin', require('../../admin/api/session/signin'));\n\tapp.post('/keystone/api/session/signout', require('../../admin/api/session/signout'));\n\n\t// Bind auth middleware (generic or custom) to /keystone* routes, allowing\n\t// access to the generic signin page if generic auth is used\n\tif (this.get('auth') === true) {\n\t\tif (!this.get('signout url')) {\n\t\t\tthis.set('signout url', '/keystone/signout');\n\t\t}\n\t\tif (!this.get('signin url')) {\n\t\t\tthis.set('signin url', '/keystone/signin');\n\t\t}\n\t\tif (!this.nativeApp || !this.get('session')) {\n\t\t\tapp.all('/keystone*', this.session.persist);\n\t\t}\n\t\tapp.all('/keystone/signin', require('../../admin/routes/views/signin'));\n\t\tapp.all('/keystone/signout', require('../../admin/routes/views/signout'));\n\t\tapp.all('/keystone*', this.session.keystoneAuth);\n\t} else if ('function' === typeof this.get('auth')) {\n\t\tapp.all('/keystone*', this.get('auth'));\n\t}\n\n\tfunction initList(respectHiddenOption) {\n\t\treturn function(req, res, next) {\n\t\t\treq.list = keystone.list(req.params.list);\n\n\t\t\tif (!req.list || (respectHiddenOption && req.list.get('hidden'))) {\n\t\t\t\tdebug('could not find list ', req.params.list);\n\t\t\t\treq.flash('error', 'List ' + req.params.list + ' could not be found.');\n\t\t\t\treturn res.redirect('/keystone');\n\t\t\t}\n\n\t\t\tdebug('getting list ', req.params.list);\n\t\t\tnext();\n\t\t};\n\t}\n\n\tdebug('setting keystone Admin Route');\n\tapp.all('/keystone', require('../../admin/routes/views/home'));\n\n\t// Email test routes\n\tif (this.get('email tests')) {\n\t\tdebug('setting email test routes');\n\t\tthis.bindEmailTestRoutes(app, this.get('email tests'));\n\t}\n\n\t// Cloudinary API for selecting an existing image / upload a new image\n\tif (keystone.get('cloudinary config')) {\n\t\tdebug('setting cloudinary api');\n\t\tapp.get('/keystone/api/cloudinary/get', require('../../admin/api/cloudinary').get);\n\t\tapp.get('/keystone/api/cloudinary/autocomplete', require('../../admin/api/cloudinary').autocomplete);\n\t\tapp.post('/keystone/api/cloudinary/upload', require('../../admin/api/cloudinary').upload);\n\t}\n\n\t// Init API request helpers\n\tapp.use('/keystone/api', function(req, res, next) {\n\t\tres.apiError = function(key, err) {\n\t\t\tvar statusCode = 500;\n\t\t\tif (key === 404) {\n\t\t\t\tstatusCode = 404;\n\t\t\t\tkey = null;\n\t\t\t\tkey = 'not found';\n\t\t\t}\n\t\t\tif (!key) {\n\t\t\t\tkey = 'unknown error';\n\t\t\t}\n\t\t\tif (!err) {\n\t\t\t\terr = 'API Error';\n\t\t\t}\n\t\t\tif (typeof err === 'object' && err.message) {\n\t\t\t\terr = err.message;\n\t\t\t}\n\t\t\tres.status(statusCode);\n\t\t\tres.json({ err: err, key: key });\n\t\t};\n\t\tnext();\n\t});\n\n\t// Generic Lists API\n\tapp.all('/keystone/api/:list/:action(autocomplete|order|create|fetch)', initList(), require('../../admin/api/list'));\n\tapp.post('/keystone/api/:list/delete', initList(), require('../../admin/api/list/delete'));\n\tapp.get('/keystone/api/:list', initList(), require('../../admin/api/list/get'));\n\tapp.get('/keystone/api/:list/:id', initList(), require('../../admin/api/item/get'));\n\tapp.post('/keystone/api/:list/:id/delete', initList(), require('../../admin/api/item/delete'));\n\n\tapp.all('/keystone/download/:list', initList(), require('../../admin/api/download'));\n\n\t// Admin-UI API\n\tapp.all('/keystone/:list/:page([0-9]{1,5})?', initList(true), require('../../admin/routes/views/list'));\n\tapp.all('/keystone/:list/:item', initList(true), require('../../admin/routes/views/item'));\n\n\treturn this;\n}\n\nmodule.exports = routes;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/start.js":"/**\n * Configures and starts a Keystone app in encapsulated mode.\n *\n * Connects to the database, runs updates and listens for incoming requests.\n *\n * Events are fired during initialisation to allow customisation, including:\n *\n *   - onMount\n *   - onStart\n *   - onHttpServerCreated\n *   - onHttpsServerCreated\n *\n * If the events argument is a function, it is assumed to be the started event.\n *\n *\n * ####Options:\n *\n * Keystone supports the following options specifically for running in encapsulated mode:\n *\n *   - name\n *   - port\n *   - views\n *   - view engine\n *   - compress\n *   - favico\n *   - less\n *   - static\n *   - headless\n *   - logger\n *   - cookie secret\n *   - session\n *   - 404\n *   - 500\n *   - routes\n *   - locals\n *   - auto update\n *   - ssl\n *   - sslport\n *   - sslkey\n *   - sslcert\n *\n *\n * @api public\n */\n\nvar fs = require('fs');\nvar debug = require('debug')('keystone:core:start');\nvar https = require('https');\n\nvar dashes = '\\n------------------------------------------------\\n';\n\nfunction start(events) {\n\t\n\t// Validate arguments\n\t\n\tif ('function' === typeof events) {\n\t\tevents = { onStart: events };\n\t}\n\t\n\tif (!events) events = {};\n\t\n\t// Ensure Keystone has been initialised\n\t\n\tif (!this.app) {\n\t\tthrow new Error('KeystoneJS Initialisaton Error:\\n\\napp must be initialised. Call keystone.init() or keystone.connect(new Express()) first.\\n\\n');\n\t}\n\t\n\t// Localise references to this for closures\n\t\n\tvar keystone = this,\n\t\tapp = this.app;\n\n\t// Prebuild the Admin Resources\n\tthis.adminApp.staticRouter.prebuild();\n\n\t// Maintain passed in onMount binding but override to start http servers\n\t// (call user-defined onMount first if present)\n\t\n\tvar onMount = events.onMount;\n\t\n\tevents.onMount = function() {\n\t\t\n\t\tonMount && onMount();// eslint-disable-line no-unused-expressions\n\t\t\n\t\tvar startupMessages = ['KeystoneJS Started:'],\n\t\t\twaitForServers = 3;\n\t\t\t\n\t\t// Log the startup messages and calls the onStart method\n\t\t\n\t\tvar serverStarted = function() {\n\t\t\twaitForServers--;\n\t\t\tif (waitForServers) return;\n\t\t\tif (keystone.get('logger')) {\n\t\t\t\tconsole.log(dashes + startupMessages.join('\\n') + dashes);\n\t\t\t}\n\t\t\tdebug('server starting');\n\t\t\tevents.onStart && events.onStart();// eslint-disable-line no-unused-expressions\n\t\t};\n\t\t\n\t\t// Create the http server and listens to the specified port with default port specified\n\t\t\n\t\tvar host = keystone.get('host'),\n\t\t\tport = keystone.get('port'),\n\t\t\tssl = keystone.get('ssl'),\n\t\t\tunixSocket = keystone.get('unix socket'),\n\t\t\tletsencrypt = keystone.get('letsencrypt'),\n\t\t\thttpReadyMsg;\n\t\t\n\t\tif (letsencrypt && !unixSocket) {\n\t\t\twaitForServers++;\n\t\t\trequire('../../server/startLetsEncrypt')(keystone, app, function (err, msg) {\n\t\t\t\tif (err) { throw err; }\n\t\t\t\tstartupMessages.push(msg);\n\t\t\t\tserverStarted();\n\t\t\t});\n\t\t}\n\t\tif (ssl !== 'only' && !letsencrypt && !unixSocket) {\n\t\t\thttpReadyMsg = keystone.get('name') + ' is ready on ';\n\t\t\t\n\t\t\tif (host) {\n\t\t\t\thttpReadyMsg += 'http://' + host;\n\t\t\t\tif (port) {\n\t\t\t\t\thttpReadyMsg += ':' + port;\n\t\t\t\t} else {\n\t\t\t\t\thttpReadyMsg += ':3000';\n\t\t\t\t}\n\t\t\t} else if (port){\n\t\t\t\thttpReadyMsg += 'port ' + port;\n\t\t\t} else {\n\t\t\t\thttpReadyMsg += 'port 3000';\n\t\t\t}\n\t\t\t\n\t\t\tvar httpStarted = function(msg) {\n\t\t\t\treturn function() {\n\t\t\t\t\tstartupMessages.push(msg);\n\t\t\t\t\tserverStarted();\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tif (host) {\n\t\t\t\tkeystone.httpServer = app.listen(port || 3000, host, httpStarted(httpReadyMsg));\n\t\t\t} else {\n\t\t\t\tkeystone.httpServer = app.listen(port || 3000, httpStarted(httpReadyMsg));\n\t\t\t}\n\t\t\tevents.onHttpServerCreated && events.onHttpServerCreated();// eslint-disable-line no-unused-expressions\n\t\t} else {\n\t\t\twaitForServers--;\n\t\t}\n\t\t\n\t\tif (ssl && !letsencrypt && !unixSocket) {\n\t\t\t\n\t\t\tdebug('start the ssl server');\n\t\t\tvar sslOpts = keystone.get('https server options') || {};\n\t\t\t\n\t\t\tif (keystone.get('ssl cert') && fs.existsSync(keystone.getPath('ssl cert'))) {\n\t\t\t\tsslOpts.cert = fs.readFileSync(keystone.getPath('ssl cert'));\n\t\t\t}\n\t\t\tif (keystone.get('ssl key') && fs.existsSync(keystone.getPath('ssl key'))) {\n\t\t\t\tsslOpts.key = fs.readFileSync(keystone.getPath('ssl key'));\n\t\t\t}\n\t\t\tif (keystone.get('ssl ca') && fs.existsSync(keystone.getPath('ssl ca'))) {\n\t\t\t\tsslOpts.ca = fs.readFileSync(keystone.getPath('ssl ca'));\n\t\t\t}\n\t\t\t\n\t\t\tif (!sslOpts.key || !sslOpts.cert) {\n\t\t\t\t\n\t\t\t\tif (ssl === 'only') {\n\t\t\t\t\tconsole.log(keystone.get('name') + ' failed to start: invalid ssl configuration');\n\t\t\t\t\tprocess.exit();\n\t\t\t\t} else {\n\t\t\t\t\tstartupMessages.push('Warning: Invalid SSL Configuration');\n\t\t\t\t\tserverStarted();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tvar httpsStarted = function(msg) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tstartupMessages.push(msg);\n\t\t\t\t\t\tserverStarted();\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tkeystone.httpsServer = https.createServer(sslOpts, app);\n\t\t\t\tevents.onHttpsServerCreated && events.onHttpsServerCreated();// eslint-disable-line no-unused-expressions\n\t\t\t\t\n\t\t\t\tvar sslHost = keystone.get('ssl host') || host,\n\t\t\t\t\tsslPort = keystone.get('ssl port') || 3001;\n\t\t\t\t\n\t\t\t\tvar httpsReadyMsg = (ssl === 'only') ? keystone.get('name') + ' (SSL) is ready on ' : 'SSL Server is ready on ';\n\t\t\t\t\n\t\t\t\tif (sslHost) {\n\t\t\t\t\tkeystone.httpsServer.listen(sslPort, sslHost, httpsStarted(httpsReadyMsg + 'https://' + sslHost + ':' + sslPort));\n\t\t\t\t} else {\n\t\t\t\t\tvar httpsPortMsg = (keystone.get('ssl port')) ? 'port: ' + keystone.get('ssl port') : 'default port 3001';\n\t\t\t\t\tkeystone.httpsServer.listen(sslPort, httpsStarted(httpsReadyMsg + httpsPortMsg));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\twaitForServers--;\n\t\t}\n\t\t\n\t\tif(unixSocket) {\n\t\t\t\n\t\t\tvar unixSocketStarted = function(msg) {\n\t\t\t\treturn function() {\n\t\t\t\t\tstartupMessages.push(msg);\n\t\t\t\t\tserverStarted();\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\thttpReadyMsg = keystone.get('name') + ' is ready on ' + unixSocket;\n\t\t\t\n\t\t\tfs.unlink(unixSocket, function(err) {// eslint-disable-line no-unused-vars, handle-callback-err\n\t\t\t\tkeystone.httpServer = app.listen(unixSocket, unixSocketStarted(httpReadyMsg));\n\t\t\t\tevents.onSocketServerCreated && events.onSocketServerCreated();// eslint-disable-line no-unused-expressions\n\t\t\t\tfs.chmod(unixSocket, 0x777, function(){\n\t\t\t\t\t// set permissions\n\t\t\t\t});\n\t\t\t});\n\t\t\t\n\t\t} else {\n\t\t\twaitForServers--;\n\t\t}\n\t\t\n\t\tprocess.on('uncaughtException', function(e) {\n\t\t\tif (e.code === 'EADDRINUSE') {\n\t\t\t\tconsole.log(dashes +\n\t\t\t\t\tkeystone.get('name') + ' failed to start: address already in use\\n' +\n\t\t\t\t\t'Please check you are not already running a server on the specified port.\\n');\n\t\t\t\tprocess.exit();\n\t\t\t}/* else if (e.code === 'ECONNRESET') {\n\t\t\t\t// Connection reset by peer, ignore it instead of exiting server with a throw.\n\t\t\t\t// Disabled for release 0.2.16 while further research is being done.\n\t\t\t\tconsole.log('Connection reset by peer');\n\t\t\t\tconsole.log(e);\n\t\t\t} */else {\n\t\t\t\tconsole.log(e.stack || e);\n\t\t\t\tprocess.exit(1);\n\t\t\t}\n\t\t});\n\t\t\n\t};\n\t\n\tdebug('mount the express app');\n\tthis.mount(events);\n\t\n\treturn this;\n\t\n}\n\nmodule.exports = start;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/core/wrapHTMLError.js":"/**\n * Wraps an error in simple HTML to be sent as a response to the browser\n *\n * @api public\n */\n\nfunction wrapHTMLError(title, err) {\n\treturn '<html><head><meta charset=\\'utf-8\\'><title>Error</title>' +\n\t'<link rel=\\'stylesheet\\' href=\\'/keystone/styles/error.css\\'>' +\n\t'</head><body><div class=\\'error\\'><h1 class=\\'error-title\\'>' + title + '</h1>' +\n\t'<div class=\"error-message\">' + (err || '') + '</div></div></body></html>';\n}\n\nmodule.exports = wrapHTMLError;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/admin/app/static.js":"/**\n * Returns an Express Router with bindings for the Admin UI static resources,\n * i.e files, less and browserified scripts.\n *\n * Should be included before other middleware (e.g. session management,\n * logging, etc) for reduced overhead.\n */\n\nvar browserify = require('./browserify');\nvar express = require('express');\nvar less = require('less-middleware');\nvar path = require('path');\nvar router = express.Router();\n\n/* Prepare browserify bundles */\n\nvar bundles = {\n\tfields: browserify('fields.js', 'FieldTypes'),\n\thome: browserify('views/home.js'),\n\titem: browserify('views/item.js'),\n\tlist: browserify('views/list.js')\n};\n\nrouter.prebuild = function() {\n\tbundles.fields.build();\n\tbundles.home.build();\n\tbundles.item.build();\n\tbundles.list.build();\n};\n\n/* Prepare LESS options */\n\nvar reactSelectPath = path.join(path.dirname(require.resolve('react-select')), '..');\n\nvar lessOptions = {\n\trender: {\n\t\tmodifyVars: {\n\t\t\treactSelectPath: JSON.stringify(reactSelectPath)\n\t\t}\n\t}\n};\n\n/* Configure router */\n\nrouter.use('/styles', less(path.join(__dirname, '../public/styles'), lessOptions));\nrouter.use(express.static(path.join(__dirname, '../public')));\nrouter.get('/js/fields.js', bundles.fields.serve);\nrouter.get('/js/home.js', bundles.home.serve);\nrouter.get('/js/item.js', bundles.item.serve);\nrouter.get('/js/list.js', bundles.list.serve);\n\nmodule.exports = router;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/admin/app/browserify.js":"var babelify = require('babelify');\nvar browserify = require('browserify');\nvar chalk = require('chalk');\nvar crypto = require('crypto');\nvar moment = require('moment');\nvar packages = require('../packages');\nvar path = require('path');\nvar watchify = require('watchify');\n\nvar basedir = path.resolve(__dirname + '/../src/');\nvar devMode = process.env.KEYSTONE_DEV === 'true';\n\nfunction ts() {\n\treturn chalk.gray(moment().format('YYYY-MM-DD HH:MM:SS '));\n}\n\nfunction logInit(file) {\n\tconsole.log(chalk.grey('Watching ' + chalk.black.underline('keystone/admin/src/' + file) + ' for changes...'));\n}\n\nfunction logRebuild(file) {\n\tconsole.log(ts() + chalk.green('rebuilt ' + chalk.underline(file)));\n}\n\nfunction logError(file, err) {\n\tconsole.log(ts() + chalk.red('error building ' + chalk.underline(file) + ':') + '\\n' + err.message);\n}\n\nmodule.exports = function(file, name) {\n\tvar b;\n\tvar building = false;\n\tvar queue = [];\n\tvar ready;\n\tvar src;\n\tfunction build() {\n\t\tif (building) return;\n\t\tbuilding = true;\n\t\tvar opts = { basedir: basedir };\n\t\tif (devMode) {\n\t\t\tlogInit(file);\n\t\t\topts.cache = {};\n\t\t\topts.packageCache = {};\n\t\t}\n\t\tif (name) {\n\t\t\tb = browserify(opts);\n\t\t\tb.require('./' + file, { expose: name });\n\t\t} else {\n\t\t\tb = browserify('./' + file, opts);\n\t\t}\n\t\tb.transform(babelify.configure({\n\t\t\tignore: ['**/lib/**']\n\t\t}));\n\t\tb.exclude('FieldTypes');\n\t\tpackages.forEach(function(i) {\n\t\t\tb.exclude(i);\n\t\t});\n\t\tif (devMode) {\n\t\t\tb = watchify(b);\n\t\t}\n\t\tb.bundle(function(err, buff) {\n\t\t\tif (err) return logError(file, err);\n\t\t\tsrc = buff;\n\t\t\tready = true;\n\t\t\tqueue.forEach(function(reqres) {\n\t\t\t\tsend.apply(null, reqres);\n\t\t\t});\n\t\t});\n\t\tb.on('update', function() {\n\t\t\tb.bundle(function(err, buff) {\n\t\t\t\tif (err) return logError(file, err);\n\t\t\t\telse logRebuild(file);\n\t\t\t\tsrc = buff;\n\t\t\t});\n\t\t});\n\t}\n\tfunction serve(req, res) {\n\t\tif (!ready) {\n\t\t\tbuild();\n\t\t\tqueue.push([req, res]);\n\t\t\treturn;\n\t\t}\n\t\tsend(req, res);\n\t}\n\tfunction send(req, res) {\n\t\tres.setHeader('Content-Type', 'application/javascript');\n\t\tvar etag = crypto.createHash('md5').update(src).digest('hex').slice(0, 6);\n\t\tif (req.get && (etag === req.get('If-None-Match'))) {\n\t\t\tres.status(304);\n\t\t\tres.end();\n\t\t}\n\t\telse {\n\t\t\tres.setHeader('ETag', etag);\n\t\t\tres.setHeader('Vary', 'Accept-Encoding');\n\t\t\tres.send(src);\n\t\t}\n\t}\n\treturn {\n\t\tserve: serve,\n\t\tbuild: build\n\t};\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/admin/packages.js":"// This file exports the common packages required by the Admin UI.\n// \n// It is used to build /public/js/packages.js, and exclude these packages from\n// the Admin UI bundle generated by browserify.\nmodule.exports = [\n\t'bytes',\n\t'classnames',\n\t'marked',\n\t'moment',\n\t'numeral',\n\t'pikaday',\n\t'react',\n\t'react-select',\n\t'react-alt-text',\n\t'react/addons',\n\t'superagent'\n];\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/middleware/api.js":"/**\n * Adds shortcut methods for JSON API responses:\n * \n *   * `res.apiResponse(data)`\n *   * `res.apiError(key, err, msg, code)`\n *   * `res.apiNotFound(err, msg)`\n *   * `res.apiNotAllowed(err, msg)`\n *\n * ####Example:\n *\n *     app.all('/api*', keystone.middleware.api);\n *\n * @param {app.request} req\n * @param {app.response} res\n * @param {function} next\n * @api public\n */\n\n// The exported function returns a closure that retains\n// a reference to the keystone instance, so it can be\n// passed as middeware to the express app.\n\nexports = module.exports = function(keystone) {\n\treturn function initAPI(req, res, next) {\n\t\t\n\t\tres.apiResponse = function(data) {\n\t\t\tif (req.query.callback) {\n\t\t\t\tres.jsonp(data);\n\t\t\t} else {\n\t\t\t\tres.json(data);\n\t\t\t}\n\t\t};\n\n\t\tres.apiError = function(key, err, msg, code) {\n\t\t\tmsg = msg || 'Error';\n\t\t\tkey = key || 'unknown error';\n\t\t\tmsg += ' (' + key + ')';\n\t\t\tif (keystone.get('logger')) {\n\t\t\t\tconsole.log(msg + (err ? ':' : ''));\n\t\t\t\tif (err) {\n\t\t\t\t\tconsole.log(err);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.status(code || 500);\n\t\t\tres.apiResponse({ error: key || 'error', detail: err });\n\t\t};\n\t\t\n\t\tres.apiNotFound = function (err, msg) {\n\t\t\tres.apiError('data not found', err, msg || 'not found', 404);\n\t\t};\n\t\t\n\t\tres.apiNotAllowed = function (err, msg) {\n\t\t\tres.apiError('access not allowed', err, msg || 'not allowed', 403);\n\t\t};\n\n\t\tnext();\n\t};\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/middleware/cors.js":"/**\n * Adds CORS headers to the response\n *\n * ####Example:\n *\n *     app.all('/api*', keystone.middleware.cors);\n *\n * @param {app.request} req\n * @param {app.response} res\n * @param {function} next\n * @api public\n */\n\n// The exported function returns a closure that retains\n// a reference to the keystone instance, so it can be\n// passed as middeware to the express app.\n\nexports = module.exports = function(keystone) {\n\treturn function cors(req, res, next) {\n\t\t\n\t\tvar origin = keystone.get('cors allow origin');\n\t\tif (origin) {\n\t\t\tres.header('Access-Control-Allow-Origin', origin === true ? '*' : origin);\n\t\t}\n\t\t\n\t\tif (keystone.get('cors allow methods') !== false) {\n\t\t\tres.header('Access-Control-Allow-Methods', keystone.get('cors allow methods') || 'GET,PUT,POST,DELETE');\n\t\t}\n\t\tif (keystone.get('cors allow headers') !== false) {\n\t\t\tres.header('Access-Control-Allow-Headers', keystone.get('cors allow headers') || 'Content-Type, Authorization');\n\t\t}\n\n\t\tnext();\n\t};\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/email.js":"var _ = require('underscore');\nvar fs = require('fs');\nvar keystone = require('../');\nvar mandrillapi = require('mandrill-api');\nvar mailgunapi = require('mailgun-js');\nvar juice = require('juice');\nvar moment = require('moment');\nvar path = require('path');\nvar util = require('util');\nvar utils = require('keystone-utils');\n\nvar templateCache = {};\n\n// Get view engine\nvar emailsEngine, emailsEnginelib;\nif (keystone.get('custom engine')) {\n\temailsEngine = keystone.get('view engine');\n\temailsEnginelib = keystone.get('custom engine');\n} else {\n\temailsEngine = 'jade';\n\temailsEnginelib = require('jade');\n}\n\nvar defaultConfig = {\n\ttemplateExt: emailsEngine,\n\ttemplateEngine: emailsEnginelib,\n\ttemplateBasePath: path.normalize(path.join(__dirname, '..', 'templates', 'helpers', 'emails')),\n};\nif (!_.isEqual(keystone.get('email transport'), 'mailgun')) {\n\tdefaultConfig.mandrill = {\n\t\ttrack_opens: true,\n\t\ttrack_clicks: true,\n\t\tpreserve_recipients: false,\n\t\tinline_css: true,\n\t};\n\tdefaultConfig.templateMandrillName = null; // Mandrill template\n\tdefaultConfig.templateForceHtml = false; // Force html render\n}\n\n/** Custom Errors */\n\n// TOTO: Uses arguments.callee for the stack trace, which prevents optimisation.\n// I've marked these to be ignored by jshint but we should find a better way.\n\nvar ErrorNoEmailTemplateName = function() {\n\tError.apply(this, arguments);\n\tError.captureStackTrace(this, arguments.callee);\n\tthis.message = 'No email templateName specified.';\n\tthis.name = 'ErrorNoEmailTemplateName';\n};\nutil.inherits(ErrorNoEmailTemplateName, Error);\n\nvar ErrorEmailsPathNotSet = function() {\n\tError.apply(this, arguments);\n\tError.captureStackTrace(this, arguments.callee);\n\tthis.message = 'Keystone has not been configured for email support. Set the `emails` option in your configuration.';\n\tthis.name = 'ErrorEmailsPathNotSet';\n};\nutil.inherits(ErrorEmailsPathNotSet, Error);\n\nvar ErrorEmailOptionsRequired = function() {\n\tError.apply(this, arguments);\n\tError.captureStackTrace(this, arguments.callee);\n\tthis.message = 'The keystone.Email class requires a templateName or options argument to be provided.';\n\tthis.name = 'ErrorEmailOptionsRequired';\n};\nutil.inherits(ErrorEmailsPathNotSet, Error);\n\n/** Helper methods */\n\nvar getEmailsPath = function() {\n\tvar path = keystone.getPath('emails');\n\tif (path) {\n\t\treturn path;\n\t}\n\tthrow new ErrorEmailsPathNotSet();\n};\n\nfunction buildAddress (email, name) {\n\tif (Array.isArray(email)) {\n\t\treturn email.map(function (to) { return to.name + ' <' + to.email + '>'; }).join(',');\n\t} else {\n\t\treturn name ? name + ' <' + email + '>' : email;\n\t}\n}\n\n/**\n * Flatten an object\n * @param  {Object} obj   Source object\n * @param  {String} delim Delimeter\n * @return {Object}       Flat object\n */\nvar flattenObject = function(obj, delim) {\n\tdelim = delim || '_';\n\tvar _ret = {};\n\n\tfor (var key in obj) {\n\t\tif (!obj.hasOwnProperty(key)) continue;\n\n\t\tif ((typeof obj[key]) === 'object' && obj[key] !== null) {\n\t\t\tvar _flat = flattenObject(obj[key], delim);\n\t\t\tfor (var next in _flat) {\n\t\t\t\tif (!_flat.hasOwnProperty(next)) continue;\n\n\t\t\t\t_ret[key + delim + next] = _flat[next];\n\t\t\t}\n\t\t} else {\n\t\t\t_ret[key] = obj[key];\n\t\t}\n\t}\n\treturn _ret;\n};\n\n/**\n * Converts javascript Objects into\n * Mandrill's vars objects.\n *\n * @param  {Mixed}  _var Object to parse\n * @return {Array}       An array of vars\n */\nvar objToMandrillVars = function (_var) {\n\tvar _new = [];\n\tif ('object' === typeof _var) {\n\t\tvar _flat = flattenObject(_var, '_');\n\t\t_.each(_flat, function(value, key) {\n\t\t\t_new.push({ name: key, content: value });\n\t\t});\n\t\treturn _new;\n\t}\n\treturn _var;\n};\n\n/** CSS Helper methods */\n\nvar templateCSSMethods = {\n\tshadeColor: function(color, percent) {\n\t\t/* eslint-disable space-infix-ops */\n\t\tvar num = parseInt(color.slice(1), 16), amt = Math.round(2.55 * percent), R = (num >> 16) + amt, G = (num >> 8 & 0x00FF) + amt, B = (num & 0x0000FF) + amt;\n\t\treturn '#' + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);\n\t\t/* eslint-enable */\n\t}\n};\n\n\n\n/**\n * Email Class\n * ===========\n *\n * Helper class for sending emails with Mandrill.\n *\n * New instances take a `templatePath` string which must be a folder in the\n * emails path, and must contain either `templateName/email.templateExt` or `templateName.templateExt`\n * which is used as the template for the HTML part of the email.\n *\n * Once created, emails can be rendered or sent.\n *\n * Requires the `emails` path option and the `mandrill api key` option to be\n * set on Keystone.\n *\n * @api public\n */\n\nvar Email = function(options) {\n\t// Passing a string will use Email.defaults for everything but template name\n\tif ('string' === typeof options) {\n\t\toptions = {\n\t\t\ttemplateName: options\n\t\t};\n\t} else if (!utils.isObject(options)) {\n\t\tthrow new ErrorEmailOptionsRequired();\n\t}\n\n\tthis.templateMandrillName = options.templateMandrillName;\n\tthis.templateMandrillContent = _.isArray(options.templateMandrillContent) ? options.templateMandrillContent : [];\n\n\tthis.templateName = options.templateName || this.templateMandrillName;\n\tthis.templateExt = options.templateExt || Email.defaults.templateExt;\n\tthis.templateEngine = options.templateEngine || Email.defaults.templateEngine;\n\tthis.templateBasePath = options.templateBasePath || Email.defaults.templateBasePath;\n\tthis.templateCompile = options.templateCompile || Email.defaults.templateCompile;\n\tthis.templateRender = options.templateRender || Email.defaults.templateRender;\n\n\tif (!this.templateName) {\n\t\tthrow new ErrorNoEmailTemplateName();\n\t}\n\n\treturn this;\n\n};\n\n/**\n * Renders the email and passes it to the callback. Used by `email.send()` but\n * can also be called directly to generate a preview.\n *\n * @param {Object} locals - object of local variables provided to the template\n * @param {Function} callback(err, email)\n *\n * @api public\n */\n\nEmail.prototype.render = function(locals, callback) {\n\n\tif ('function' === typeof locals && !callback) {\n\t\tcallback = locals;\n\t\tlocals = {};\n\t}\n\n\tlocals = ('object' === typeof locals) ? locals : {};\n\tcallback = ('function' === typeof callback) ? callback : function() {};\n\n\tif (keystone.get('email locals')) {\n\t\t_.defaults(locals, keystone.get('email locals'));\n\t}\n\n\t_.defaults(locals, {\n\t\tpretty: true,\n\t\t_: _,\n\t\tmoment: moment,\n\t\tutils: utils,\n\t\tsubject: '(no subject)',\n\t\tbrand: keystone.get('brand'),\n\t\ttheme: {},\n\t\tcss: templateCSSMethods\n\t});\n\n\tif (!locals.theme.buttons) {\n\t\tlocals.theme.buttons = {};\n\t}\n\n\tthis.compileTemplate(function(err) {\n\t\tif (err) {\n\t\t\treturn callback(err);\n\t\t}\n\n\t\tvar html = null;\n\t\tvar template = templateCache[this.templateName];\n\t\tif (this.templateRender) {\n\t\t\thtml = this.templateRender(template, locals);\n\t\t} else if (typeof template === 'function') {\n\t\t\thtml = template(locals);\n\t\t} else if (typeof template.render === 'function') {\n\t\t\thtml = template.render(locals);\n\t\t} else {\n\t\t\treturn callback({\n\t\t\t\tfrom: 'Email.compileTemplate',\n\t\t\t\tkey: 'invalid rendering function',\n\t\t\t\tmessage: 'no template rendering function could be found.',\n\t\t\t});\n\t\t}\n\n\t\t// ensure extended characters are replaced\n\t\thtml = html.replace(/[\\u007f-\\uffff]/g, function(c) {\n\t\t\treturn '&#x' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4) + ';';\n\t\t});\n\n\t\t// process email rules\n\t\tvar rules = keystone.get('email rules');\n\n\t\tif (rules) {\n\n\t\t\tif (!Array.isArray(rules)) {\n\t\t\t\trules = [rules];\n\t\t\t}\n\n\t\t\t_.each(rules, function(rule) {\n\t\t\t\tif (rule.find && rule.replace) {\n\n\t\t\t\t\tvar find = rule.find,\n\t\t\t\t\t\treplace = rule.replace;\n\n\t\t\t\t\tif ('string' === typeof find) {\n\t\t\t\t\t\tfind = new RegExp(find, 'gi');\n\t\t\t\t\t}\n\n\t\t\t\t\thtml = html.replace(find, replace);\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\n\t\tcallback(null, {\n\t\t\tsubject: locals.subject,\n\t\t\thtml: html\n\t\t});\n\n\t}.bind(this));\n\n};\n\n/**\n * Loads the template. Looks for `templateName.templateExt`, followed by `templateName/email.templateExt`\n *\n * @param {Function} callback(err)\n *\n * @api private\n */\n\nEmail.prototype.loadTemplate = function(callback) {\n\n\tcallback = ('function' === typeof callback) ? callback : function() {};\n\n\tvar fsTemplatePath = path.join(Email.getEmailsPath(), this.templateName + '.' + this.templateExt);\n\n\tfs.readFile(fsTemplatePath, function(err, contents) {\n\t\tif (err) {\n\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\tfsTemplatePath = path.join(Email.getEmailsPath(), this.templateName, 'email.' + this.templateExt);\n\n\t\t\t\tfs.readFile(fsTemplatePath, function(err, contents) {\n\t\t\t\t\tcallback(err, fsTemplatePath, contents);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\treturn callback(err);\n\t\t\t}\n\t\t} else {\n\t\t\treturn callback(err, fsTemplatePath, contents);\n\t\t}\n\n\t}.bind(this));\n\n};\n\n/**\n * Ensures the template for the email has been compiled\n *\n * @param {Function} callback(err)\n *\n * @api private\n */\n\nEmail.prototype.compileTemplate = function(callback) {\n\tcallback = ('function' === typeof callback) ? callback : function() {};\n\n\tif (keystone.get('env') === 'production' && templateCache[this.templateName]) {\n\t\treturn process.nextTick(callback);\n\t}\n\n\tthis.loadTemplate(function(err, filename, contents) {\n\t\tif (err) return callback(err);\n\n\t\tvar template = null;\n\t\tif (this.templateCompile) {\n\t\t\ttemplate = this.templateCompile(this.templateEngine, contents.toString(), Email.defaults.compilerOptions, fs.realpathSync(filename));\n\t\t} else {\n\t\t\ttemplate = this.templateEngine.compile(contents.toString(), Email.defaults.compilerOptions || { filename: fs.realpathSync(filename), basedir: this.templateBasePath }, fs.realpathSync(filename));\n\t\t}\n\n\t\ttemplateCache[this.templateName] = template;\n\n\t\tcallback();\n\n\t}.bind(this));\n\n};\n\n/**\n * Prepares the email, with or without render\n *\n * @param  {Object}   options  options to render the email\n * @param  {Function} callback(err, message)\n *\n * @api private\n */\nEmail.prototype.prepare = function(options, callback) {\n\tvar locals = options;\n\n\tif (arguments.length === 3 || !utils.isFunction(callback)) {\n\t\tcallback = arguments[2];\n\t\toptions = arguments[1] || arguments[0];\n\t}\n\n\tcallback = ('function' === typeof callback) ? callback : function() {};\n\n\t// Renders an email via Keystone (default behavior)\n\tif (!this.templateMandrillName || this.templateForceHtml) {\n\n\t\tthis.render(locals, function(err, email){\n\n\t\t\t_.extend(options, email);\n\t\t\tthis.buildOptions.call(this, err, options, callback);\n\t\t}.bind(this));\n\t}\n\t// Uses a Mandrill template directly\n\telse {\n\t\tthis.buildOptions.call(this, null, options, callback);\n\t}\n};\n\n/**\n * Build an options object\n *\n * @param  {Object}   options  Input options\n * @param  {Function} callback(err, callback)\n *\n * @api private\n */\nEmail.prototype.buildOptions = function(err, options, callback) {\n\tcallback = ('function' === typeof callback) ? callback : function() {};\n\n\tif (err) {\n\t\treturn callback(err);\n\t}\n\n\tif (!utils.isObject(options)) {\n\t\treturn callback({\n\t\t\tfrom: 'Email.send',\n\t\t\tkey: 'invalid options',\n\t\t\tmessage: 'options object is required'\n\t\t});\n\t}\n\n\tif ('string' === typeof options.from) {\n\t\toptions.fromName = options.from;\n\t\toptions.fromEmail = options.from;\n\t} else if (utils.isObject(options.from)) {\n\t\toptions.fromName = utils.isObject(options.from.name) ? options.from.name.full : options.from.name;\n\t\toptions.fromEmail = options.from.email;\n\t}\n\n\tif (!options.fromName || !options.fromEmail) {\n\t\treturn callback({\n\t\t\tfrom: 'Email.send',\n\t\t\tkey: 'invalid options',\n\t\t\tmessage: 'options.fromName and options.fromEmail are required'\n\t\t});\n\t}\n\tif (_.isEqual(keystone.get('email transport'), 'mailgun')) {\n\t\tif (!options.mailgun) {\n\t\t\tif (!keystone.get('mailgun api key')) {\n\t\t\t\treturn callback({\n\t\t\t\t\tfrom: 'Email.send',\n\t\t\t\t\tkey: 'missing api key',\n\t\t\t\t\tmessage: 'You must either provide a Mailgun API Instance or set the mandrill api key before sending email.',\n\t\t\t\t});\n\t\t\t}\n\t\t\tvar api_key = keystone.get('mailgun api key');\n\t\t\tvar domain = keystone.get('mailgun domain');\n\t\t\toptions.mailgun = new mailgunapi({ apiKey: api_key, domain: domain });\n\t\t}\n\t} else {\n\t\tif (!options.mandrill) {\n\t\t\tif (!keystone.get('mandrill api key')) {\n\t\t\t\treturn callback({\n\t\t\t\t\tfrom: 'Email.send',\n\t\t\t\t\tkey: 'missing api key',\n\t\t\t\t\tmessage: 'You must either provide a Mandrill API Instance or set the mandrill api key before sending email.',\n\t\t\t\t});\n\t\t\t}\n\t\t\toptions.mandrill = new mandrillapi.Mandrill(keystone.get('mandrill api key'));\n\t\t}\n\t}\n\n\toptions.tags = utils.isArray(options.tags) ? options.tags : [];\n\toptions.tags.push('sent:' + moment().format('YYYY-MM-DD'));\n\toptions.tags.push(this.templateName);\n\n\tif (keystone.get('env') === 'development') {\n\t\toptions.tags.push('development');\n\t}\n\n\t/**\n\t * Convert and concat globalMergeVars\n\t */\n\tif (options.globalMergeVars) {\n\t\toptions.global_merge_vars = (options.global_merge_vars || []).concat(objToMandrillVars(options.globalMergeVars));\n\t}\n\n\tvar recipients = [];\n\tvar mergeVars = [];\n\n\toptions.to = Array.isArray(options.to) ? options.to : [options.to];\n\n\tfor (var i = 0; i < options.to.length; i++) {\n\t\tif (typeof options.to[i] === 'string') {\n\t\t\toptions.to[i] = { email: options.to[i] };\n\t\t} else if (typeof options.to[i] === 'object' && options.to[i] !== null) {\n\t\t\tif (!options.to[i].email) {\n\t\t\t\treturn callback({\n\t\t\t\t\tfrom: 'Email.send',\n\t\t\t\t\tkey: 'invalid recipient',\n\t\t\t\t\tmessage: 'Recipient ' + (i + 1) + ' does not have a valid email address.',\n\t\t\t\t});\n\t\t\t}\n\n\t\t} else {\n\t\t\treturn callback({\n\t\t\t\tfrom: 'Email.send',\n\t\t\t\tkey: 'invalid recipient',\n\t\t\t\tmessage: 'Recipient ' + (i + 1) + ' is not a string or an object.',\n\t\t\t});\n\n\t\t}\n\n\t\tvar recipient = { email: options.to[i].email };\n\t\tvar vars = [{ name: 'email', content: recipient.email }];\n\n\t\tif (typeof options.to[i].name === 'string') {\n\t\t\trecipient.name = options.to[i].name;\n\t\t\tvars.push({ name: 'name', content: options.to[i].name });\n\t\t} else if (typeof options.to[i].name === 'object') {\n\t\t\trecipient.name = options.to[i].name.full || '';\n\t\t\tvars.push({ name: 'name', content: options.to[i].name.full || '' });\n\t\t\tvars.push({ name: 'first_name', content: options.to[i].name.first || '' });\n\t\t\tvars.push({ name: 'last_name', content: options.to[i].name.last || '' });\n\t\t}\n\n\t\t// Mandrill template\n\t\tif (recipient.vars) {\n\t\t\tvars.concat(objToMandrillVars(recipient.vars));\n\t\t}\n\n\t\trecipients.push(recipient);\n\n\t\tmergeVars.push({\n\t\t\trcpt: recipient.email,\n\t\t\tvars: vars,\n\t\t});\n\t}\n\n\tvar message = {\n\t\theaders: options.headers,\n\t\tfrom_name: options.fromName,\n\t\tfrom_email: options.fromEmail,\n\t\ttags: options.tags,\n\t\tattachments: options.attachments,\n\t\tto: recipients,\n\t\tglobal_merge_vars: options.global_merge_vars,\n\t\tmerge_vars: mergeVars,\n\t\tasync: true,\n\t};\n\n\tif (options.subject) {\n\t\tmessage.subject = options.subject;\n\t}\n\n\tif (options.html) {\n\t\tmessage.html = options.html;\n\t}\n\n\t_.defaults(message, options.mandrillOptions);\n\t_.defaults(message, Email.defaults.mandrill);\n\n\tvar toSend = {\n\t\tmessage: message,\n\t};\n\n\tif (this.templateMandrillName) {\n\t\ttoSend.template_name = this.templateMandrillName;\n\t\ttoSend.template_content = this.templateMandrillContent;\n\t\tif (_.isArray(options.templateMandrillContent)) {\n\t\t\ttoSend.template_content = toSend.template_content.concat(options.templateMandrillContent);\n\t\t}\n\t}\n\n\tcallback(null, toSend);\n};\n\n/**\n * Sends the email\n *\n * Options:\n *\n * - mandrill\n *   Initialised Mandrill API instance\n *\n * - tags\n *   Array of tags to send to Mandrill\n *\n * - to\n *   Object / String or Array of Objects / Strings to send to, e.g.\n *   ['jed@team9.com.au', { email: 'jed.watson@gmail.com' }]\n *   { email: 'jed@team9.com.au' }\n *   'jed@team9.com.au'\n *\n * - fromName\n *   Name to send from\n *\n * - fromEmail\n *   Email address to send from\n *\n * - headers\n *   Headers to send through with the email\n *\n * For compatibility with older implementations, send supports providing\n * locals and options objects as the first and second arguments, and the\n * callback as the third.\n *\n * @param {Object} options (passed to `email.render()`)\n * @param {Function} callback(err, info)\n *\n * @api private\n */\n\nEmail.prototype.send = function (options, callback) {\n\tvar locals = options;\n\tvar prepareOptions = [locals];\n\n\tif (arguments.length === 3) {\n\t\t// we expect locals, options, callback\n\t\tif (_.isObject(arguments[1])) {\n\t\t\tprepareOptions.push(arguments[1]);\n\t\t}\n\t\tcallback = arguments[2];\n\n\t} else if (arguments.length === 2 && !utils.isFunction(callback)) {\n\t\t// no callback so we expect locals, options\n\t\tif (_.isObject(arguments[1])) {\n\t\t\tprepareOptions.push(arguments[1]);\n\t\t}\n\t\tcallback = function(err, info) {// eslint-disable-line no-unused-vars\n\t\t\tif (err) console.log(err);\n\t\t};\n\n\t} else if (arguments.length === 1) {\n\t\t// we expect options here and it is pushed already\n\t\tcallback = function (err, info) { // eslint-disable-line no-unused-vars\n\t\t\tif (err) console.log(err);\n\t\t};\n\t}\n\n\tprepareOptions.push(function (err, toSend) {\n\t\tif (err) {\n\t\t\treturn callback(err, null);\n\t\t}\n\n\t\tvar onSuccess = function (info) {\n\t\t\tcallback(null, info);\n\t\t};\n\n\t\tvar onFail = function (info) {\n\t\t\tcallback({\n\t\t\t\tfrom: 'Email.send',\n\t\t\t\tkey: 'send error',\n\t\t\t\tmessage: 'Email transport encountered an error and did not send the emails.',\n\t\t\t\tinfo: info,\n\t\t\t});\n\t\t};\n\t\tif (_.isEqual(keystone.get('email transport'), 'mailgun')) {\n\t\t\tvar msg = toSend.message;\n\t\t\tvar data = {\n\t\t\t\tfrom: buildAddress(msg.from_email, msg.from_name),\n\t\t\t\tto: buildAddress(msg.to),\n\t\t\t\tsubject: msg.subject,\n\t\t\t\thtml: juice(msg.html),\n\t\t\t\tattachment: msg.attachments,\n\t\t\t};\n\t\t\treturn process.nextTick(function () {\n\t\t\t\toptions.mailgun.messages().send(data, function (err, body) {\n\t\t\t\t\tif (err) return onFail(err);\n\t\t\t\t\tonSuccess(body);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tif (this.templateMandrillName) {\n\t\t\t\treturn process.nextTick(function () {\n\t\t\t\t\toptions.mandrill.messages.sendTemplate(toSend, onSuccess, onFail);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn process.nextTick(function () {\n\t\t\t\t\toptions.mandrill.messages.send(toSend, onSuccess, onFail);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}.bind(this));\n\n\tthis.prepare.apply(this, prepareOptions);\n};\n\n/**\n * Renders a Mandrill template\n * @param  {Object}   options  Same options that sendTemplate\n * @param  {Function} callback(err, info)\n */\nEmail.prototype.renderMandrill = function (options, callback) {\n\tvar locals = options;\n\tvar prepareOptions = [locals];\n\n\tif (arguments.length === 3 || !utils.isFunction(callback)) {\n\t\tcallback = arguments[2];\n\t\toptions = arguments[1] || arguments[0];\n\t\tprepareOptions.push(options);\n\t}\n\n\tcallback = ('function' === typeof callback) ? callback : function() {};\n\n\tprepareOptions.push(function (err, toSend) {\n\t\tif (err) {\n\t\t\treturn callback(err, null);\n\t\t}\n\n\t\t/**\n\t\t * The object sent to render is not the same as for the sendTemplate\n\t\t * method, so it needs to be changed accordingly.\n\t\t *\n\t\t * https://mandrillapp.com/api/docs/templates.JSON.html#method=render\n\t\t * https://mandrillapp.com/api/docs/messages.JSON.html#method=send-template\n\t\t */\n\n\t\tif (toSend.message.merge_vars && toSend.message.merge_vars.length) {\n\t\t\ttoSend.merge_vars = toSend.message.merge_vars[0].vars;\n\t\t}\n\n\t\tif (toSend.message.global_merge_vars) {\n\t\t\ttoSend.global_merge_vars = toSend.message.global_merge_vars;\n\t\t}\n\n\t\tvar onSuccess = function (info) {\n\t\t\tcallback(null, info);\n\t\t};\n\n\t\tvar onFail = function (info) {\n\t\t\tcallback({\n\t\t\t\tfrom: 'Email.renderMandrill',\n\t\t\t\tkey: 'render error',\n\t\t\t\tmessage: 'Mandrill encountered an error rendering the email.',\n\t\t\t\tinfo: info,\n\t\t\t});\n\t\t};\n\n\t\toptions.mandrill.templates.render(toSend, onSuccess, onFail);\n\t});\n\n\tthis.prepare.apply(this, prepareOptions);\n};\n\nEmail.getEmailsPath = getEmailsPath;\nEmail.templateCache = templateCache;\nEmail.templateCSSMethods = templateCSSMethods;\nEmail.defaults = defaultConfig;\n\nexports = module.exports = Email;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/Type.js":"/*!\n * Module dependencies.\n */\nvar _ = require('underscore');\nvar di = require('asyncdi');\nvar marked = require('marked');\nvar Path = require('../../lib/path');\nvar utils = require('keystone-utils');\n\nvar DEFAULT_OPTION_KEYS = [\n\t'path',\n\t'paths',\n\t'type',\n\t'label',\n\t'note',\n\t'size',\n\t'initial',\n\t'required',\n\t'col',\n\t'noedit',\n\t'nocol',\n\t'nosort',\n\t'nofilter',\n\t'indent',\n\t'hidden',\n\t'collapse',\n\t'dependsOn'\n];\n\n/**\n * Field Constructor\n * =================\n *\n * Extended by fieldType Classes, should not be used directly.\n *\n * @api public\n */\nfunction Field(list, path, options) {\n\n\t// Set field properties and options\n\tthis.list = list;\n\tthis._path = new Path(path);\n\tthis.path = path;\n\n\tthis.type = this.constructor.name;\n\tthis.options = utils.options(this.defaults, options);\n\tthis.label = options.label || utils.keyToLabel(this.path);\n\tthis.typeDescription = options.typeDescription || this.typeDescription || this.type;\n\n\t// Add the field to the schema\n\tthis.list.automap(this);\n\tthis.addToSchema();\n\n\t// Warn on required fields that aren't initial\n\tif (this.options.required &&\n        this.options.initial === undefined &&\n        this.options.default === undefined &&\n        !this.options.value &&\n        !this.list.get('nocreate') &&\n        this.path !== this.list.mappings.name\n\t) {\n\t\tconsole.error('\\nError: Invalid Configuration\\n\\n' +\n\t\t\t'Field (' + list.key + '.' + path + ') is required but not initial, and has no default or generated value.\\n' +\n\t\t\t'Please provide a default, remove the required setting, or set initial: false to override this error.\\n');\n\t\tprocess.exit(1);\n\t}\n\n\t// Add pre-save handler to the list if this field watches others\n\tif (this.options.watch) {\n\t\tthis.list.schema.pre('save', this.getPreSaveWatcher());\n\t}\n\n\t// Convert notes from markdown to html\n\tvar note = null;\n\tObject.defineProperty(this, 'note', {\n\t\tget: function() {\n\t\t\treturn (note === null) ? (note = (this.options.note) ? marked(this.options.note) : '') : note;\n\t\t}\n\t});\n\n}\n\n/**\n * Gets the options for the Field, as used by the React components\n */\nField.prototype.getOptions = function() {\n\tif (!this.__options) {\n\t\tthis.__options = {};\n\t\tvar optionKeys = DEFAULT_OPTION_KEYS;\n\t\tif (_.isArray(this._properties)) {\n\t\t\toptionKeys = optionKeys.concat(this._properties);\n\t\t}\n\t\toptionKeys.forEach(function(key) {\n\t\t\tif (this[key]) {\n\t\t\t\tthis.__options[key] = this[key];\n\t\t\t} else if (this.options[key]){\n\t\t\t\tthis.__options[key] = this.options[key];\n\t\t\t}\n\t\t}, this);\n\t\tif (this.getProperties) {\n\t\t\t_.extend(this.__options, this.getProperties());\n\t\t}\n\t\tthis.__options.hasFilterMethod = this.addFilterToQuery ? true : false;\n\t\tthis.__options.defaultValue = this.getDefaultValue();\n\t}\n\treturn this.__options;\n};\n\n/**\n * Validates and returns the size of the field.\n * Defaults to deprecated 'width' option.\n */\nField.prototype.getSize = function() {\n\tif (!this.__size) {\n\t\tvar size = this._fixedSize || this.options.size || this.options.width;\n\t\tif (size !== 'small' && size !== 'medium' && size !== 'large' && size !== 'full') {\n\t\t\tsize = this._defaultSize || 'large';\n\t\t}\n\t\tthis.__size = size;\n\t}\n\treturn this.__size;\n};\n\n/**\n * Gets default value for the field, based on the option or default for the type\n */\nField.prototype.getDefaultValue = function() {\n\treturn this.options.default || '';\n};\n\n/**\n * Gets the field's data from an Item, as used by the React components\n */\nField.prototype.getData = function(item) {\n\treturn item.get(this.path);\n};\n\n/**\n * Field watching implementation\n */\nField.prototype.getPreSaveWatcher = function() {\n\tvar field = this;\n\tvar applyValue;\n\n\tif (this.options.watch === true) {\n\t\t// watch == true means always apply the value method\n\t\tapplyValue = function() { return true; };\n\t} else {\n\t\t// if watch is a string, convert it to a list of paths to watch\n\t\tif (_.isString(this.options.watch)) {\n\t\t\tthis.options.watch = this.options.watch.split(' ');\n\t\t}\n\t\tif (_.isFunction(this.options.watch)) {\n\t\t\tapplyValue = this.options.watch;\n\t\t} else if (_.isArray(this.options.watch)) {\n\t\t\tapplyValue = function(item) {\n\t\t\t\tvar pass = false;\n\t\t\t\tfield.options.watch.forEach(function(path) {\n\t\t\t\t\tif (item.isModified(path)) pass = true;\n\t\t\t\t});\n\t\t\t\treturn pass;\n\t\t\t};\n\t\t} else if (_.isObject(this.options.watch)) {\n\t\t\tapplyValue = function(item) {\n\t\t\t\tvar pass = false;\n\t\t\t\t_.each(field.options.watch, function(value, path) {\n\t\t\t\t\tif (item.isModified(path) && item.get(path) === value) pass = true;\n\t\t\t\t});\n\t\t\t\treturn pass;\n\t\t\t};\n\t\t}\n\t}\n\n\tif (!applyValue) {\n\t\tconsole.error('\\nError: Invalid Configuration\\n\\n' +\n\t\t\t'Invalid watch value (' + this.options.watch + ') provided for ' + this.list.key + '.' + this.path + ' (' + this.type + ')');\n\t\tprocess.exit(1);\n\t}\n\n\tif (!_.isFunction(this.options.value)) {\n\t\tconsole.error('\\nError: Invalid Configuration\\n\\n' +\n\t\t\t'Watch set with no value method provided for ' + this.list.key + '.' + this.path + ' (' + this.type + ')');\n\t\tprocess.exit(1);\n\t}\n\n\treturn function(next) {\n\t\tif (!applyValue(this)) {\n\t\t\treturn next();\n\t\t}\n\t\tdi(field.options.value).call(this, function(err, val){\n\t\t\tif(err){\n\t\t\t\tconsole.error('\\nError: ' +\n\t\t\t\t'Watch set with value method for ' + field.list.key + '.' + field.path + ' (' + field.type + ') throws error:' + err);\n\t\t\t}else{\n\t\t\t\tthis.set(field.path, val);\n\t\t\t}\n\t\t\tnext();\n\t\t}.bind(this));\n\t};\n\n};\nexports = module.exports = Field;\n\n/** Getter properties for the Field prototype */\nObject.defineProperty(Field.prototype, 'size', { get: function() { return this.getSize(); } });\nObject.defineProperty(Field.prototype, 'initial', { get: function() { return this.options.initial || false; } });\nObject.defineProperty(Field.prototype, 'required', { get: function() { return this.options.required || false; } });\nObject.defineProperty(Field.prototype, 'note', { get: function() { return this.options.note || ''; } });\nObject.defineProperty(Field.prototype, 'col', { get: function() { return this.options.col || false; } });\nObject.defineProperty(Field.prototype, 'noedit', { get: function() { return this.options.noedit || false; } });\nObject.defineProperty(Field.prototype, 'nocol', { get: function() { return this.options.nocol || false; } });\nObject.defineProperty(Field.prototype, 'nosort', { get: function() { return this.options.nosort || false; } });\nObject.defineProperty(Field.prototype, 'nofilter', { get: function() { return this.options.nofilter || false; } });\nObject.defineProperty(Field.prototype, 'collapse', { get: function() { return this.options.collapse || false; } });\nObject.defineProperty(Field.prototype, 'hidden', { get: function() { return this.options.hidden || false; } });\nObject.defineProperty(Field.prototype, 'dependsOn', { get: function() { return this.options.dependsOn || false; } });\n\n/**\n * Default method to register the field on the List's Mongoose Schema.\n * Overridden by some fieldType Classes\n *\n * @api public\n */\nField.prototype.addToSchema = function() {\n\tvar ops = (this._nativeType) ? _.defaults({ type: this._nativeType }, this.options) : this.options;\n\tthis.list.schema.path(this.path, ops);\n\tthis.bindUnderscoreMethods();\n};\n\nField.prototype.bindUnderscoreMethods = function(methods) {\n\tvar field = this;\n\t// automatically bind underscore methods specified by the _underscoreMethods property\n\t// always include the 'update' method\n\t(this._underscoreMethods || []).concat({ fn: 'updateItem', as: 'update' }, (methods || [])).forEach(function(method) {\n\t\tif ('string' === typeof method) {\n\t\t\tmethod = { fn: method, as: method };\n\t\t}\n\t\tif ('function' !== typeof field[method.fn]) {\n\t\t\tthrow new Error('Invalid underscore method (' + method.fn + ') applied to ' + field.list.key + '.' + field.path + ' (' + field.type + ')');\n\t\t}\n\t\tfield.underscoreMethod(method.as, function() {\n\t\t\tvar args = [this].concat(Array.prototype.slice.call(arguments));\n\t\t\treturn field[method.fn].apply(field, args);\n\t\t});\n\t});\n};\n\n/**\n * Adds a method to the underscoreMethods collection on the field's list,\n * with a path prefix to match this field's path and bound to the document\n *\n * @api public\n */\nField.prototype.underscoreMethod = function(path, fn) {\n\tthis.list.underscoreMethod(this.path + '.' + path, function() {\n\t\treturn fn.apply(this, arguments);\n\t});\n};\n\n/**\n * Default method to format the field value for display\n * Overridden by some fieldType Classes\n *\n * @api public\n */\nField.prototype.format = function(item) {\n\treturn item.get(this.path);\n};\n\n/**\n * Default method to detect whether the field has been modified in an item\n * Overridden by some fieldType Classes\n *\n * @api public\n */\nField.prototype.isModified = function(item) {\n\treturn item.isModified(this.path);\n};\n\n/**\n * Validates that a value for this field has been provided in a data object\n * Overridden by some fieldType Classes\n *\n * @api public\n */\nField.prototype.validateInput = function(data, required, item) {\n\tif (!required) return true;\n\tvar value = this.getValueFromData(data);\n\tif (value === undefined && item && item.get(this.path)) return true;\n\tif ('string' === typeof data[this.path]) {\n\t\treturn (data[this.path].trim()) ? true : false;\n\t} else {\n\t\treturn (data[this.path]) ? true : false;\n\t}\n};\n\n/**\n * Updates the value for this field in the item from a data object\n * Overridden by some fieldType Classes\n *\n * @api public\n */\nField.prototype.updateItem = function(item, data) {\n\tvar value = this.getValueFromData(data);\n\t// This is a deliberate type coercion so that numbers from forms play nice\n\tif (value !== undefined && value != item.get(this.path)) { // eslint-disable-line eqeqeq\n\t\titem.set(this.path, value);\n\t}\n};\n\n/**\n * Retrieves the value from an object, whether the path is nested or flattened\n *\n * @api public\n */\nField.prototype.getValueFromData = function(data) {\n\treturn this.path in data ? data[this.path] : this._path.get(data);\n};","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/path.js":"var utils = require('keystone-utils');\n\n/**\n * Path Class\n *\n * @api public\n */\n\nexports = module.exports = function Path(str) {\n\n\tif (!(this instanceof Path)) {\n\t\treturn new Path(str);\n\t}\n\n\tthis.original = str;\n\n\tvar parts = this.parts = str.split('.');\n\tvar last = this.last = this.parts[this.parts.length - 1];\n\tvar exceptLast = [];\n\n\tfor (var i = 0; i < parts.length - 1; i++) {\n\t\texceptLast.push(parts[i]);\n\t}\n\n\tthis.exceptLast = exceptLast.join('.');\n\n\tthis.addTo = function(obj, val) {\n\t\tvar o = obj;\n\t\tfor (var i = 0; i < parts.length - 1; i++) {\n\t\t\tif (!utils.isObject(o[parts[i]])) {\n\t\t\t\to[parts[i]] = {};\n\t\t\t}\n\t\t\to = o[parts[i]];\n\t\t}\n\t\to[last] = val;\n\t\treturn obj;\n\t};\n\n\tthis.get = function(obj) {\n\t\tvar o = obj;\n\t\tfor (var i = 0; i < parts.length; i++) {\n\t\t\tif (typeof o !== 'object') return undefined;\n\t\t\to = o[parts[i]];\n\t\t}\n\t\treturn o;\n\t};\n\n\tthis.prependToLast = function(prepend, titlecase) {\n\t\tvar rtn = '';\n\t\tfor (var i = 0; i < parts.length - 1; i++) {\n\t\t\trtn += parts[i] + '.';\n\t\t}\n\t\treturn rtn + (prepend || '') + (titlecase ? utils.upcase(last) : last);\n\t};\n\n\tthis.append = function(append) {\n\t\treturn str + append;\n\t};\n\n\tthis.flatten = function(titlecase) {\n\t\treturn utils.camelcase(parts.join('_'), titlecase ? true : false);\n\t};\n\n\tthis.flattenplural = function(titlecase) {\n\t\treturn utils.camelcase([].concat(exceptLast).concat(utils.plural(last)).join('_'), titlecase ? true : false);\n\t};\n\n\tthis.flattensingular = function(titlecase) {\n\t\treturn utils.camelcase([].concat(exceptLast).concat(utils.singular(last)).join('_'), titlecase ? true : false);\n\t};\n\n\treturn this;\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/fieldTypes.js":"var fields = {\n\tget AzureFile () { return require('../fields/types/azurefile/AzureFileType'); },\n\tget Boolean () { return require('../fields/types/boolean/BooleanType'); },\n\tget CloudinaryImage () { return require('../fields/types/cloudinaryimage/CloudinaryImageType'); },\n\tget CloudinaryImages () { return require('../fields/types/cloudinaryimages/CloudinaryImagesType'); },\n\tget Code () { return require('../fields/types/code/CodeType'); },\n\tget Color () { return require('../fields/types/color/ColorType'); },\n\tget Date () { return require('../fields/types/date/DateType'); },\n\tget DateArray () { return require('../fields/types/datearray/DateArrayType'); },\n\tget Datetime () { return require('../fields/types/datetime/DatetimeType'); },\n\tget Email () { return require('../fields/types/email/EmailType'); },\n\tget Embedly () { return require('../fields/types/embedly/EmbedlyType'); },\n\tget GeoPoint () { return require('../fields/types/geopoint/GeoPointType'); },\n\tget Html () { return require('../fields/types/html/HtmlType'); },\n\tget Key () { return require('../fields/types/key/KeyType'); },\n\tget LocalFile () { return require('../fields/types/localfile/LocalFileType'); },\n\tget LocalFiles () { return require('../fields/types/localfiles/LocalFilesType'); },\n\tget Location () { return require('../fields/types/location/LocationType'); },\n\tget Markdown () { return require('../fields/types/markdown/MarkdownType'); },\n\tget Money () { return require('../fields/types/money/MoneyType'); },\n\tget Name () { return require('../fields/types/name/NameType'); },\n\tget Number () { return require('../fields/types/number/NumberType'); },\n\tget NumberArray () { return require('../fields/types/numberarray/NumberArrayType'); },\n\tget Password () { return require('../fields/types/password/PasswordType'); },\n\tget Relationship () { return require('../fields/types/relationship/RelationshipType'); },\n\tget S3File () { return require('../fields/types/s3file/S3FileType'); },\n\tget Select () { return require('../fields/types/select/SelectType'); },\n\tget Text () { return require('../fields/types/text/TextType'); },\n\tget TextArray () { return require('../fields/types/textarray/TextArrayType'); },\n\tget Textarea () { return require('../fields/types/textarea/TextareaType'); },\n\tget Url () { return require('../fields/types/url/UrlType'); }\n};\n\nmodule.exports = fields;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list.js":"var _ = require('underscore');\nvar keystone = require('../');\nvar schemaPlugins = require('./schemaPlugins');\nvar utils = require('keystone-utils');\n\n/**\n * List Class\n *\n * @param {String} key\n * @param {Object} options\n */\n\nfunction List(key, options) {\n\tif (!(this instanceof List)) return new List(key, options);\n\n\tvar defaultOptions = {\n\t\tschema: {\n\t\t\tcollection: keystone.prefixModel(key)\n\t\t},\n\t\tnoedit: false,\n\t\tnocreate: false,\n\t\tnodelete: false,\n\t\tautocreate: false,\n\t\tsortable: false,\n\t\thidden: false,\n\t\ttrack: false,\n\t\tinherits: false,\n\t\tsearchFields: '__name__',\n\t\tdefaultSort: '__default__',\n\t\tdefaultColumns: '__name__'\n\t};\n\n\t// initialFields values are initialised on demand by the getter\n\tvar initialFields;\n\n\t// Inherit default options from parent list if it exists\n\tif (options && options.inherits) {\n\t\tif (options.inherits.options && options.inherits.options.inherits) {\n\t\t\tthrow new Error('Inherited Lists may not contain any inheritance');\n\t\t}\n\t\tdefaultOptions = utils.options(defaultOptions, options.inherits.options);\n\t}\n\n\tthis.options = utils.options(defaultOptions, options);\n\n\t// init properties\n\tthis.key = key;\n\tthis.path = this.get('path') || utils.keyToPath(key, true);\n\tthis.schema = new keystone.mongoose.Schema({}, this.options.schema);\n\tthis.schemaFields = [];\n\tthis.uiElements = [];\n\tthis.underscoreMethods = {};\n\tthis.fields = {};\n\tthis.fieldTypes = {};\n\tthis.relationships = {};\n\tthis.mappings = {\n\t\tname: null,\n\t\tcreatedBy: null,\n\t\tcreatedOn: null,\n\t\tmodifiedBy: null,\n\t\tmodifiedOn: null\n\t};\n\n\t// init mappings\n\t_.each(this.options.map, function(val, key) { this.map(key, val); }, this);\n\n\t// define property getters\n\tObject.defineProperty(this, 'label', { get: function() {\n\t\treturn this.get('label') || this.set('label', utils.plural(utils.keyToLabel(key)));\n\t} });\n\tObject.defineProperty(this, 'singular', { get: function() {\n\t\treturn this.get('singular') || this.set('singular', utils.singular(this.label));\n\t} });\n\tObject.defineProperty(this, 'plural', { get: function() {\n\t\treturn this.get('plural') || this.set('plural', utils.plural(this.singular));\n\t} });\n\tObject.defineProperty(this, 'namePath', { get: function() {\n\t\treturn this.mappings.name || '_id';\n\t} });\n\tObject.defineProperty(this, 'nameField', { get: function() {\n\t\treturn this.fields[this.mappings.name];\n\t} });\n\tObject.defineProperty(this, 'nameIsVirtual', { get: function() {\n\t\treturn this.model.schema.virtuals[this.mappings.name] ? true : false;\n\t} });\n\tObject.defineProperty(this, 'nameIsEditable', { get: function() {\n\t\treturn (this.fields[this.mappings.name] && this.fields[this.mappings.name].type === 'text') ? !this.fields[this.mappings.name].noedit : false;\n\t} });\n\tObject.defineProperty(this, 'nameIsInitial', { get: function() {\n\t\treturn (this.fields[this.mappings.name] && this.fields[this.mappings.name].options.initial === undefined);\n\t} });\n\tObject.defineProperty(this, 'initialFields', { get: function() {\n\t\treturn initialFields || (initialFields = _.filter(this.fields, function(i) { return i.initial; }));\n\t} });\n\tif (this.get('sortable')) {\n\t\tschemaPlugins.sortable.apply(this);\n\t}\n\tif (this.get('autokey')) {\n\t\tschemaPlugins.autokey.apply(this);\n\t}\n\tif (this.get('track')) {\n\t\tschemaPlugins.track.apply(this);\n\t}\n\tif (this.get('history')) {\n\t\tschemaPlugins.history.apply(this);\n\t}\n\tif (this.get('inherits')) {\n\t\tvar parentFields = this.get('inherits').schemaFields;\n\t\tthis.add.apply(this, parentFields);\n\t}\n}\n\n// Search Fields\nObject.defineProperty(List.prototype, 'searchFields', {\n\tget: function() {\n\t\tif (!this._searchFields) {\n\t\t\tthis._searchFields = this.expandPaths(this.get('searchFields'));\n\t\t}\n\t\treturn this._searchFields;\n\t}, set: function(value) {\n\t\tthis.set('searchFields', value);\n\t\tdelete this._searchFields;\n\t}\n});\n\n// Default Sort Field\nObject.defineProperty(List.prototype, 'defaultSort', {\n\tget: function() {\n\t\tvar ds = this.get('defaultSort');\n\t\treturn (ds === '__default__') ? (this.get('sortable') ? 'sortOrder' : this.namePath) : ds;\n\t}, set: function(value) {\n\t\tthis.set('defaultSort', value);\n\t}\n});\n\n// Default Column Fields\nObject.defineProperty(List.prototype, 'defaultColumns', {\n\tget: function() {\n\t\tif (!this._defaultColumns) {\n\t\t\tthis._defaultColumns = this.expandColumns(this.get('defaultColumns'));\n\t\t}\n\t\treturn this._defaultColumns;\n\t}, set: function(value) {\n\t\tthis.set('defaultColumns', value);\n\t\tdelete this._defaultColumns;\n\t}\n});\n\n// Add prototype methods\nList.prototype.set = require('./list/set');\nList.prototype.get = List.prototype.set;\nList.prototype.add = require('./list/add');\nList.prototype.map = require('./list/map');\nList.prototype.automap = require('./list/automap');\nList.prototype.field = require('./list/field');\nList.prototype.relationship = require('./list/relationship');\nList.prototype.underscoreMethod = require('./list/underscoreMethod');\nList.prototype.register = require('./list/register');\nList.prototype.getData = require('./list/getData');\nList.prototype.getOptions = require('./list/getOptions');\nList.prototype.getAdminURL = require('./list/getAdminURL');\nList.prototype.getDocumentName = require('./list/getDocumentName');\nList.prototype.addSearchToQuery = require('./list/addSearchToQuery');\nList.prototype.addFiltersToQuery = require('./list/addFiltersToQuery');\nList.prototype.isReserved = require('./list/isReserved');\nList.prototype.expandColumns = require('./list/expandColumns');\nList.prototype.expandPaths = require('./list/expandPaths');\nList.prototype.selectColumns = require('./list/selectColumns');\nList.prototype.processFilters = require('./list/processFilters');\nList.prototype.getSearchFilters = require('./list/getSearchFilters');\nList.prototype.updateAll = require('./list/updateAll');\nList.prototype.getUniqueValue = require('./list/getUniqueValue');\nList.prototype.getPages = require('./list/getPages');\nList.prototype.paginate = require('./list/paginate');\n\n/*!\n * Export class\n */\nexports = module.exports = List;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/schemaPlugins.js":"exports.sortable = require('./schemaPlugins/sortable');\nexports.autokey = require('./schemaPlugins/autokey');\nexports.track = require('./schemaPlugins/track');\nexports.history = require('./schemaPlugins/history');\n\nexports.methods = {\n\tgetRelated: require('./schemaPlugins/methods/getRelated'),\n\tpopulateRelated: require('./schemaPlugins/methods/populateRelated')\n};\n\nexports.options = {\n\ttransform: require('./schemaPlugins/options/transform')\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/schemaPlugins/sortable.js":"module.exports = function sortable() {\n\n\tvar list = this;\n\n\tthis.schema.add({\n\t\tsortOrder: { type: Number, index: true }\n\t});\n\n\tthis.schema.pre('save', function(next) {\n\n\t\tif (typeof this.sortOrder === 'number') {\n\t\t\treturn next();\n\t\t}\n\n\t\tvar item = this;\n\t\tlist.model.findOne().sort('-sortOrder').exec(function(err, max) {// eslint-disable-line no-unused-vars, handle-callback-err\n\t\t\titem.sortOrder = (max && max.sortOrder) ? max.sortOrder + 1 : 1;\n\t\t\tnext();\n\t\t});\n\n\t});\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/schemaPlugins/autokey.js":"var _ = require('underscore');\nvar utils = require('keystone-utils');\n\nmodule.exports = function autokey() {\n\n\tvar autokey = this.autokey = _.clone(this.get('autokey'));\n\tvar def = {};\n\tvar list = this;\n\n\tif (!autokey.from) {\n\t\tvar fromMsg = 'Invalid List Option (autokey) for ' + list.key + ' (from is required)\\n';\n\t\tthrow new Error(fromMsg);\n\t}\n\tif (!autokey.path) {\n\t\tvar pathMsg = 'Invalid List Option (autokey) for ' + list.key + ' (path is required)\\n';\n\t\tthrow new Error(pathMsg);\n\t}\n\n\tif ('string' === typeof autokey.from) {\n\t\tautokey.from = autokey.from.split(' ');\n\t}\n\n\tautokey.from = autokey.from.map(function(i) {\n\t\ti = i.split(':');\n\t\treturn { path: i[0], format: i[1] };\n\t});\n\n\tdef[autokey.path] = {\n\t\ttype: String,\n\t\tindex: true\n\t};\n\n\tif (autokey.unique) {\n\t\tdef[autokey.path].index = { unique: true };\n\t}\n\n\tthis.schema.add(def);\n\n\tvar getUniqueKey = function(doc, src, callback) {\n\n\t\tvar q = list.model.find().where(autokey.path, src);\n\n\t\tif (_.isObject(autokey.unique)) {\n\t\t\t_.each(autokey.unique, function(k, v) {\n\t\t\t\tif (_.isString(v) && v.charAt(0) === ':') {\n\t\t\t\t\tq.where(k, doc.get(v.substr(1)));\n\t\t\t\t} else {\n\t\t\t\t\tq.where(k, v);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tq.exec(function(err, results) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t// deliberate use of implicit type coercion with == because doc.id may need to become a String\n\t\t\t} else if (results.length && (results.length > 1 || results[0].id != doc.id)) { // eslint-disable-line eqeqeq\n\t\t\t\tvar inc = src.match(/^(.+)\\-(\\d+)$/);\n\t\t\t\tif (inc && inc.length === 3) {\n\t\t\t\t\tsrc = inc[1];\n\t\t\t\t\tinc = '-' + ((inc[2] * 1) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tinc = '-1';\n\t\t\t\t}\n\t\t\t\treturn getUniqueKey(doc, src + inc, callback);\n\t\t\t} else {\n\t\t\t\tdoc.set(autokey.path, src);\n\t\t\t\treturn callback();\n\t\t\t}\n\t\t});\n\t};\n\n\tthis.schema.pre('save', function(next) {\n\n\t\tvar modified = false;\n\t\tvar values = [];\n\n\t\tautokey.from.forEach(function(ops) {\n\t\t\tif (list.fields[ops.path]) {\n\t\t\t\tvalues.push(list.fields[ops.path].format(this, ops.format));\n\t\t\t\tif (list.fields[ops.path].isModified(this)) {\n\t\t\t\t\tmodified = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvalues.push(this.get(ops.path));\n\t\t\t\t// virtual paths are always assumed to have changed, except 'id'\n\t\t\t\tif (ops.path !== 'id' && list.schema.pathType(ops.path) === 'virtual' || this.isModified(ops.path)) {\n\t\t\t\t\tmodified = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}, this);\n\n\t\t// if has a value and is unmodified or fixed, don't update it\n\t\tif ((!modified || autokey.fixed) && this.get(autokey.path)) {\n\t\t\treturn next();\n\t\t}\n\t\tvar newKey = utils.slug(values.join(' '), null, { locale: autokey.locale }) || this.id;\n\t\tif (autokey.unique) {\n\t\t\treturn getUniqueKey(this, newKey, next);\n\t\t} else {\n\t\t\tthis.set(autokey.path, newKey);\n\t\t\treturn next();\n\t\t}\n\n\t});\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/schemaPlugins/track.js":"var _ = require('underscore');\nvar keystone = require('../../');\nvar Types = require('../fieldTypes');\n\n/**\n * List track option\n *\n * When enabled, it tracks when a document are created/updated, \n * as well as the user who created/updated it.\n */\n\nmodule.exports = function track() {\n\t\n\tvar list = this;\n\tvar options = list.get('track');\n\tvar userModel = keystone.get('user model');\n\tvar defaultOptions = { \n\t\t\tcreatedAt: false, \n\t\t\tcreatedBy: false,\n\t\t\tupdatedAt: false,\n\t\t\tupdatedBy: false\n\t\t};\n\tvar fields = {};\n\t\n\t// ensure track is a boolean or an object\n\tif (!_.isBoolean(options) && !_.isObject(options) ) {\n\t\tthrow new Error('Invalid List \"track\" option for ' + list.key + '\\n' +\n\t\t\t'\"track\" must be a boolean or an object.\\n\\n' +\n\t\t\t'See http://keystonejs.com/docs/database/#lists-options for more information.');\t\t\t\t\n\t}\n\n\tif (_.isBoolean(options)) {\n\t\t// shorthand: { track: true } sets all tracked fields to true\n\t\tif (options) {\n\t\t\toptions = { \n\t\t\t\tcreatedAt: true, \n\t\t\t\tcreatedBy: true,\n\t\t\t\tupdatedAt: true,\n\t\t\t\tupdatedBy: true\n\t\t\t};\n\t\t} else {\n\t\t\t// otherwise user doesn't want tracking\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// if all track fields are set to false, then user doesn't want to track anything\n\tif (!options.createdAt && !options.createdBy && !options.updatedAt && !options.updatedBy) {\n\t\treturn;\n\t}\n\n\t// merge user options with default options\n\toptions = _.extend({}, defaultOptions, options);\n\n\t// validate option fields\n\t_.each(options, function(value, key) {\n\t\t\n\t\tvar fieldName;\n\t\t\n\t\t// make sure the key isn't already defined as a field\n\t\tif (_.has(list.fields, key)) {\n\t\t\tthrow new Error('Invalid List \"track\" option for ' + list.key + '\\n' +\n\t\t\t\t'\"' + key + '\" is already defined in the Schema.');\n\t\t}\n\n\t\t// make sure it's a valid track option field\n\t\tif (_.has(defaultOptions, key)) {\n\t\t\t\n\t\t\t// make sure the option field value is either a boolean or a string\n\t\t\tif (!_.isBoolean(value) && !_.isString(value)) {\n\t\t\t\tthrow new Error('Invalid List \"track\" option for ' + list.key + '\\n' +\n\t\t\t\t\t'\"' + key + '\" must be a boolean or a string.\\n\\n' +\n\t\t\t\t\t'See http://keystonejs.com/docs/database/#lists-options for more information.');\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\t// determine \n\t\t\t\tfieldName = value === true ? key : value;\n\t\t\t\toptions[key] = fieldName;\n\t\t\t\tlist.map(key, fieldName);\n\n\t\t\t\tswitch(key) {\n\t\t\t\t\tcase 'createdAt':\n\t\t\t\t\tcase 'updatedAt':\n\t\t\t\t\t\tfields[fieldName] = { type: Date, hidden: true, index: true };\n\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'createdBy':\n\t\t\t\t\tcase 'updatedBy':\n\t\t\t\t\t\tfields[fieldName] = { type: Types.Relationship, ref: userModel, hidden: true, index: true };\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Invalid List \"track\" option for ' + list.key + '\\n' +\n\t\t\t\t'valid field options are \"createdAt\", \"createdBy\", \"updatedAt\", an \"updatedBy\".\\n\\n' +\n\t\t\t\t'See http://keystonejs.com/docs/database/#lists-options for more information.');\t\t\t\t\n\t\t}\n\n\t});\n\n\t// add track fields to schema\n\tlist.add(fields);\n\t\n\tlist.tracking = options;\n\n\t// add the pre-save schema plugin\n\tlist.schema.pre('save', function (next) {\n\t\t\n\t\tvar now = new Date();\n\n\t\t// set createdAt/createdBy on new docs\n\t\tif (this.isNew) {\n\t\t\tif (options.createdAt && !this.get(options.createdAt)) {\n\t\t\t\tthis.set(options.createdAt, now);\n\t\t\t}\n\t\t\tif (options.createdBy && this._req_user && !this.get(options.createdBy)) {\n\t\t\t\tthis.set(options.createdBy, this._req_user._id);\n\t\t\t}\n\t\t}\n\n\t\t// set updatedAt/updatedBy when doc is modified\n\t\tif (this.isNew || this.isModified()) {\n\t\t\tif (options.updatedAt) {\n\t\t\t\tthis.set(options.updatedAt, now);\n\t\t\t}\n\t\t\tif (options.updatedBy && this._req_user) {\n\t\t\t\tthis.set(options.updatedBy, this._req_user._id);\n\t\t\t}\n\t\t}\n\n\t\tnext();\n\t\t\n\t});\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/schemaPlugins/history.js":"var keystone = require('../../');\n\nvar historyModelSuffix = '_revisions'; \n\nfunction getHistoryModelName (list) {\n\treturn list.options.schema.collection + historyModelSuffix;\n}\n\nfunction getHistoryModel(list, userModel) {\n\t\n\tvar collection = getHistoryModelName(list);\n\t\n\tvar schema = new keystone.mongoose.Schema({\n\t\ti: { type: keystone.mongoose.Schema.Types.ObjectId, ref: collection },\n\t\tt: { type: Date, index: true, required: true },\n\t\to: { type: String, index: true, required: true },\n\t\tc: { type: [String], index: true },\n\t\td: { type: keystone.mongoose.Schema.Types.Mixed, required: true }\n\t}, {\n\t\tid: true,\n\t\tversionKey: false\n\t});\n\t\n\tif (userModel) {\n\t\tschema.add({\n\t\t\tu: { type: keystone.mongoose.Schema.Types.ObjectId, ref: userModel }\n\t\t});\n\t}\n\t\n\treturn keystone.mongoose.model(collection, schema, collection);\n\t\n}\n\n/**\n * List history option\n *\n * When enabled, it tracks changes to each document on save or remove.\n */\n\nmodule.exports = function history() {\n\n\tvar list = this;\n\t\n\t//If model already exists for a '_revisions' in an inherited model, log a warning but skip creating the new model (inherited _revisions model will be used).\n\tvar collectionName = getHistoryModelName(list);\n\tif (list.get('inherits') &&\n\t\tcollectionName.indexOf(historyModelSuffix, collectionName.length - historyModelSuffix.length) !== -1 &&\n\t\tkeystone.mongoose.models[collectionName]) {\n\t\tconsole.log('List/model already exists for ' + collectionName + '.\\nWon\\'t re-create, keystone continuing.');\n\t\treturn;\n\t}\n\n\tvar userModel = keystone.get('user model');\n\t\n\tvar HistoryModel = list.HistoryModel = getHistoryModel(this, userModel);\n\t\n\tlist.schema.add({\n\t\t__rev: Number\n\t});\n\t\n\tlist.schema.pre('save', function(next) {\n\t\tthis.__rev = (typeof this.__rev === 'number') ? this.__rev + 1 : 1;\n\t\t\n\t\tvar data = this.toObject();\n\t\tdelete data._id;\n\t\tdelete data.__v;\n\t\tdelete data.__rev;\n\t\t\n\t\tvar doc = {\n\t\t\ti: this.id,\n\t\t\tt: Date.now(),\n\t\t\to: this.isNew ? 'c' : 'u',\n\t\t\tc: [],\n\t\t\td: data\n\t\t};\n\t\t\n\t\tfor (var path in list.fields) {\n\t\t\tif (this.isModified(path)) {\n\t\t\t\tdoc.c.push(path);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (list.autokey) {\n\t\t\tif (this.isModified(list.autokey.path)) {\n\t\t\t\tdoc.c.push(list.autokey.path);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (userModel && this._req_user) {\n\t\t\tdoc.u = this._req_user;\n\t\t}\n\t\t\n\t\tnew HistoryModel(doc).save(next);\n\t});\n\t\n\tlist.schema.pre('remove', function(next) {\n\t\tvar data = this.toObject();\n\t\tdata.__v = undefined;\n\t\t\n\t\tvar doc = {\n\t\t\tt: Date.now(),\n\t\t\to: 'd',\n\t\t\td: data\n\t\t};\n\t\t\n\t\tif (userModel && this._req_user) {\n\t\t\tdoc.u = this._req_user;\n\t\t}\n\t\t\n\t\tnew HistoryModel(doc).save(next);\n\t});\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/schemaPlugins/methods/getRelated.js":"var keystone = require('../../../');\nvar _ = require('underscore');\nvar async = require('async');\n\nmodule.exports = function getRelated(paths, callback, nocollapse) {\n\n\tvar item = this;\n\tvar list = this.list;\n\tvar queue = {};\n\n\tif ('function' !== typeof callback) {\n\t\tthrow new Error('List.getRelated(paths, callback, nocollapse) requires a callback function.');\n\t}\n\n\tif ('string' === typeof paths) {\n\t\tvar pathsArr = paths.split(' ');\n\t\tvar lastPath = '';\n\t\tpaths = [];\n\t\tfor (var i = 0; i < pathsArr.length; i++) {\n\t\t\tlastPath += (lastPath.length ? ' ' : '') + pathsArr[i];\n\t\t\tif (lastPath.indexOf('[') < 0 || lastPath.charAt(lastPath.length - 1) === ']') {\n\t\t\t\tpaths.push(lastPath);\n\t\t\t\tlastPath = '';\n\t\t\t}\n\t\t}\n\t}\n\n\t_.each(paths, function(options) {\n\n\t\tvar populateString = '';\n\n\t\tif ('string' === typeof options) {\n\t\t\tif (options.indexOf('[') > 0) {\n\t\t\t\tpopulateString = options.substring(options.indexOf('[') + 1, options.indexOf(']'));\n\t\t\t\toptions = options.substr(0, options.indexOf('['));\n\t\t\t}\n\t\t\toptions = { path: options };\n\t\t}\n\t\toptions.populate = options.populate || [];\n\t\toptions.related = options.related || [];\n\n\t\tvar relationship = list.relationships[options.path];\n\t\tif (!relationship) throw new Error('List.getRelated: list ' + list.key + ' does not have a relationship ' + options.path + '.');\n\n\t\tvar refList = keystone.list(relationship.ref);\n\t\tif (!refList) throw new Error('List.getRelated: list ' + relationship.ref + ' does not exist.');\n\n\t\tvar relField = refList.fields[relationship.refPath];\n\t\tif (!relField || relField.type !== 'relationship') throw new Error('List.getRelated: relationship ' + relationship.ref + ' on list ' + list.key + ' refers to a path (' + relationship.refPath + ') which is not a relationship field.');\n\n\t\tif (populateString.length) {\n\n\t\t\t_.each(populateString.split(' '), function(key) {\n\t\t\t\tif (refList.relationships[key]) {\n\t\t\t\t\toptions.related.push(key);\n\t\t\t\t} else {\n\t\t\t\t\toptions.populate.push(key);\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\n\t\tqueue[relationship.path] = function(done) {\n\n\t\t\tvar query = refList.model.find().where(relField.path);\n\n\t\t\tif (options.populate) {\n\t\t\t\tquery.populate(options.populate);\n\t\t\t}\n\n\t\t\tif (relField.many) {\n\t\t\t\tquery.in([item.id]);\n\t\t\t} else {\n\t\t\t\tquery.equals(item.id);\n\t\t\t}\n\n\t\t\tquery.sort(options.sort || relationship.sort || refList.defaultSort);\n\n\t\t\tif (options.related.length) {\n\t\t\t\tquery.exec(function(err, results) {\n\t\t\t\t\tif (err || !results.length) {\n\t\t\t\t\t\treturn done(err, results);\n\t\t\t\t\t}\n\t\t\t\t\tasync.parallel(results.map(function(item) {\n\t\t\t\t\t\t\treturn function(done) {\n\t\t\t\t\t\t\t\titem.populateRelated(options.related, done);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tfunction(err) {\n\t\t\t\t\t\t\tdone(err, results);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tquery.exec(done);\n\t\t\t}\n\n\t\t};\n\n\t\tif (!item._populatedRelationships) item._populatedRelationships = {};\n\t\titem._populatedRelationships[relationship.path] = true;\n\n\t});\n\n\tasync.parallel(queue, function(err, results) {\n\t\tif (!nocollapse && results && paths.length === 1) {\n\t\t\tresults = results[paths[0]];\n\t\t}\n\t\tcallback(err, results);\n\t});\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/schemaPlugins/methods/populateRelated.js":"var _ = require('underscore');\n\nmodule.exports = function populateRelated(rel, callback) {\n\n\tvar item = this;\n\n\tif ('function' !== typeof callback) {\n\t\tthrow new Error('List.populateRelated(rel, callback) requires a callback function.');\n\t}\n\n\tthis.getRelated(rel, function(err, results) {\n\t\t_.each(results, function(data, key) {\n\t\t\titem[key] = data;\n\t\t});\n\t\tcallback(err, results);\n\t}, true);\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/schemaPlugins/options/transform.js":"var _ = require('underscore');\n\nmodule.exports = function transform(doc, ret) {\n\tif (doc._populatedRelationships) {\n\t\t_.each(doc._populatedRelationships, function(on, key) {\n\t\t\tif (!on) return;\n\t\t\tret[key] = doc[key];\n\t\t});\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/set.js":"/**\n * Gets and Sets list options. Aliased as .get()\n *\n * Example:\n *     list.set('test') // returns the 'test' value\n *     list.set('test', value) // sets the 'test' option to `value`\n */\nfunction set(key, value) {\n\tif (arguments.length === 1) {\n\t\treturn this.options[key];\n\t}\n\tthis.options[key] = value;\n\treturn value;\n}\n\nmodule.exports = set;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/add.js":"var _ = require('underscore');\nvar utils = require('keystone-utils');\n\n/**\n * Adds one or more fields to the List\n * Based on Mongoose's Schema.add\n */\nfunction add () {\n\tvar add = function(obj, prefix) {\n\t\tprefix = prefix || '';\n\t\tvar keys = Object.keys(obj);\n\t\tfor (var i = 0; i < keys.length; ++i) {\n\t\t\tvar key = keys[i];\n\t\t\tif (!obj[key]) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Invalid value for schema path `' + prefix + key + '` in `' + this.key + '`.\\n' +\n\t\t\t\t\t'Did you misspell the field type?\\n'\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (utils.isObject(obj[key]) && (!obj[key].constructor || 'Object' === obj[key].constructor.name) && (!obj[key].type || obj[key].type.type)) {\n\t\t\t\tif (Object.keys(obj[key]).length) {\n\t\t\t\t\t// nested object, e.g. { last: { name: String }}\n\t\t\t\t\t// matches logic in mongoose/Schema:add\n\t\t\t\t\tthis.schema.nested[this.path] = true;\n\t\t\t\t\tadd(obj[key], prefix + key + '.');\n\t\t\t\t} else {\n\t\t\t\t\taddField(prefix + key, obj[key]); // mixed type field\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddField(prefix + key, obj[key]);\n\t\t\t}\n\t\t}\n\t}.bind(this);\n\n\tvar addField = function(path, options) {\n\t\tif (this.isReserved(path)) {\n\t\t\tthrow new Error('Path ' + path + ' on list ' + this.key + ' is a reserved path');\n\t\t}\n\t\tthis.uiElements.push({\n\t\t\ttype: 'field',\n\t\t\tfield: this.field(path, options)\n\t\t});\n\t}.bind(this);\n\n\t_.each(arguments, function(def) {\n\t\tthis.schemaFields.push(def);\n\t\tif ('string' === typeof def) {\n\t\t\tif (def === '>>>') {\n\t\t\t\tthis.uiElements.push({\n\t\t\t\t\ttype: 'indent'\n\t\t\t\t});\n\t\t\t} else if (def === '<<<') {\n\t\t\t\tthis.uiElements.push({\n\t\t\t\t\ttype: 'outdent'\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.uiElements.push({\n\t\t\t\t\ttype: 'heading',\n\t\t\t\t\theading: def,\n\t\t\t\t\toptions: {}\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (def.heading && 'string' === typeof def.heading) {\n\t\t\t\tthis.uiElements.push({\n\t\t\t\t\ttype: 'heading',\n\t\t\t\t\theading: def.heading,\n\t\t\t\t\toptions: def\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tadd(def);\n\t\t\t}\n\t\t}\n\t}, this);\n\n\treturn this;\n}\n\nmodule.exports = add;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/map.js":"/**\n * Maps a built-in field (e.g. name) to a specific path\n */\nfunction map (field, path) {\n\tif (path) {\n\t\tthis.mappings[field] = path;\n\t}\n\treturn this.mappings[field];\n}\n\nmodule.exports = map;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/automap.js":"/**\n * Checks to see if a field path matches a currently unmapped path, and\n * if so, adds a mapping for it.\n */\nfunction automap (field) {\n\tif ((field.path in this.mappings) && !this.mappings[field.path]) {\n\t\tthis.map(field.path, field.path);\n\t}\n\treturn this;\n}\n\nmodule.exports = automap;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/field.js":"var Field = require('../../fields/types/Type');\n\n/**\n * Creates a new field at the specified path, with the provided options.\n * If no options are provides, returns the field at the specified path.\n */\nfunction field (path, options) {\n\tif (arguments.length === 1) {\n\t\treturn this.fields[path];\n\t}\n\tif ('function' === typeof options) {\n\t\toptions = { type: options };\n\t}\n\tif (this.get('noedit')) {\n\t\toptions.noedit = true;\n\t}\n\tif (!options.note && this.get('notes')) {\n\t\toptions.note = this.get('notes')[path];\n\t}\n\tif ('function' !== typeof options.type) {\n\t\tthrow new Error('Fields must be specified with a type function');\n\t}\n\tif (options.type.prototype.__proto__ !== Field.prototype) {\n\t\t// Convert native field types to their default Keystone counterpart\n\t\tif (options.type === String) {\n\t\t\toptions.type = Field.Types.Text;\n\t\t} else if (options.type === Number) {\n\t\t\toptions.type = Field.Types.Number;\n\t\t} else if (options.type === Boolean) {\n\t\t\toptions.type = Field.Types.Boolean;\n\t\t} else if (options.type === Date) {\n\t\t\toptions.type = Field.Types.Datetime;\n\t\t} else {\n\t\t\tthrow new Error('Unrecognised field constructor: ' + options.type);\n\t\t}\n\t}\n\n\t// Note the presence of this field type for client-side script optimisation\n\tthis.fieldTypes[options.type.name] = true;\n\n\t// Wysiwyg HTML fields are handled as a special case so we can include TinyMCE as required\n\tif (options.type.name === 'html' && options.wysiwyg) {\n\t\tthis.fieldTypes.wysiwyg = true;\n\t}\n\n\tvar field = new options.type(this, path, options);\n\tthis.fields[path] = field;\n\treturn field;\n}\n\nmodule.exports = field;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/relationship.js":"var keystone = require('../../');\nvar utils = require('keystone-utils');\n\n/**\n * Registers relationships to this list defined on others\n */\nfunction relationship (def) {\n\tif (arguments.length > 1) {\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tthis.relationship(arguments[i]);\n\t\t}\n\t\treturn this;\n\t}\n\tif ('string' === typeof def) {\n\t\tdef = { ref: def };\n\t}\n\tif (!def.ref) {\n\t\tthrow new Error('List Relationships must be specified with an object containing ref (' + this.key + ')');\n\t}\n\tif (!def.refPath) {\n\t\tdef.refPath = utils.downcase(this.key);\n\t}\n\tif (!def.path) {\n\t\tdef.path = utils.keyToProperty(def.ref, true);\n\t}\n\tObject.defineProperty(def, 'refList', {\n\t\tget: function() {\n\t\t\treturn keystone.list(def.ref);\n\t\t}\n\t});\n\tObject.defineProperty(def, 'isValid', {\n\t\tget: function() {\n\t\t\treturn keystone.list(def.ref) ? true : false;\n\t\t}\n\t});\n\tthis.relationships[def.path] = def;\n\treturn this;\n}\n\nmodule.exports = relationship;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/underscoreMethod.js":"/**\n * Adds a method to the underscoreMethods collection on the list, which is then\n * added to the schema before the list is registered with mongoose.\n */\nfunction underscoreMethod (path, fn) {\n\tvar target = this.underscoreMethods;\n\tpath = path.split('.');\n\tvar last = path.pop();\n\tpath.forEach(function(part) {\n\t\tif (!target[part]) target[part] = {};\n\t\ttarget = target[part];\n\t});\n\ttarget[last] = fn;\n\treturn this;\n}\n\nmodule.exports = underscoreMethod;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/register.js":"var keystone = require('../../');\nvar schemaPlugins = require('../schemaPlugins');\nvar UpdateHandler = require('../updateHandler');\nvar utils = require('keystone-utils');\n\n/**\n * Registers the Schema with Mongoose, and the List with Keystone\n *\n * Also adds default fields and virtuals to the schema for the list\n */\nfunction register() {\n\tvar list = this;\n\tthis.schema.virtual('list').get(function () {\n\t\treturn list;\n\t});\n\tif (Object.keys(this.relationships).length) {\n\t\tthis.schema.methods.getRelated = schemaPlugins.methods.getRelated;\n\t\tthis.schema.methods.populateRelated = schemaPlugins.methods.populateRelated;\n\t\tif (!this.schema.options.toObject) this.schema.options.toObject = {};\n\t\tthis.schema.options.toObject.transform = schemaPlugins.options.transform;\n\t}\n\tthis.schema.virtual('_').get(function() {\n\t\tif (!this.__methods) {\n\t\t\tthis.__methods = utils.bindMethods(list.underscoreMethods, this);\n\t\t}\n\t\treturn this.__methods;\n\t});\n\tthis.schema.method('getUpdateHandler', function(req, res, ops) {\n\t\treturn new UpdateHandler(list, this, req, res, ops);\n\t});\n\tif (this.get('inherits')) {\n\t\tthis.model = this.get('inherits').model.discriminator(this.key, this.schema);\n\t} else {\n\t\tthis.model = keystone.mongoose.model(this.key, this.schema);\n\t}\n\tkeystone.list(this);\n\treturn this;\n}\n\nmodule.exports = register;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/updateHandler.js":"var _ = require('underscore');\nvar keystone = require('../');\n\n/**\n * UpdateHandler Class\n *\n * @param {Object} item to update\n * @api public\n */\n\nfunction UpdateHandler(list, item, req, res, options) {\n\n\tif (!(this instanceof UpdateHandler)) {\n\t\treturn new UpdateHandler(list, item);\n\t}\n\n\tthis.list = list;\n\tthis.item = item;\n\tthis.req = req;\n\tthis.res = res;\n\tthis.user = req.user;\n\tthis.options = options || {};\n\n\tif (!this.options.errorMessage) {\n\t\tthis.options.errorMessage = 'There was a problem saving your changes:';\n\t}\n\n\tif (this.options.user) {\n\t\tthis.user = this.options.user;\n\t}\n\n\tthis.validationMethods = {};\n\tthis.validationErrors = {};\n\n}\n\n\n/**\n * Adds a custom validation method for a given path\n *\n * @param {string} path to call method for\n * @param {function} method to call\n * @api public\n */\n\nUpdateHandler.prototype.validate = function(path, fn) {\n\tthis.validationMethods[path] = fn;\n\treturn this;\n};\n\n\n/**\n * Adds a validationError to the updateHandler; can be used before\n * `.process()` is called to handle errors generated by custom pre-\n * processing.\n *\n * @param {string} path that failed validation\n * @param {string} message to display\n * @param {string} error type (defaults to 'required')\n * @api public\n */\nUpdateHandler.ValidationErrorName = 'ValidatorError';\nUpdateHandler.prototype.addValidationError = function(path, msg, type) {\n\tthis.validationErrors[path] = {\n\t\tname: UpdateHandler.ValidationErrorName,\n\t\tpath: path,\n\t\tmessage: msg,\n\t\ttype: type || 'required'\n\t};\n\treturn this;\n};\n\n\n/**\n * Processes data from req.body, req.query, or any data source.\n *\n * Options:\n * - fields (comma-delimited list or array of field paths)\n * - flashErrors (boolean, default false; whether to push validation errors to req.flash)\n * - ignoreNoedit (boolean, default false; whether to ignore noedit settings on fields)\n * - validationErrors (object; validation errors from previous form handling that should be included)\n *\n * @param {Object} data\n * @param {Object} options (can be comma-delimited list of fields) (optional)\n * @param {Function} callback (optional)\n * @api public\n */\n\nUpdateHandler.prototype.process = function(data, options, callback) {\n\t\n\tvar usingDefaultFields = false;\n\t\n\tif ('function' === typeof options) {\n\t\tcallback = options;\n\t\toptions = null;\n\t}\n\n\tif ('function' !== typeof callback) {\n\t\tcallback = function() {};\n\t}\n\t\n\t// Initialise options\n\t\n\tif (!options) {\n\t\toptions = {};\n\t} else if ('string' === typeof options) {\n\t\toptions = { fields: options };\n\t}\n\t\n\tif (!options.fields) {\n\t\toptions.fields = _.keys(this.list.fields);\n\t\tusingDefaultFields = true;\n\t} else if ('string' === typeof options.fields) {\n\t\toptions.fields = options.fields.split(',').map(function(i) { return i.trim(); });\n\t}\n\t\n\toptions.required = options.required || {};\n\toptions.errorMessage = options.errorMessage || this.options.errorMessage;\n\toptions.invalidMessages = options.invalidMessages || {};\n\toptions.requiredMessages = options.requiredMessages || {};\n\t\n\t// Parse a string of required fields into field paths\n\tif ('string' === typeof options.required) {\n\t\tvar requiredFields = options.required.split(',').map(function(i) { return i.trim(); });\n\t\toptions.required = {};\n\t\trequiredFields.forEach(function(path) {\n\t\t\toptions.required[path] = true;\n\t\t});\n\t}\n\t\n\t// Make sure fields with the required option set are included in the required paths\n\toptions.fields.forEach(function(path) {\n\t\tvar field = (path instanceof keystone.Field) ? path : this.list.field(path);\n\t\tif (field && field.required) {\n\t\t\toptions.required[field.path] = true;\n\t\t}\n\t}, this);\n\t\n\t// TODO: The whole progress queue management code could be a lot neater...\n\tvar actionQueue = [],\n\t\taddValidationError = this.addValidationError.bind(this),\n\t\tvalidationErrors = this.validationErrors;\n\n\tvar progress = function(err) {\n\t\tif (err) {\n\t\t\tif (options.logErrors) {\n\t\t\t\tconsole.log('Error saving changes to ' + this.item.list.singular + ' ' + this.item.id + ':');\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t\tcallback(err, this.item, this);\n\t\t} else if (_.size(validationErrors)) {\n\t\t\tif (options.flashErrors) {\n\t\t\t\tthis.req.flash('error', {\n\t\t\t\t\ttype: UpdateHandler.ValidationErrorName,\n\t\t\t\t\ttitle: options.errorMessage,\n\t\t\t\t\tlist: _.pluck(validationErrors, 'message')\n\t\t\t\t});\n\t\t\t}\n\t\t\tcallback({\n\t\t\t\tmessage: 'Validation failed',\n\t\t\t\tname: UpdateHandler.ValidationErrorName,\n\t\t\t\terrors: validationErrors\n\t\t\t}, this.item, this);\n\t\t} else if (actionQueue.length) {\n\t\t\t// TODO: parallel queue handling for cloudinary uploads?\n\t\t\tactionQueue.pop()();\n\t\t} else {\n\t\t\tsaveItem();\n\t\t}\n\t}.bind(this);\n\t\n\tvar saveItem = function() {\n\t\t\n\t\t// Make current user available to pre/post save events\n\t\tthis.item._req_user = this.user;\n\t\t\n\t\tthis.item.save(function(err) {\n\t\t\tif (err) {\n\t\t\t\tif (err.name === UpdateHandler.ValidationErrorName) {\n\t\t\t\t\t// don't log simple validation errors\n\t\t\t\t\tif (options.flashErrors) {\n\t\t\t\t\t\tthis.req.flash('error', {\n\t\t\t\t\t\t\ttype: UpdateHandler.ValidationErrorName,\n\t\t\t\t\t\t\ttitle: options.errorMessage,\n\t\t\t\t\t\t\tlist: _.pluck(err.errors, 'message')\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (options.logErrors) {\n\t\t\t\t\t\tconsole.log('Error saving changes to ' + this.item.list.singular + ' ' + this.item.id + ':');\n\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t}\n\t\t\t\t\tif (options.flashErrors) {\n\t\t\t\t\t\tthis.req.flash('error', 'There was an error saving your changes: ' + err.message + ' (' + err.name + (err.type ? ': ' + err.type : '') + ')');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddValidationError(err.path, err.message, err.type);\n\n\t\t\t\terr = {\n\t\t\t\t\tmessage: 'Validation failed',\n\t\t\t\t\tname: UpdateHandler.ValidationErrorName,\n\t\t\t\t\terrors: validationErrors\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn callback(err, this.item, this);\n\t\t}.bind(this));\n\t}.bind(this);\n\t\n\toptions.fields.forEach(function(path) {\n\t\t\n\t\t// console.log('Processing field ' + path);\n\t\tvar message;\n\t\t\n\t\tvar field = (path instanceof keystone.Field) ? path : this.list.field(path),\n\t\t\tinvalidated = false;\n\t\t\n\t\tif (!field) {\n\t\t\tthrow new Error('UpdateHandler.process called with invalid field path: ' + path);\n\t\t}\n\t\t\n\t\t// skip uneditable fields\n\t\tif (usingDefaultFields && field.noedit && !options.ignoreNoedit) {\n\t\t\t// console.log('Skipping field ' + path + ' (noedit: true)');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Some field types have custom behaviours for queueing or validation\n\t\tswitch (field.type) {\n\t\t\t\n\t\t\tcase 'localfile':\n\t\t\tcase 'localfiles':\n\t\t\tcase 'cloudinaryimage':\n\t\t\tcase 'cloudinaryimages':\n\t\t\tcase 'azurefile':\n\t\t\tcase 's3file':\n\t\t\t\tactionQueue.push(field.getRequestHandler(this.item, this.req, options.paths, function(err) {\n\t\t\t\t\tif (err && options.flashErrors) {\n\t\t\t\t\t\tthis.req.flash('error', field.label + ' upload failed - ' + err.message);\n\t\t\t\t\t}\n\t\t\t\t\tprogress(err);\n\t\t\t\t}.bind(this)));\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 'location':\n\t\t\t\tactionQueue.push(field.getRequestHandler(this.item, this.req, options.paths, function(err) {\n\t\t\t\t\tif (err && options.flashErrors) {\n\t\t\t\t\t\tthis.req.flash('error', field.label + ' improve failed - ' + (err.status_text || err.status));\n\t\t\t\t\t}\n\t\t\t\t\tprogress(err);\n\t\t\t\t}.bind(this)));\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 'password':\n\t\t\t\t// passwords should only be set if a value is provided.\n\t\t\t\t// if no value is provided, as long as the field isn't required or empty, bail.\n\t\t\t\tif (!data[field.path] && (!options.required[field.path] || this.item.get(field.path))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// validate the password fields match, with a custom error message.\n\t\t\t\tif (data[field.path] !== data[field.paths.confirm]) {\n\t\t\t\t\tmessage = options.invalidMessages[field.path + '_match'] || 'Passwords must match';\n\t\t\t\t\taddValidationError(field.path, message);\n\t\t\t\t\tinvalidated = true;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t}\n\t\t\n\t\t// validate field input, unless it's already been invalidated by field-specific behaviour\n\t\tif (!invalidated && !field.validateInput(data)) {\n\t\t\t// console.log('Field ' + field.path + ' is invalid');\n\t\t\tmessage = options.invalidMessages[field.path] || field.options.invalidMessage || 'Please enter a valid ' + field.typeDescription + ' in the ' + field.label + ' field';\n\t\t\taddValidationError(field.path, message);\n\t\t\tinvalidated = true;\n\t\t}\n\t\t\n\t\t// validate required fields, unless they've already been invalidated by field-specific behaviour\n\t\tif (!invalidated && options.required[field.path] && !field.validateInput(data, true, this.item) && !validationErrors[field.path]) {\n\t\t\t// console.log('Field ' + field.path + ' is required, but not provided.');\n\t\t\tmessage = options.requiredMessages[field.path] || field.options.requiredMessage || field.label + ' is required';\n\t\t\taddValidationError(field.path, message);\n\t\t\tinvalidated = true;\n\t\t}\n\t\t\n\t\t// check for a custom validation rule at the path, and run it (unless the field is already invalid)\n\t\tif (!invalidated && this.validationMethods[field.path]) {\n\t\t\tmessage = this.validationMethods[field.path](data);\n\t\t\tif (message) {\n\t\t\t\taddValidationError(field.path, message);\n\t\t\t}\n\t\t\tinvalidated = true;\n\t\t}\n\t\t\n\t\tfield.updateItem(this.item, data);\n\t\t\n\t}, this);\n\n\tprogress();\n\t\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = UpdateHandler;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/getData.js":"var listToArray = require('list-to-array');\n\n/**\n * Gets the data from an Item ready to be serialised for client-side use, as\n * used by the React components\n */\n\nfunction getData (item, fields) {\n\tvar data = {\n\t\tid: item.id,\n\t\tname: this.getDocumentName(item)\n\t};\n\tif (this.autokey) {\n\t\tdata[this.autokey.path] = item.get(this.autokey.path);\n\t}\n\tif (fields === undefined) {\n\t\tfields = Object.keys(this.fields);\n\t}\n\tif (fields) {\n\t\tif (typeof fields === 'string') {\n\t\t\tfields = listToArray(fields);\n\t\t}\n\t\tif (!Array.isArray(fields)) {\n\t\t\tthrow new Error('List.getData: fields must be undefined, a string, or an array.');\n\t\t}\n\t\tdata.fields = {};\n\t\tfields.forEach(function (path) {\n\t\t\tvar field = this.fields[path];\n\t\t\tif (field) {\n\t\t\t\tdata.fields[path] = field.getData(item);\n\t\t\t} else {\n\t\t\t\tdata.fields[path] = item.get(path);\n\t\t\t}\n\t\t}, this);\n\t}\n\treturn data;\n}\n\nmodule.exports = getData;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/getOptions.js":"var _ = require('underscore');\n\n/**\n * Gets the options for the List, as used by the React components\n */\nfunction getOptions () {\n\tvar ops = {\n\t\tautocreate: this.options.autocreate,\n\t\tautokey: this.autokey,\n\t\tdefaultColumns: this.options.defaultColumns,\n\t\tdefaultSort: this.options.defaultSort,\n\t\tfields: {},\n\t\thidden: this.options.hidden,\n\t\tinitialFields: _.pluck(this.initialFields, 'path'),\n\t\tkey: this.key,\n\t\tlabel: this.label,\n\t\tnameField: this.nameField ? this.nameField.getOptions() : null,\n\t\tnameIsEditable: this.nameIsEditable,\n\t\tnameIsInitial: this.nameIsInitial,\n\t\tnameIsVirtual: this.nameIsVirtual,\n\t\tnamePath: this.namePath,\n\t\tnocreate: this.options.nocreate,\n\t\tnodelete: this.options.nodelete,\n\t\tnoedit: this.options.noedit,\n\t\tpath: this.path,\n\t\tplural: this.plural,\n\t\tsearchFields: this.options.searchFields,\n\t\tsingular: this.singular,\n\t\tsortable: this.options.sortable,\n\t\tsortContext: this.options.sortContext,\n\t\ttrack: this.options.track,\n\t\ttracking: this.tracking,\n\t\tuiElements: []\n\t};\n\t_.each(this.uiElements, function (el) {\n\t\tswitch (el.type) {\n\t\t\t// TODO: handle indentation\n\t\t\tcase 'field':\n\t\t\t\t// add the field options by path\n\t\t\t\tops.fields[el.field.path] = el.field.getOptions();\n\t\t\t\t// don't output the name field as a ui element if it's editable as it'll\n\t\t\t\t// appear as an input in the header\n\t\t\t\tif (el.field === this.nameField && this.nameIsEditable) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// don't output hidden fields\n\t\t\t\tif (el.field.hidden && el.field.type !== 'boolean') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// add the field to the elements array\n\t\t\t\tops.uiElements.push({\n\t\t\t\t\ttype: 'field',\n\t\t\t\t\tfield: el.field.path\n\t\t\t\t});\n\t\t\tbreak;\n\t\t\tcase 'heading':\n\t\t\t\tops.uiElements.push({\n\t\t\t\t\ttype: 'heading',\n\t\t\t\t\tcontent: el.heading,\n\t\t\t\t\toptions: el.options\n\t\t\t\t});\n\t\t\tbreak;\n\t\t}\n\t}, this);\n\treturn ops;\n}\n\nmodule.exports = getOptions;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/getAdminURL.js":"/**\n * Gets the Admin URL to view the list (or an item if provided)\n *\n * Example:\n *     var listURL = list.getAdminURL()\n *     var itemURL = list.getAdminURL(item)\n *\n * @param {Object} item\n */\nfunction getAdminURL(item) {\n\treturn '/keystone/' + this.path + (item ? '/' + item.id : '');\n}\n\nmodule.exports = getAdminURL;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/getDocumentName.js":"var utils = require('keystone-utils');\n\n/**\n * Gets the name of the provided document from the correct path\n *\n * Example:\n *     var name = list.getDocumentName(item)\n *\n * @param {Object} item\n * @param {Boolean} escape - causes HTML entities to be encoded\n */\nfunction getDocumentName(doc, escape) {\n\tvar name = String(this.nameField ? this.nameField.format(doc) : doc.get(this.namePath));\n\treturn (escape) ? utils.encodeHTMLEntities(name) : name;\n}\n\nmodule.exports = getDocumentName;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/addSearchToQuery.js":"var assign = require('object-assign');\nvar utils = require('keystone-utils');\n\nfunction trim(i) { return i.trim(); }\nfunction truthy(i) { return i; }\n\nfunction getNameFilter(field, searchString) {\n\tvar searchWords = searchString.split(' ').map(trim).filter(truthy).map(utils.escapeRegExp);\n\tvar nameSearchRegExp = new RegExp(searchWords.join('|'), 'i');\n\tvar first = {};\n\tfirst[field.paths.first] = nameSearchRegExp;\n\tvar last = {};\n\tlast[field.paths.last] = nameSearchRegExp;\n\treturn {\n\t\t$or: [first, last]\n\t};\n}\n\nfunction getStringFilter(path, searchRegExp) {\n\tvar filter = {};\n\tfilter[path] = searchRegExp;\n\treturn filter;\n}\n\nfunction addSearchToQuery (searchString, query) {\n\tsearchString = String(searchString || '').trim();\n\tquery = query || {};\n\tif (!searchString) return query;\n\n\tvar searchRegExp = new RegExp(utils.escapeRegExp(searchString), 'i');\n\tvar searchFilters = this.searchFields.map(function (i) {\n\t\tif (i.field && i.field.type === 'name') {\n\t\t\treturn getNameFilter(i.field, searchString);\n\t\t} else {\n\t\t\treturn getStringFilter(i.path, searchRegExp);\n\t\t}\n\t}, this);\n\n\tif (this.autokey) {\n\t\tvar autokeyFilter = {};\n\t\tautokeyFilter[this.autokey.path] = searchRegExp;\n\t\tsearchFilters.push(autokeyFilter);\n\t}\n\n\tif (utils.isValidObjectId(searchString)) {\n\t\tvar idFilter = {};\n\t\tidFilter._id = searchString;\n\t\tsearchFilters.push(idFilter);\n\t}\n\n\tif (searchFilters.length > 1) {\n\t\tquery.$or = searchFilters;\n\t} else if (searchFilters.length) {\n\t\tassign(query, searchFilters[0]);\n\t}\n\n\treturn query;\n}\n\nmodule.exports = addSearchToQuery;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/addFiltersToQuery.js":"function addFiltersToQuery (filters, query) {\n\tvar fields = Object.keys(this.fields);\n\tquery = query || {};\n\tfields.forEach(function (path) {\n\t\tvar field = this.fields[path];\n\t\tif (!field.addFilterToQuery || !filters[field.path]) return;\n\t\tfield.addFilterToQuery(filters[field.path], query);\n\t}, this);\n\treturn query;\n}\n\nmodule.exports = addFiltersToQuery;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/isReserved.js":"/**\n * Check whether or not a `path` is a reserved path. This restricts the use\n * of `Object.prototype` method keys as well as internal mongo paths.\n */\n\nvar reservedPaths = [\n\t'id',\n\t'_id',\n\t'_',\n\t'prototype',\n\t'__proto__',\n\t'hasOwnProperty',\n\t'toString',\n\t'__defineGetter__',\n\t'__defineSetter__',\n\t'__lookupGetter__',\n\t'__lookupSetter__',\n\t'isPrototypeOf',\n\t'propertyIsEnumerable',\n\t'toLocaleString',\n\t'valueOf'\n];\n\nfunction isReserved (path) {\n\treturn reservedPaths.indexOf(path) >= 0;\n}\n\nmodule.exports = isReserved;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/expandColumns.js":"var utils = require('keystone-utils');\n\n/**\n * Expands a comma-separated string or array of columns into valid column objects.\n *\n * Columns can be:\n *    - A Field, in the format \"field|width\"\n *    - A Field in a single related List, in the format \"list:field|width\"\n *    - Any valid path in the Schema, in the format \"path|width\"\n *\n * The width part is optional, and can be in the format \"n%\" or \"npx\".\n *\n * The path __name__ is automatically mapped to the namePath of the List.\n *\n * The field or path for the name of the item (defaults to ID if not set or detected)\n * is automatically prepended if not explicitly included.\n */\nfunction expandColumns(cols) {\n\tif (typeof cols === 'string') {\n\t\tcols = cols.split(',');\n\t}\n\tif (!Array.isArray(cols)) {\n\t\tthrow new Error('List.expandColumns: cols must be an array.');\n\t}\n\tvar list = this;\n\tvar expanded = [];\n\tvar nameCol = false;\n\tvar getCol = function(def) {\n\t\tif (def.path === '__name__') {\n\t\t\tdef.path = list.namePath;\n\t\t}\n\t\tvar field = list.fields[def.path];\n\t\tvar col = null;\n\t\tif (field) {\n\t\t\tcol = {\n\t\t\t\tfield: field,\n\t\t\t\tpath: field.path,\n\t\t\t\ttype: field.type,\n\t\t\t\tlabel: def.label || field.label\n\t\t\t};\n\t\t\tif (col.type === 'relationship') {\n\t\t\t\tcol.refList = col.field.refList;\n\t\t\t\tif (col.refList) {\n\t\t\t\t\tcol.refPath = def.subpath || col.refList.namePath;\n\t\t\t\t\tcol.subField = col.refList.fields[col.refPath];\n\t\t\t\t\tcol.populate = { path: col.field.path, subpath: col.refPath };\n\t\t\t\t}\n\t\t\t\tif (!def.label && def.subpath) {\n\t\t\t\t\tcol.label = field.label + ': ' + (col.subField ? col.subField.label : utils.keyToLabel(def.subpath));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (list.model.schema.paths[def.path] || list.model.schema.virtuals[def.path]) {\n\t\t\t// column refers to a path in the schema\n\t\t\t// TODO: this needs to handle sophisticated types, including arrays, nested Schemas, and mixed types\n\t\t\tcol = {\n\t\t\t\tpath: def.path,\n\t\t\t\tlabel: def.label || utils.keyToLabel(def.path)\n\t\t\t};\n\t\t}\n\t\tif (col) {\n\t\t\tcol.width = def.width;\n\t\t\tif (col.path === list.namePath) {\n\t\t\t\tcol.isName = true;\n\t\t\t\tnameCol = col;\n\t\t\t}\n\t\t\tif (field && field.col) {\n\t\t\t\t_.extend(col, field.col);\n\t\t\t}\n\t\t}\n\t\treturn col;\n\t};\n\tfor (var i = 0; i < cols.length; i++) {\n\t\tvar def = {};\n\t\tif (typeof cols[i] === 'string') {\n\t\t\tvar parts = cols[i].trim().split('|');\n\t\t\tdef.width = parts[1] || false;\n\t\t\tparts = parts[0].split(':');\n\t\t\tdef.path = parts[0];\n\t\t\tdef.subpath = parts[1];\n\t\t}\n\t\tif (!utils.isObject(def) || !def.path) {\n\t\t\tthrow new Error('List.expandColumns: column definition must contain a path.');\n\t\t}\n\t\tvar col = getCol(def);\n\t\tif (col) {\n\t\t\texpanded.push(col);\n\t\t}\n\t}\n\tif (!nameCol) {\n\t\tnameCol = getCol({ path: list.namePath });\n\t\tif (nameCol) {\n\t\t\texpanded.unshift(nameCol);\n\t\t}\n\t}\n\treturn expanded;\n}\n\nmodule.exports = expandColumns;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/expandPaths.js":"var listToArray = require('list-to-array');\n\nfunction expandPaths (paths) {\n\treturn listToArray(paths).map(function (path) {\n\t\tif (path === '__name__') {\n\t\t\tpath = this.mappings.name;\n\t\t}\n\t\treturn {\n\t\t\tpath: path,\n\t\t\tfield: this.fields[path]\n\t\t};\n\t}, this);\n}\n\nmodule.exports = expandPaths;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/selectColumns.js":"/**\n * Specified select and populate options for a query based the provided columns.\n *\n * @param {Query} query\n * @param {Array} columns\n */\nfunction selectColumns (q, cols) {\n\t// Populate relationship columns\n\tvar select = [];\n\tvar populate = {};\n\tvar path;\n\tcols.forEach(function(col) {\n\t\tselect.push(col.path);\n\t\tif (col.populate) {\n\t\t\tif (!populate[col.populate.path]) {\n\t\t\t\tpopulate[col.populate.path] = [];\n\t\t\t}\n\t\t\tpopulate[col.populate.path].push(col.populate.subpath);\n\t\t}\n\t});\n\tq.select(select.join(' '));\n\tfor (path in populate) {\n\t\tif (populate.hasOwnProperty(path)) {\n\t\t\tq.populate(path, populate[path].join(' '));\n\t\t}\n\t}\n}\n\nmodule.exports = selectColumns;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/processFilters.js":"var queryfilterlib = require('queryfilter');\n\n/**\n * Processes a filter string into a filters object\n *\n * NOTE: This function is deprecated in favor of List.prototype.addFiltersToQuery\n * and will be removed in a later version.\n *\n * @param {String} filters\n */\nfunction processFilters (q) {\n\tvar list = this;\n\tvar filters = {};\n\tqueryfilterlib.QueryFilters.create(q).getFilters().forEach(function(filter){\n\t\tfilter.path = filter.key; // alias for b/c\n\t\tfilter.field = list.fields[filter.key];\n\t\tfilters[filter.path] = filter;\n\t});\n\treturn filters;\n}\n\nmodule.exports = processFilters;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/getSearchFilters.js":"var _ = require('underscore');\nvar moment = require('moment');\nvar utils = require('keystone-utils');\n\n/**\n * Gets filters for a Mongoose query that will search for the provided string,\n * based on the searchFields List option.\n *\n * Also accepts a filters object from `processFilters()`, any of which may\n * override the search string.\n *\n * NOTE: This function is deprecated in favor of List.prototype.addSearchToQuery\n * and will be removed in a later version.\n *\n * Example:\n *     list.getSearchFilters('jed') // returns { name: /jed/i }\n *\n * @param {String} query\n * @param {Object} additional filters\n */\nfunction getSearchFilters (search, add) {\n\tvar filters = {};\n\tvar list = this;\n\n\tsearch = String(search || '').trim();\n\n\tif (search.length) {\n\t\tvar searchFilter;\n\t\tvar searchParts = search.split(' ');\n\t\tvar searchRx = new RegExp(utils.escapeRegExp(search), 'i');\n\t\tvar splitSearchRx = new RegExp((searchParts.length > 1) ? _.map(searchParts, utils.escapeRegExp).join('|') : search, 'i');\n\t\tvar searchFields = this.get('searchFields');\n\t\tvar searchFilters = [];\n\t\tvar searchIdField = utils.isValidObjectId(search);\n\n\t\tif ('string' === typeof searchFields) {\n\t\t\tsearchFields = searchFields.split(',');\n\t\t}\n\n\t\tsearchFields.forEach(function (path) {\n\t\t\tpath = path.trim();\n\n\t\t\tif (path === '__name__') {\n\t\t\t\tpath = list.mappings.name;\n\t\t\t}\n\n\t\t\tvar field = list.fields[path];\n\n\t\t\tif (field && field.type === 'name') {\n\t\t\t\tvar first = {};\n\t\t\t\tfirst[field.paths.first] = splitSearchRx;\n\t\t\t\tvar last = {};\n\t\t\t\tlast[field.paths.last] = splitSearchRx;\n\t\t\t\tsearchFilter = {};\n\t\t\t\tsearchFilter.$or = [first, last];\n\t\t\t\tsearchFilters.push(searchFilter);\n\t\t\t} else {\n\t\t\t\tsearchFilter = {};\n\t\t\t\tsearchFilter[path] = searchRx;\n\t\t\t\tsearchFilters.push(searchFilter);\n\t\t\t}\n\t\t});\n\n\t\tif (list.autokey) {\n\t\t\tsearchFilter = {};\n\t\t\tsearchFilter[list.autokey.path] = searchRx;\n\t\t\tsearchFilters.push(searchFilter);\n\t\t}\n\n\t\tif (searchIdField) {\n\t\t\tsearchFilter = {};\n\t\t\tsearchFilter._id = search;\n\t\t\tsearchFilters.push(searchFilter);\n\t\t}\n\n\t\tif (searchFilters.length > 1) {\n\t\t\tfilters.$or = searchFilters;\n\t\t} else if (searchFilters.length) {\n\t\t\tfilters = searchFilters[0];\n\t\t}\n\n\t}\n\n\tif (add) {\n\t\t_.each(add, function(filter) {\n\t\t\tvar cond;\n\t\t\tvar path = filter.key;\n\t\t\tvar value = filter.value;\n\n\t\t\tswitch (filter.field.type) {\n\t\t\t\tcase 'boolean':\n\t\t\t\t\tif (!value || value === 'false') {\n\t\t\t\t\t\tfilters[path] = { $ne: true };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfilters[path] = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'localfile':\n\t\t\t\tcase 'cloudinaryimage':\n\t\t\t\tcase 'cloudinaryimages':\n\t\t\t\tcase 's3file':\n\t\t\t\tcase 'name':\n\t\t\t\tcase 'password':\n\t\t\t\t\t// TODO\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'location':\n\t\t\t\t\t_.each(['street1', 'suburb', 'state', 'postcode', 'country'], function(pathKey, i) {\n\t\t\t\t\t\tvar value = filter.value[i];\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\tfilters[filter.field.paths[pathKey]] = new RegExp(utils.escapeRegExp(value), 'i');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'relationship':\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (filter.field.many) {\n\t\t\t\t\t\t\tfilters[path] = (filter.inverse) ? { $nin: [value] } : { $in: [value] };\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfilters[path] = (filter.inverse) ? { $ne: value } : value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (filter.field.many) {\n\t\t\t\t\t\t\tfilters[path] = (filter.inverse) ? { $not: { $size: 0 } } : { $size: 0 };\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfilters[path] = (filter.inverse) ? { $ne: null } : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'select':\n\t\t\t\t\tif (filter.value) {\n\t\t\t\t\t\tfilters[path] = (filter.inverse) ? { $ne: value } : value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfilters[path] = (filter.inverse) ? { $nin: ['', null] } : { $in: ['', null] };\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'money':\n\t\t\t\t\tif (filter.operator === 'bt') {\n\t\t\t\t\t\tvalue = [\n\t\t\t\t\t\t\tutils.number(value[0]),\n\t\t\t\t\t\t\tutils.number(value[1])\n\t\t\t\t\t\t];\n\t\t\t\t\t\tif ( !isNaN(value[0]) && !isNaN(value[1]) ) {\n\t\t\t\t\t\t\tfilters[path] = {\n\t\t\t\t\t\t\t\t$gte: value[0],\n\t\t\t\t\t\t\t\t$lte: value[1]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfilters[path] = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = utils.number(value);\n\t\t\t\t\t\tif ( !isNaN(value) ) {\n\t\t\t\t\t\t\tif (filter.operator === 'gt') {\n\t\t\t\t\t\t\t\tfilters[path] = { $gt: value };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (filter.operator === 'lt') {\n\t\t\t\t\t\t\t\tfilters[path] = { $lt: value };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfilters[path] = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfilters[path] = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase 'date':\n\t\t\t\tcase 'datetime':\n\t\t\t\t\tif (filter.operator === 'bt') {\n\t\t\t\t\t\tvalue = [\n\t\t\t\t\t\t\tmoment(value[0]),\n\t\t\t\t\t\t\tmoment(value[1])\n\t\t\t\t\t\t];\n\t\t\t\t\t\tif ( (value[0] && value[0].isValid()) && (value[1] && value[0].isValid()) ) {\n\t\t\t\t\t\t\tfilters[path] = {\n\t\t\t\t\t\t\t\t$gte: moment(value[0]).startOf('day').toDate(),\n\t\t\t\t\t\t\t\t$lte: moment(value[1]).endOf('day').toDate()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = moment(value);\n\t\t\t\t\t\tif (value && value.isValid()) {\n\t\t\t\t\t\t\tvar start = moment(value).startOf('day').toDate();\n\t\t\t\t\t\t\tvar end = moment(value).endOf('day').toDate();\n\t\t\t\t\t\t\tif (filter.operator === 'gt') {\n\t\t\t\t\t\t\t\tfilters[path] = { $gt: end };\n\t\t\t\t\t\t\t} else if (filter.operator === 'lt') {\n\t\t\t\t\t\t\t\tfilters[path] = { $lt: start };\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfilters[path] = { $lte: end, $gte: start };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'text':\n\t\t\t\tcase 'textarea':\n\t\t\t\tcase 'html':\n\t\t\t\tcase 'email':\n\t\t\t\tcase 'url':\n\t\t\t\tcase 'key':\n\t\t\t\t\tif (filter.exact) {\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\t// Don't use regex when searching for an exact match on a string value\n\t\t\t\t\t\t\t// Regex makes the search case-insensitive but prevents indexes from being used\n\t\t\t\t\t\t\tfilters[path] = filter.inverse ? { $not: value } : value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (filter.inverse) {\n\t\t\t\t\t\t\t\tfilters[path] = { $nin: ['', null] };\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfilters[path] = { $in: ['', null] };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (value) {\n\t\t\t\t\t\tcond = new RegExp(utils.escapeRegExp(value), 'i');\n\t\t\t\t\t\tfilters[path] = filter.inverse ? { $not: cond } : cond;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t});\n\t}\n\treturn filters;\n}\n\nmodule.exports = getSearchFilters;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/updateAll.js":"var async = require('async');\n\n/**\n * Updates every document in a List,\n * setting the provided data on each.\n *\n * @param {Object} data\n * @param {Function} callback (optional)\n */\nfunction updateAll (data, callback) {\n\tif ('function' === typeof data) {\n\t\tcallback = data;\n\t\tdata = null;\n\t}\n\tcallback = callback || function () {};\n\tthis.model.find(function (err, results) {\n\t\tif (err) return callback(err);\n\t\tasync.eachSeries(results, function (doc, next) {\n\t\t\tif (data) {\n\t\t\t\tdoc.set(data);\n\t\t\t}\n\t\t\tdoc.save(next);\n\t\t}, function (err) {\n\t\t\tcallback(err);\n\t\t});\n\t});\n}\n\nmodule.exports = updateAll;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/getUniqueValue.js":"/**\n * Gets a unique value from a generator method by checking for documents with the same value.\n *\n * To avoid infinite loops when a unique value cannot be found, it will bail and pass back an\n * undefined value after 10 attemptes.\n *\n * WARNING: Because there will always be a small amount of time between checking for an\n * existing value and saving a document, race conditions can occur and it is possible that\n * another document has the 'unique' value assigned at the same time.\n *\n * Because of this, if true uniqueness is required, you should also create a unique index on\n * the database path, and handle duplicate errors thrown on save.\n *\n * @param {String} path to check for uniqueness\n * @param {Function} generator method to call to generate a new value\n * @param {Number} the maximum number of attempts (optional, defaults to 10)\n * @param {Function} callback(err, uniqueValue)\n */\nfunction getUniqueValue (path, generator, limit, callback) {\n\tvar model = this.model;\n\tvar count = 0;\n\tvar value;\n\tif (typeof limit === 'function') {\n\t\tcallback = limit;\n\t\tlimit = 10;\n\t}\n\tif (Array.isArray(generator)) {\n\t\tvar fn = generator[0];\n\t\tvar args = generator.slice(1);\n\t\tgenerator = function () {\n\t\t\treturn fn.apply(this, args);\n\t\t};\n\t}\n\tvar check = function () {\n\t\tif (count++ > 10) {\n\t\t\treturn callback(undefined, undefined);\n\t\t}\n\t\tvalue = generator();\n\t\tmodel.count().where(path, value).exec(function (err, matches) {\n\t\t\tif (err) return callback(err);\n\t\t\tif (matches) return check();\n\t\t\tcallback(undefined, value);\n\t\t});\n\t};\n\tcheck();\n}\n\nmodule.exports = getUniqueValue;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/getPages.js":"/**\n * Generate page array for pagination\n *\n * @param {Number} the maximum number pages to display in the pagination\n * @param {Object} page options\n */\nfunction getPages (options, maxPages) {\n\tvar surround = Math.floor(maxPages / 2);\n\tvar firstPage = maxPages ? Math.max(1, options.currentPage - surround) : 1;\n\tvar padRight = Math.max(((options.currentPage - surround) - 1) * -1, 0);\n\tvar lastPage = maxPages ? Math.min(options.totalPages, options.currentPage + surround + padRight) : options.totalPages;\n\tvar padLeft = Math.max(((options.currentPage + surround) - lastPage), 0);\n\toptions.pages = [];\n\tfirstPage = Math.max(Math.min(firstPage, firstPage - padLeft), 1);\n\tfor (var i = firstPage; i <= lastPage; i++) {\n\t\toptions.pages.push(i);\n\t}\n\tif (firstPage !== 1) {\n\t\toptions.pages.shift();\n\t\toptions.pages.unshift('...');\n\t}\n\tif (lastPage !== Number(options.totalPages)) {\n\t\toptions.pages.pop();\n\t\toptions.pages.push('...');\n\t}\n}\n\nmodule.exports = getPages;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/list/paginate.js":"/**\n * Gets a special Query object that will paginate documents in the list\n *\n * Example:\n *     list.paginate({\n *         page: 1,\n *         perPage: 100,\n *         maxPages: 10\n *     }).exec(function(err, results) {\n *         // do something\n *     });\n *\n * @param {Object} options\n * @param {Function} callback (optional)\n */\nfunction paginate (options, callback) {\n\tvar list = this;\n\tvar model = this.model;\n\n\toptions = options || {};\n\n\tvar query = model.find(options.filters);\n\n\tquery._original_exec = query.exec;\n\tquery._original_sort = query.sort;\n\tquery._original_select = query.select;\n\n\tvar currentPage = Number(options.page) || 1;\n\tvar resultsPerPage = Number(options.perPage) || 50;\n\tvar maxPages = Number(options.maxPages) || 10;\n\tvar skip = (currentPage - 1) * resultsPerPage;\n\n\tlist.pagination = { maxPages: maxPages };\n\n\t// as of mongoose 3.7.x, we need to defer sorting and field selection\n\t// until after the count has been executed\n\n\tquery.select = function () {\n\t\toptions.select = arguments[0];\n\t\treturn query;\n\t};\n\n\tquery.sort = function () {\n\t\toptions.sort = arguments[0];\n\t\treturn query;\n\t};\n\n\tquery.exec = function (callback) {\n\t\tquery.count(function (err, count) {\n\t\t\tif (err) return callback(err);\n\n\t\t\tquery.find().limit(resultsPerPage).skip(skip);\n\n\t\t\t// apply the select and sort options before calling exec\n\t\t\tif (options.select) {\n\t\t\t\tquery._original_select(options.select);\n\t\t\t}\n\n\t\t\tif (options.sort) {\n\t\t\t\tquery._original_sort(options.sort);\n\t\t\t}\n\n\t\t\tquery._original_exec(function (err, results) {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tvar totalPages = Math.ceil(count / resultsPerPage);\n\t\t\t\tvar rtn = {\n\t\t\t\t\ttotal: count,\n\t\t\t\t\tresults: results,\n\t\t\t\t\tcurrentPage: currentPage,\n\t\t\t\t\ttotalPages: totalPages,\n\t\t\t\t\tpages: [],\n\t\t\t\t\tprevious: (currentPage > 1) ? (currentPage - 1) : false,\n\t\t\t\t\tnext: (currentPage < totalPages) ? (currentPage + 1) : false,\n\t\t\t\t\tfirst: skip + 1,\n\t\t\t\t\tlast: skip + results.length\n\t\t\t\t};\n\t\t\t\tlist.getPages(rtn, maxPages);\n\t\t\t\tcallback(err, rtn);\n\t\t\t});\n\t\t});\n\n\t};\n\n\tif (callback) {\n\t\treturn query(callback);\n\t} else {\n\t\treturn query;\n\t}\n}\n\nmodule.exports = paginate;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/view.js":"/*!\n * Module dependencies.\n */\n\nvar _ = require('underscore');\nvar async = require('async');\nvar keystone = require('../');\nvar utils = require('keystone-utils');\n\n/**\n * View Constructor\n * =================\n *\n * Helper to simplify view logic in a Keystone application\n *\n * @api public\n */\n\nfunction View(req, res) {\n\n\tif (!req || req.constructor.name !== 'IncomingMessage') {\n\t\tthrow new Error('Keystone.View Error: Express request object is required.');\n\t}\n\n\tif (!res || res.constructor.name !== 'ServerResponse') {\n\t\tthrow new Error('Keystone.View Error: Express response object is required.');\n\t}\n\n\tthis.req = req;\n\tthis.res = res;\n\n\tthis.initQueue = [];\t// executed first in series\n\tthis.actionQueue = [];\t// executed second in parallel, if optional conditions are met\n\tthis.queryQueue = [];\t// executed third in parallel\n\tthis.renderQueue = [];\t// executed fourth in parallel\n\n}\n\nmodule.exports = exports = View;\n\n\n/**\n * Adds a method (or array of methods) to be executed in parallel\n * to the `init`, `action` or `render` queue.\n *\n * @api public\n */\n\nView.prototype.on = function(on) {\n\t\n\tvar req = this.req;\n\tvar callback = arguments[1];\n\tvar values;\n\t\n\tif ('function' === typeof on) {\n\t\t\n\t\t/* If the first argument is a function that returns truthy then add the second\n\t\t * argument to the action queue\n\t\t * \n\t\t * Example:\n\t\t * \n\t\t *     view.on(function() {\n\t\t *             var thing = true;\n\t\t *             return thing;\n\t\t *         },\n\t\t *         function(next) {\n\t\t *             console.log('thing is true!');\n\t\t *             next();\n\t\t *         }\n\t\t *     );\n\t\t */\n\t\t\n\t\tif (on()) {\n\t\t\tthis.actionQueue.push(callback);\n\t\t}\n\n\t} else if (utils.isObject(on)) {\n\t\t\n\t\t/* Do certain actions depending on information in the response object.\n\t\t * \n\t\t * Example:\n\t\t * \n\t\t *     view.on({ 'user.name.first': 'Admin' }, function(next) {\n\t\t *         console.log('Hello Admin!');\n\t\t *         next();\n\t\t *     });\n\t\t */\n\t\t\n\t\tvar check = function(value, path) {\n\n\t\t\tvar ctx = req;\n\t\t\tvar parts = path.split('.');\n\n\t\t\tfor (var i = 0; i < parts.length - 1; i++) {\n\t\t\t\tif (!ctx[parts[i]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tctx = ctx[parts[i]];\n\t\t\t}\n\t\t\t\n\t\t\tpath = _.last(parts);\n\t\t\t\n\t\t\treturn (value === true && path in ctx) ? true : (ctx[path] === value);\n\n\t\t};\n\n\t\tif (_.every(on, check)) {\n\t\t\tthis.actionQueue.push(callback);\n\t\t}\n\t\t\n\t} else if (on === 'get' || on === 'post' || on === 'put' || on === 'delete') {\n\t\t\n\t\t/* Handle HTTP verbs\n\t\t * \n\t\t * Example:\n\t\t *     view.on('get', function(next) {\n\t\t *         console.log('GOT!');\n\t\t *         next();\n\t\t *     });\n\t\t */\n\t\t\n\t\tif (req.method !== on.toUpperCase()) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (arguments.length === 3) {\n\t\t\t\n\t\t\t/* on a POST and PUT requests search the req.body for a matching value\n\t\t\t * on every other request search the query.\n\t\t\t * \n\t\t\t * Example:\n\t\t\t *     view.on('post', { action: 'theAction' }, function(next) {\n\t\t\t *         // respond to the action\n\t\t\t *         next();\n\t\t\t *     });\n\t\t\t *     \n\t\t\t * Example:\n\t\t\t *     view.on('get', { page: 2 }, function(next) {\n\t\t\t *         // do something specifically on ?page=2\n\t\t\t *         next();\n\t\t\t *     });\n\t\t\t */\n\t\t\t\n\t\t\tif (utils.isString(arguments[1])) {\n\t\t\t\tvalues = {};\n\t\t\t\tvalues[arguments[1]] = true;\n\t\t\t} else {\n\t\t\t\tvalues = arguments[1];\n\t\t\t}\n\t\t\t\n\t\t\tcallback = arguments[2];\n\t\t\t\n\t\t\tvar ctx = (on === 'post' || on === 'put') ? req.body : req.query;\n\t\t\t\n\t\t\tif (_.every(values || {}, function(value, path) {\n\t\t\t\treturn (value === true && path in ctx) ? true : (ctx[path] === value);\n\t\t\t})) {\n\t\t\t\tthis.actionQueue.push(callback);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tthis.actionQueue.push(callback);\n\t\t}\n\n\t} else if (on === 'init') {\n\t\t\n\t\t/* Init events are always fired in series, before any other actions\n\t\t * \n\t\t * Example:\n\t\t *     view.on('init', function (next) {\n\t\t *         // do something before any actions or queries have run\n\t\t *     });\n\t\t */\n\t\t\n\t\tthis.initQueue.push(callback);\n\t\t\n\t} else if (on === 'render') {\n\t\t\n\t\t/* Render events are always fired last in parallel, after any other actions\n\t\t *  \n\t\t * Example:\n\t\t *     view.on('render', function (next) {\n\t\t *         // do something after init, action and query middleware has run\n\t\t *     });\n\t\t */\n\t\t\n\t\tthis.renderQueue.push(callback);\n\t\t\n\t}\n\n\treturn this;\n\t\n};\n\nvar QueryCallbacks = function(options) {\n\tif (utils.isString(options)) {\n\t\toptions = { then: options };\n\t} else {\n\t\toptions = options || {};\n\t}\n\tthis.callbacks = {};\n\tif (options.err) this.callbacks.err = options.err;\n\tif (options.none) this.callbacks.none = options.none;\n\tif (options.then) this.callbacks.then = options.then;\n\treturn this;\n};\n\nQueryCallbacks.prototype.has = function(fn) { return (fn in this.callbacks); };\nQueryCallbacks.prototype.err = function(fn) { this.callbacks.err = fn; return this; };\nQueryCallbacks.prototype.none = function(fn) { this.callbacks.none = fn; return this; };\nQueryCallbacks.prototype.then = function(fn) { this.callbacks.then = fn; return this; };\n\n\n/**\n * Queues a mongoose query for execution before the view is rendered.\n * The results of the query are set in `locals[key]`.\n *\n * Keys can be nested paths, containing objects will be created as required.\n *\n * The third argument `then` can be a method to call after the query is completed\n * like function(err, results, callback), or a `populatedRelated` definition\n * (string or array).\n * \n * Examples:\n * \n * view.query('books', keystone.list('Book').model.find());\n * \n *     an array of books from the database will be added to locals.books. You can\n *     also nest properties on the locals variable.\n * \n * view.query(\n *     'admin.books',\n *      keystone.list('Book').model.find().where('user', 'Admin')\n * );\n * \n *     locals.admin.books will be the result of the query\n *     views.query().then is always called if it is available\n * \n * view.query('books', keystone.list('Book').model.find())\n *     .then(function (err, results, next) {\n *         if (err) return next(err);\n *         console.log(results);\n *         next();\n *     });\n *\n * @api public\n */\n\nView.prototype.query = function(key, query, options) {\n\n\tvar locals = this.res.locals;\n\tvar parts = key.split('.');\n\tvar chain = new QueryCallbacks(options);\n\n    key = parts.pop();\n\n\tfor (var i = 0; i < parts.length; i++) {\n\t\tif (!locals[parts[i]]) {\n\t\t\tlocals[parts[i]] = {};\n\t\t}\n\t\tlocals = locals[parts[i]];\n\t}\n\n\tthis.queryQueue.push(function(next) {\n\t\tquery.exec(function(err, results) {\n\n\t\t\tlocals[key] = results;\n\t\t\tvar callbacks = chain.callbacks;\n\n\t\t\tif (err) {\n\t\t\t\tif ('err' in callbacks) {\n\t\t\t\t\t/* Will pass errors into the err callback\n\t\t\t\t\t * \n\t\t\t\t\t * Example:\n\t\t\t\t\t *     view.query('books', keystone.list('Book'))\n\t\t\t\t\t *         .err(function (err, next) {\n\t\t\t\t\t *             console.log('ERROR: ', err);\n\t\t\t\t\t *             next();\n\t\t\t\t\t *         });\n\t\t\t\t\t */\n\t\t\t\t\treturn callbacks.err(err, next);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((!results || (utils.isArray(results) && !results.length)) && 'none' in callbacks) {\n\t\t\t\t\t/* If there are no results view.query().none will be called\n\t\t\t\t\t * \n\t\t\t\t\t * Example:\n\t\t\t\t\t *     view.query('books', keystone.list('Book').model.find())\n\t\t\t\t\t *         .none(function (next) {\n\t\t\t\t\t *             console.log('no results');\n\t\t\t\t\t *             next();\n\t\t\t\t\t *         });\n\t\t\t\t\t */\n\t\t\t\t\treturn callbacks.none(next);\n\t\t\t\t} else if ('then' in callbacks) {\n\t\t\t\t\tif (utils.isFunction(callbacks.then)) {\n\t\t\t\t\t\treturn callbacks.then(err, results, next);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn keystone.populateRelated(results, callbacks.then, next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn next(err);\n\n\t\t});\n\t});\n\n\treturn chain;\n};\n\n\n/**\n * Executes the current queue of init and action methods in series, and\n * then executes the render function. If renderFn is a string, it is provided\n * to `res.render`.\n *\n * It is expected that *most* init stacks require processing in series,\n * but it is safe to execute actions in parallel.\n *\n * If there are several init methods that should be run in parallel, queue\n * them as an array, e.g. `view.on('init', [first, second])`.\n *\n * @api public\n */\nView.prototype.render = function(renderFn, locals, callback) {\n\n\tvar req = this.req;\n\tvar res = this.res;\n\n\tif ('string' === typeof renderFn) {\n\t\tvar viewPath = renderFn;\n\t\trenderFn = function() {\n\t\t\tif ('function' === typeof locals) {\n\t\t\t\tlocals = locals();\n\t\t\t}\n\t\t\tthis.res.render(viewPath, locals, callback);\n\t\t}.bind(this);\n\t}\n\n\tif ('function' !== typeof renderFn) {\n\t\tthrow new Error('Keystone.View.render() renderFn must be a templatePath (string) or a function.');\n\t}\n\n\t// Add actions, queries & renderQueue to the end of the initQueue\n\tthis.initQueue.push(this.actionQueue);\n\tthis.initQueue.push(this.queryQueue);\n\n\tvar preRenderQueue = [];\n\n\t// Add Keystone's global pre('render') queue\n\tkeystone.getMiddleware('pre:render').forEach( function(fn) {\n\t\tpreRenderQueue.push(function(next) {\n\t\t\tfn(req, res, next);\n\t\t});\n\t});\n\n\tthis.initQueue.push(preRenderQueue);\n\tthis.initQueue.push(this.renderQueue);\n\n\tasync.eachSeries(this.initQueue, function(i, next) {\n\t\tif (Array.isArray(i)) {\n\t\t\t// process nested arrays in parallel\n\t\t\tasync.parallel(i, next);\n\t\t} else if ('function' === typeof i) {\n\t\t\t// process single methods in series\n\t\t\ti(next);\n\t\t} else {\n\t\t\tthrow new Error('Keystone.View.render() events must be functions.');\n\t\t}\n\t}, function(err) {\n\t\trenderFn(err, req, res);\n\t});\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/content/index.js":"var _ = require('underscore'),\n\tkeystone = require('../../'),\n\tutils = keystone.utils;\n\n/**\n * Content Class\n *\n * Accessed via `Keystone.content`\n *\n * @api public\n */\n\nvar Content = function() {};\n\n/**\n * Loads page content by page key (optional).\n *\n * If page key is not provided, returns a hash of all page contents in the database.\n *\n * ####Example:\n *\n *     keystone.content.fetch('home', function(err, content) { ... });\n *\n * @param {String} key (optional)\n * @param {Function} callback\n * @api public\n */\n\nContent.prototype.fetch = function(page, callback) {\n\n\tif (utils.isFunction(page)) {\n\t\tcallback = page;\n\t\tpage = null;\n\t}\n\n\tvar content = this;\n\n\tif (!this.AppContent) {\n\t\treturn callback({ error: 'invalid page', message: 'No pages have been registered.' });\n\t}\n\n\tif (page) {\n\n\t\tif (!this.pages[page]) {\n\t\t\treturn callback({ error: 'invalid page', message: 'The page ' + page + ' does not exist.' });\n\t\t}\n\n\t\tthis.AppContent.findOne({ key: page }, function(err, result) {\n\n\t\t\tif (err) return callback(err);\n\n\t\t\treturn callback(null, content.pages[page].populate(result ? result.content.data : {}));\n\n\t\t});\n\n\t} else {\n\n\t\tthis.AppContent.find(function(err, results) {\n\n\t\t\tif (err) return callback(err);\n\n\t\t\tvar data = {};\n\n\t\t\tresults.forEach(function(i) {\n\t\t\t\tif (content.pages[i.key]) {\n\t\t\t\t\tdata[i.key] = content.pages[i.key].populate(i.content.data);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t_.each(content.pages, function(i) {\n\t\t\t\tif (!data[i.key]) {\n\t\t\t\t\tdata[i.key] = i.populate();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn data;\n\n\t\t});\n\n\t}\n\n};\n\n/**\n * Sets page content by page key.\n *\n * Merges content with existing content.\n *\n * ####Example:\n *\n *     keystone.content.store('home', { title: 'Welcome' }, function(err) { ... });\n *\n * @param {String} key\n * @param {Object} content\n * @param {Function} callback\n * @api public\n */\n\nContent.prototype.store = function(page, content, callback) {\n\n\tif (!this.pages[page]) {\n\t\treturn callback({ error: 'invalid page', message: 'The page ' + page + ' does not exist.' });\n\t}\n\n\tcontent = this.pages[page].validate(content);\n\n\t// TODO: Handle validation errors\n\n\tthis.AppContent.findOne({ key: page }, function(err, doc) {\n\n\t\tif (err) return callback(err);\n\n\t\tif (doc) {\n\t\t\tif (doc.content) {\n\t\t\t\tdoc.history.push(doc.content);\n\t\t\t}\n\t\t\t_.defaults(content, doc.content);\n\t\t} else {\n\t\t\tdoc = new content.AppContent({ key: page });\n\t\t}\n\n\t\tdoc.content = { data: this.pages[page].clean(content) };\n\t\tdoc.lastChangeDate = Date.now();\n\n\t\tdoc.save(callback);\n\n\t});\n\n};\n\n/**\n * Registers a page. Should not be called directly, use Page.register() instead.\n *\n * @param {Page} page\n * @api private\n */\n\nContent.prototype.page = function(key, page) {\n\n\tif (!this.pages) {\n\t\tthis.pages = {};\n\t}\n\n\tif (arguments.length === 1) {\n\n\t\tif (!this.pages[key]) {\n\t\t\tthrow new Error('keystone.content.page() Error: page ' + key + ' cannot be registered more than once.');\n\t\t}\n\n\t\treturn this.pages[key];\n\n\t}\n\n\tthis.initModel();\n\n\tif (this.pages[key]) {\n\t\tthrow new Error('keystone.content.page() Error: page ' + key + ' cannot be registered more than once.');\n\t}\n\n\tthis.pages[key] = page;\n\n\treturn page;\n\n};\n\n/**\n * Ensures the Mongoose model for storing content is initialised.\n *\n * Called automatically when pages are added.\n *\n * @api private\n */\n\nContent.prototype.initModel = function() {\n\n\tif (this.AppContent) return;\n\n\tvar contentSchemaDef = {\n\t\tcreatedAt: { type: Date, default: Date.now },\n\t\tdata: { type: keystone.mongoose.Schema.Types.Mixed }\n\t};\n\n\tvar ContentSchema = new keystone.mongoose.Schema(contentSchemaDef);\n\n\tvar PageSchema = new keystone.mongoose.Schema({\n\t\tpage: { type: String, index: true },\n\t\tlastChangeDate: { type: Date, index: true },\n\t\tcontent: contentSchemaDef,\n\t\thistory: [ContentSchema]\n\t}, { collection: 'app_content' });\n\n\tthis.AppContent = keystone.mongoose.model('App_Content', PageSchema);\n\n};\n\n/**\n * Outputs client-side editable data for content management\n *\n * Called automatically when pages are added.\n *\n * @api private\n */\n\nContent.prototype.editable = function(user, options) {\n\n\tif (!user || !user.canAccessKeystone) {\n\t\treturn undefined;\n\t}\n\n\tif (options.list) {\n\n\t\tvar list = keystone.list(options.list);\n\n\t\tif (!list) {\n\t\t\treturn JSON.stringify({ type: 'error', err: 'list not found' });\n\t\t}\n\n\t\tvar data = {\n\t\t\ttype: 'list',\n\t\t\tpath: list.path,\n\t\t\tsingular: list.singular,\n\t\t\tplural: list.plural\n\t\t};\n\n\t\tif (options.id) {\n\t\t\tdata.id = options.id;\n\t\t}\n\n\t\treturn JSON.stringify(data);\n\n\t}\n\n};\n\n\n/**\n * The exports object is an instance of Content.\n *\n * @api public\n */\n\nmodule.exports = exports = new Content();\n\n// Expose Classes\nexports.Page = require('./page');\nexports.Types = require('./types');\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/content/page.js":"var _ = require('underscore'),\n\tkeystone = require('../../'),\n\tutils = keystone.utils,\n\tType = require('./type');\n\n/**\n * Page Class\n *\n * @param {String} key\n * @param {Object} options\n * @api public\n */\n\nfunction Page(key, options) {\n\t\n\tif (!(this instanceof Page)) {\n\t\treturn new Page(key, options);\n\t}\n\t\n\tthis.options = utils.options({\n\t\t// ...\n\t}, options);\n\t\n\tthis.key = key;\n\tthis.fields = {};\n\t\n}\n\nObject.defineProperty(Page.prototype, 'name', {\n\tget: function() {\n\t\treturn this.get('name') || this.set('name', utils.keyToLabel(this.key));\n\t}\n});\n\n/**\n * Sets page options\n *\n * ####Example:\n *\n *     page.set('test', value) // sets the 'test' option to `value`\n *\n * @param {String} key\n * @param {String} value\n * @api public\n */\n\nPage.prototype.set = function(key, value) {\n\t\n\tif (arguments.length === 1) {\n\t\treturn this.options[key];\n\t}\n\t\n\tthis.options[key] = value;\n\treturn value;\n\t\n};\n\n\n/**\n * Gets page options\n *\n * ####Example:\n *\n *     page.get('test') // returns the 'test' value\n *\n * @param {String} key\n * @method get\n * @api public\n */\n\nPage.prototype.get = Page.prototype.set;\n\n/**\n * Adds one or more fields to the page\n * \n * @api public\n */\n\nPage.prototype.add = function(fields) {\n\t\n\t// TODO: nested paths\n\tif (!utils.isObject(fields)) {\n\t\tthrow new Error('keystone.content.Page.add() Error: fields must be an object.');\n\t}\n\t\n\t_.each(fields, function(options, path) {\n\t\t\n\t\tif ('function' === typeof options) {\n\t\t\toptions = { type: options };\n\t\t}\n\t\t\n\t\tif ('function' !== typeof options.type) {\n\t\t\tthrow new Error('Page fields must be specified with a type function');\n\t\t}\n\t\t\n\t\tif (options.type.prototype.__proto__ !== Type.prototype) {\n\t\t\t\n\t\t\t// Convert native field types to their default Keystone counterpart\n\t\t\t\n\t\t\tif (options.type === String) {\n\t\t\t\toptions.type = keystone.content.Types.Text;\n\t\t\t}\n\t\t\t\n\t\t\t// TODO: More types\n\t\t\t// else if (options.type == Number)\n\t\t\t// \toptions.type = Field.Types.Number;\n\t\t\t// else if (options.type == Boolean)\n\t\t\t// \toptions.type = Field.Types.Boolean;\n\t\t\t// else if (options.type == Date)\n\t\t\t// \toptions.type = Field.Types.Datetime;\n\t\t\t\n\t\t\telse {\n\t\t\t\tthrow new Error('Unrecognised field constructor: ' + options.type);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tthis.fields[path] = new options.type(path, options);\n\t\t\n\t}, this);\n\t\n\treturn this;\n\t\n};\n\n/**\n * Registers the page with Keystone.\n * \n * ####Example:\n * \t\t\n * \t\tvar homePage = new keystone.content.Page('home');\n * \t\t// ...\n * \t\thomePage.register();\n * \t\t\n * \t\t// later...\n * \t\tvar homePage = keystone.content.page('home');\n * \n * @api public\n */\n\nPage.prototype.register = function() {\n\treturn keystone.content.page(this.key, this);\n};\n\n/**\n * Populates a data structure based on defined fields\n * \n * @api public\n */\n\nPage.prototype.populate = function(data) {\n\t\n\tif (!utils.isObject(data)) {\n\t\tdata = {};\n\t}\n\t\n\t// TODO: implement schema\n\t\n\treturn data;\n\t\n};\n\n/**\n * Validates a data structure based on defined fields\n * \n * @api public\n */\n\nPage.prototype.validate = function(data) {\n\t\n\tif (!_.isObject(data)) {\n\t\tdata = {};\n\t}\n\t\n\t// TODO: implement schema\n\t\n\treturn data;\n\t\n};\n\n/**\n * Cleans a data structure so only the defined fields are present\n * \n * @api public\n */\n\nPage.prototype.clean = function(data) {\n\t\n\tif (!_.isObject(data)) {\n\t\tdata = {};\n\t}\n\t\n\t// TODO: implement schema\n\t\n\treturn data;\n\t\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = Page;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/content/type.js":"/**\n * Type Class\n * @api private\n */\n\nvar Type = function(path, options) { //eslint-disable-line no-unused-vars\n\t// TODO\n};\n\n\n/*!\n * Export class\n */\n\nmodule.exports = exports = Type;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/content/types/index.js":"exports.Text = require('./text');\nexports.Html = require('./html');\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/content/types/text.js":"/*!\n * Module dependencies.\n */\n\nvar util = require('util'),\n\tsuper_ = require('../type');\n\n/**\n * Text ContentType Constructor\n * @extends Field\n * @api public\n */\n\nfunction text(path, options) {\n\ttext.super_.call(path, options);\n}\n\n/*!\n * Inherit from Type\n */\n\nutil.inherits(text, super_);\n\n\n/*!\n * Export class\n */\n\nmodule.exports = exports = text;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/content/types/html.js":"/*!\n * Module dependencies.\n */\n\nvar util = require('util'),\n\tsuper_ = require('../type');\n\n/**\n * HTML ContentType Constructor\n * @extends Field\n * @api public\n */\n\nfunction html(path, options) {\n\thtml.super_.call(path, options);\n}\n\n/*!\n * Inherit from Type\n */\n\nutil.inherits(html, super_);\n\n\n/*!\n * Export class\n */\n\nmodule.exports = exports = html;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/security/csrf.js":"var crypto = require('crypto');\nvar scmp = require('scmp');\nvar utils = require('keystone-utils');\n\nexports.TOKEN_KEY = '_csrf';\nexports.LOCAL_KEY = 'csrf_token_key';\nexports.LOCAL_VALUE = 'csrf_token_value';\nexports.SECRET_KEY = exports.TOKEN_KEY + '_secret';\nexports.SECRET_LENGTH = 10;\nexports.CSRF_HEADER_KEY = 'x-csrf-token';\nexports.XSRF_HEADER_KEY = 'x-xsrf-token';\nexports.XSRF_COOKIE_KEY = 'XSRF-TOKEN';\n\nfunction tokenize(salt, secret) {\n\treturn salt + crypto.createHash('sha1').update(salt + secret).digest('base64');\n}\n\nexports.createSecret = function() {\n\treturn crypto.pseudoRandomBytes(exports.SECRET_LENGTH).toString('base64');\n};\n\nexports.getSecret = function(req) {\n\treturn req.session[exports.SECRET_KEY] || (req.session[exports.SECRET_KEY] = exports.createSecret());\n};\n\nexports.createToken = function(req) {\n\treturn tokenize(utils.randomString(exports.SECRET_LENGTH), exports.getSecret(req));\n};\n\nexports.getToken = function(req, res) {\n\tres.locals[exports.LOCAL_VALUE] = res.locals[exports.LOCAL_VALUE] || exports.createToken(req);\n\tres.cookie(exports.XSRF_COOKIE_KEY, res.locals[exports.LOCAL_VALUE]);\n\treturn res.locals[exports.LOCAL_VALUE];\n};\n\nexports.requestToken = function(req) {\n\tif (req.body && req.body[exports.TOKEN_KEY]) {\n\t\treturn req.body[exports.TOKEN_KEY];\n\t} else if (req.query && req.query[exports.TOKEN_KEY]) {\n\t\treturn req.query[exports.TOKEN_KEY];\n\t} else if (req.headers && req.headers[exports.XSRF_HEADER_KEY]) {\n\t\treturn req.headers[exports.XSRF_HEADER_KEY];\t\n\t} else if (req.headers && req.headers[exports.CSRF_HEADER_KEY]) {\n\t\treturn req.headers[exports.CSRF_HEADER_KEY];\t\t\n\t}\n\treturn '';\n};\n\nexports.validate = function(req, token) {\n\tif (arguments.length === 1) {\n\t\ttoken = exports.requestToken(req);\n\t}\n\tif (typeof token !== 'string') {\n\t\treturn false;\n\t}\n\treturn scmp(token, tokenize(token.slice(0, exports.SECRET_LENGTH), req.session[exports.SECRET_KEY]));\n};\n\nexports.middleware = {\n\t\n\tinit: function(req, res, next) {\n\t\tres.locals[exports.LOCAL_KEY] = exports.LOCAL_VALUE;\n\t\texports.getToken(req, res);\n\t\tnext();\n\t},\n\t\n\tvalidate: function(req, res, next) {\n\t\t\n\t\t// Bail on safe methods\n\t\tif (req.method === 'GET' || req.method === 'HEAD' || req.method === 'OPTIONS') {\n\t\t\treturn next();\n\t\t}\n\t\t\n\t\t// Validate token\n\t\tif (exports.validate(req)) {\n\t\t\tnext();\n\t\t} else {\n\t\t\tres.statusCode = 403;\n\t\t\tnext(new Error('CSRF token mismatch'));\n\t\t}\n\t\n\t}\n\t\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/session.js":"var crypto = require('crypto');\nvar keystone = require('../');\nvar scmp = require('scmp');\nvar utils = require('keystone-utils');\n\n/**\n * Creates a hash of str with Keystone's cookie secret.\n * Only hashes the first half of the string.\n */\nfunction hash(str) {\n\t// force type\n\tstr = '' + str;\n\t// get the first half\n\tstr = str.substr(0, Math.round(str.length / 2));\n\t// hash using sha256\n\treturn crypto\n\t\t.createHmac('sha256', keystone.get('cookie secret'))\n\t\t.update(str)\n\t\t.digest('base64')\n\t\t.replace(/\\=+$/, '');\n}\n\n/**\n * Signs in a user using user obejct\n *\n * @param {Object} user - user object\n * @param {Object} req - express request object\n * @param {Object} res - express response object\n * @param {function()} onSuccess callback, is passed the User instance\n */\n\nfunction signinWithUser(user, req, res, onSuccess) {\n\tif (arguments.length < 4) {\n\t\tthrow new Error('keystone.session.signinWithUser requires user, req and res objects, and an onSuccess callback.');\n\t}\n\tif ('object' !== typeof user) {\n\t\tthrow new Error('keystone.session.signinWithUser requires user to be an object.');\n\t}\n\tif ('object' !== typeof req) {\n\t\tthrow new Error('keystone.session.signinWithUser requires req to be an object.');\n\t}\n\tif ('object' !== typeof res) {\n\t\tthrow new Error('keystone.session.signinWithUser requires res to be an object.');\n\t}\n\tif ('function' !== typeof onSuccess) {\n\t\tthrow new Error('keystone.session.signinWithUser requires onSuccess to be a function.');\n\t}\n\treq.session.regenerate(function() {\n\t\treq.user = user;\n\t\treq.session.userId = user.id;\n\t\t// if the user has a password set, store a persistence cookie to resume sessions\n\t\tif (keystone.get('cookie signin') && user.password) {\n\t\t\tvar userToken = user.id + ':' + hash(user.password);\n\t\t\tres.cookie('keystone.uid', userToken, { signed: true, httpOnly: true });\n\t\t}\n\t\tonSuccess(user);\n\t});\n}\n\nexports.signinWithUser = signinWithUser;\n\nvar postHookedSigninWithUser = function(user, req, res, onSuccess, onFail) {\n\tkeystone.callHook(user, 'post:signin', function(err) {\n\t\tif (err) {\n\t\t\treturn onFail(err);\n\t\t}\n\t\texports.signinWithUser(user, req, res, onSuccess, onFail);\n\t});\n};\n\n/**\n * Signs in a user user matching the lookup filters\n *\n * @param {Object} lookup - must contain email and password\n * @param {Object} req - express request object\n * @param {Object} res - express response object\n * @param {function()} onSuccess callback, is passed the User instance\n * @param {function()} onFail callback\n */\n\nvar doSignin = function(lookup, req, res, onSuccess, onFail) {\n\tif (!lookup) {\n\t\treturn onFail(new Error('session.signin requires a User ID or Object as the first argument'));\n\t}\n\tvar User = keystone.list(keystone.get('user model'));\n\tif ('string' === typeof lookup.email && 'string' === typeof lookup.password) {\n\t\t// ensure that it is an email, we don't want people being able to sign in by just using \"\\.\" and a haphazardly correct password.\n\t\tif (!utils.isEmail(lookup.email)) {\n\t\t\treturn onFail(new Error('Incorrect email or password'));\n\t\t}\n\t\t// create regex for email lookup with special characters escaped\n\t\tvar emailRegExp = new RegExp('^' + utils.escapeRegExp(lookup.email) + '$', 'i');\n\t\t// match email address and password\n\t\tUser.model.findOne({ email: emailRegExp }).exec(function(err, user) {\n\t\t\tif (user) {\n\t\t\t\tuser._.password.compare(lookup.password, function(err, isMatch) {\n\t\t\t\t\tif (!err && isMatch) {\n\t\t\t\t\t\tpostHookedSigninWithUser(user, req, res, onSuccess, onFail);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonFail(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tonFail(err);\n\t\t\t}\n\t\t});\n\t} else {\n\t\tlookup = '' + lookup;\n\t\t// match the userId, with optional password check\n\t\tvar userId = (lookup.indexOf(':') > 0) ? lookup.substr(0, lookup.indexOf(':')) : lookup;\n\t\tvar passwordCheck = (lookup.indexOf(':') > 0) ? lookup.substr(lookup.indexOf(':') + 1) : false;\n\t\tUser.model.findById(userId).exec(function(err, user) {\n\t\t\tif (user && (!passwordCheck || scmp(passwordCheck, hash(user.password)))) {\n\t\t\t\tpostHookedSigninWithUser(user, req, res, onSuccess, onFail);\n\t\t\t} else {\n\t\t\t\tonFail(err);\n\t\t\t}\n\t\t});\n\t}\n};\n\nexports.signin = function(lookup, req, res, onSuccess, onFail) {\n\tkeystone.callHook({}, 'pre:signin', function(err) {\n\t\tif (err) {\n\t\t\treturn onFail(err);\n\t\t}\n\t\tdoSignin(lookup, req, res, onSuccess, onFail);\n\t});\n};\n\n/**\n * Signs the current user out and resets the session\n *\n * @param {Object} req - express request object\n * @param {Object} res - express response object\n * @param {function()} next callback\n */\n\nexports.signout = function(req, res, next) {\n\tkeystone.callHook(req.user, 'pre:signout', function(err) {\n\t\tif (err) {\n\t\t\tconsole.log(\"An error occurred in signout 'pre' middleware\", err);\n\t\t}\n\t\tres.clearCookie('keystone.uid');\n\t\treq.user = null;\n\t\treq.session.regenerate(function(err) {\n\t\t\tif (err) {\n\t\t\t\treturn next(err);\n\t\t\t}\n\t\t\tkeystone.callHook({}, 'post:signout', function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tconsole.log(\"An error occurred in signout 'post' middleware\", err);\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t});\n\t\t});\n\t});\n};\n\n/**\n * Middleware to ensure session persistence across server restarts\n *\n * Looks for a userId cookie, and if present, and there is no user signed in,\n * automatically signs the user in.\n *\n * @param {Object} req - express request object\n * @param {Object} res - express response object\n * @param {function()} next callback\n */\n\nexports.persist = function(req, res, next) {\n\tvar User = keystone.list(keystone.get('user model'));\n\tif (!req.session) {\n\t\tconsole.error('\\nKeystoneJS Runtime Error:\\n\\napp must have session middleware installed. Try adding \"express-session\" to your express instance.\\n');\n\t\tprocess.exit(1);\n\t}\n\tif (keystone.get('cookie signin') && !req.session.userId && req.signedCookies['keystone.uid'] && req.signedCookies['keystone.uid'].indexOf(':') > 0) {\n\t\texports.signin(req.signedCookies['keystone.uid'], req, res, function() {\n\t\t\tnext();\n\t\t}, function(err) {\n\t\t\tnext(err);\n\t\t});\n\t} else if (req.session.userId) {\n\t\tUser.model.findById(req.session.userId).exec(function(err, user) {\n\t\t\tif (err) return next(err);\n\t\t\treq.user = user;\n\t\t\tnext();\n\t\t});\n\t} else {\n\t\tnext();\n\t}\n};\n\n/**\n * Middleware to enable access to Keystone\n *\n * Bounces the user to the signin screen if they are not signed in or do not have permission.\n *\n * req.user is the user returned by the database. It's type is Keystone.List.\n *\n * req.user.canAccessKeystone denotes whether the user has access to the admin panel.\n * If you're having issues double check your user model. Setting `canAccessKeystone` to true in\n * the database will not be reflected here if it is virtual.\n * See http://mongoosejs.com/docs/guide.html#virtuals\n *\n * @param {Object} req - express request object\n * @param req.user - The user object Keystone.List\n * @param req.user.canAccessKeystone {Boolean|Function}\n * @param {Object} res - express response object\n * @param {function()} next callback\n */\n\nexports.keystoneAuth = function(req, res, next) {\n\tif (!req.user || !req.user.canAccessKeystone) {\n\t\tvar from = new RegExp('^\\/keystone\\/?$', 'i').test(req.url) ? '' : '?from=' + req.url;\n\t\treturn res.redirect(keystone.get('signin url') + from);\n\t}\n\tnext();\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/azurefile/AzureFileType.js":"/*!\n * Module dependencies.\n */\n\nvar _ = require('underscore'),\n\tmoment = require('moment'),\n\tkeystone = require('../../../'),\n\tutil = require('util'),\n\tazure = require('azure'),\n\tutils = require('keystone-utils'),\n\tgrappling = require('grappling-hook'),\n\tsuper_ = require('../Type');\n\n\n/**\n * AzureFile FieldType Constructor\n * @extends Field\n * @api public\n */\n\nfunction azurefile(list, path, options) {\n\tgrappling.mixin(this)\n\t\t.allowHooks('pre:upload');\n\n\tthis._underscoreMethods = ['format', 'uploadFile'];\n\tthis._fixedSize = 'full';\n\n\t// TODO: implement filtering, usage disabled for now\n\toptions.nofilter = true;\n\n\t// TODO: implement initial form, usage disabled for now\n\tif (options.initial) {\n\t\tthrow new Error('Invalid Configuration\\n\\nAzureFile fields (' + list.key + '.' + path + ') do not currently support being used as initial fields.\\n');\n\t}\n\n\tazurefile.super_.call(this, list, path, options);\n\n\t// validate azurefile config (has to happen after super_.call)\n\tif (!this.azurefileconfig) {\n\t\tthrow new Error('Invalid Configuration\\n\\n' +\n\t\t\t'AzureFile fields (' + list.key + '.' + path + ') require the \"azurefile config\" option to be set.\\n\\n' +\n\t\t\t'See http://keystonejs.com/docs/configuration/#services-azure for more information.\\n');\n\t}\n\n\tprocess.env.AZURE_STORAGE_ACCOUNT = this.azurefileconfig.account;\n\tprocess.env.AZURE_STORAGE_ACCESS_KEY = this.azurefileconfig.key;\n\n\tthis.azurefileconfig.container = this.azurefileconfig.container || 'keystone';\n\n\tvar self = this;\n\toptions.filenameFormatter = options.filenameFormatter || function(item, filename) { return filename; };\n\toptions.containerFormatter = options.containerFormatter || function(item, filename) { return self.azurefileconfig.container; };//eslint-disable-line no-unused-vars\n\n\t// Could be more pre- hooks, just upload for now\n\tif (options.pre && options.pre.upload) {\n\t\tthis.pre('upload', options.pre.upload);\n\t}\n\n}\n\n/*!\n * Inherit from Field\n */\n\nutil.inherits(azurefile, super_);\n\n/**\n * Exposes the custom or keystone s3 config settings\n */\n\nObject.defineProperty(azurefile.prototype, 'azurefileconfig', {\n\tget: function() {\n\t\treturn this.options.azurefileconfig || keystone.get('azurefile config');\n\t}\n});\n\n\n/**\n * Registers the field on the List's Mongoose Schema.\n *\n * @api public\n */\n\nazurefile.prototype.addToSchema = function() {\n\n\tvar field = this,\n\t\tschema = this.list.schema;\n\n\tvar paths = this.paths = {\n\t\t// fields\n\t\tfilename:\t\tthis._path.append('.filename'),\n\t\tpath:\t\t\tthis._path.append('.path'),\n\t\tsize:\t\t\tthis._path.append('.size'),\n\t\tfiletype:\t\tthis._path.append('.filetype'),\n\t\turl:\t\t\tthis._path.append('.url'),\n\t\tetag:\t\t\tthis._path.append('.etag'),\n\t\tcontainer:\t\tthis._path.append('.container'),\n\t\t// virtuals\n\t\texists:\t\t\tthis._path.append('.exists'),\n\t\tupload:\t\t\tthis._path.append('_upload'),\n\t\taction:\t\t\tthis._path.append('_action')\n\t};\n\n\tvar schemaPaths = this._path.addTo({}, {\n\t\tfilename:\t\tString,\n\t\tpath:\t\t\tString,\n\t\tsize:\t\t\tNumber,\n\t\tfiletype:\t\tString,\n\t\turl:\t\t\tString,\n\t\tetag: \t\t\tString,\n\t\tcontainer:\t\tString\n\t});\n\n\tschema.add(schemaPaths);\n\n\tvar exists = function(item) {\n\t\treturn (item.get(paths.url) ? true : false);\n\t};\n\n\t// The .exists virtual indicates whether a file is stored\n\tschema.virtual(paths.exists).get(function() {\n\t\treturn schemaMethods.exists.apply(this);\n\t});\n\n\tvar reset = function(item) {\n\t\titem.set(field.path, {\n\t\t\tfilename: '',\n\t\t\tpath: '',\n\t\t\tsize: 0,\n\t\t\tfiletype: '',\n\t\t\turl: ''\n\t\t});\n\t};\n\n\tvar schemaMethods = {\n\t\texists: function() {\n\t\t\treturn exists(this);\n\t\t},\n\t\t/**\n\t\t * Resets the value of the field\n\t\t *\n\t\t * @api public\n\t\t */\n\t\treset: function() {\n\t\t\ttry {\n\t\t\t\tazure.createBlobService().deleteBlob(this.get(paths.container), this.get(paths.filename), function() {});\n\t\t\t} catch(e) {}//eslint-disable-line no-empty\n\t\t\treset(this);\n\t\t},\n\t\t/**\n\t\t * Deletes the file from AzureFile and resets the field\n\t\t *\n\t\t * @api public\n\t\t */\n\t\tdelete: function() {\n\t\t\ttry {\n\t\t\t\tazure.createBlobService().blobService.deleteBlob(this.get(paths.container), this.get(paths.filename), function() {});\n\t\t\t} catch(e) {}//eslint-disable-line no-empty\n\t\t\treset(this);\n\t\t}\n\t};\n\n\t_.each(schemaMethods, function(fn, key) {\n\t\tfield.underscoreMethod(key, fn);\n\t});\n\n\t// expose a method on the field to call schema methods\n\tthis.apply = function(item, method) {\n\t\treturn schemaMethods[method].apply(item, Array.prototype.slice.call(arguments, 2));\n\t};\n\n\tthis.bindUnderscoreMethods();\n};\n\n\n/**\n * Formats the field value\n *\n * @api public\n */\n\nazurefile.prototype.format = function(item) {\n\treturn item.get(this.paths.url);\n};\n\n\n/**\n * Detects whether the field has been modified\n *\n * @api public\n */\n\nazurefile.prototype.isModified = function(item) {\n\treturn item.isModified(this.paths.url);\n};\n\n\n/**\n * Validates that a value for this field has been provided in a data object\n *\n * @api public\n */\n\nazurefile.prototype.validateInput = function(data) {//eslint-disable-line no-unused-vars\n\t// TODO - how should file field input be validated?\n\treturn true;\n};\n\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * @api public\n */\n\nazurefile.prototype.updateItem = function(item, data) {//eslint-disable-line no-unused-vars\n\t// TODO - direct updating of data (not via upload)\n};\n\n\n/**\n * Uploads the file for this field\n *\n * @api public\n */\n\nazurefile.prototype.uploadFile = function(item, file, update, callback) {\n\n\tvar field = this,\n\t\tprefix = field.options.datePrefix ? moment().format(field.options.datePrefix) + '-' : '',//eslint-disable-line no-unused-vars\n\t\tfiletype = file.mimetype || file.type;\n\n\tif (field.options.allowedTypes && !_.contains(field.options.allowedTypes, filetype)) {\n\t\treturn callback(new Error('Unsupported File Type: ' + filetype));\n\t}\n\n\tif ('function' === typeof update) {\n\t\tcallback = update;\n\t\tupdate = false;\n\t}\n\n\tvar doUpload = function() {\n\t\tvar blobService = azure.createBlobService();\n\t\tvar container = field.options.containerFormatter(item, file.name);\n\n\t\tblobService.createContainerIfNotExists(container, { publicAccessLevel : 'blob' }, function(err) {\n\t\t\t\n\t\t\tif (err) return callback(err);\n\n\t\t\tblobService.createBlockBlobFromLocalFile(container, field.options.filenameFormatter(item, file.name), file.path, function(err, blob, res) {//eslint-disable-line no-unused-vars\n\n\t\t\t\tif (err) return callback(err);\n\t\t\t\n\t\t\t\tvar fileData = {\n\t\t\t\t\tfilename: blob.blob,\n\t\t\t\t\tsize: file.size,\n\t\t\t\t\tfiletype: filetype,\n\t\t\t\t\tetag: blob.etag,\n\t\t\t\t\tcontainer: container,\n\t\t\t\t\turl: 'http://' + field.azurefileconfig.account + '.blob.core.windows.net/' + container + '/' + blob.blob\n\t\t\t\t};\n\n\t\t\t\tif (update) {\n\t\t\t\t\titem.set(field.path, fileData);\n\t\t\t\t}\n\n\t\t\t\tcallback(null, fileData);\n\t\t\t\t\t\n\t\t\t});\n\t\t});\n\t};\n\n\tthis.callHook('pre:upload', item, file, function(err) {\n\t\tif (err) return callback(err);\n\t\tdoUpload();\n\t});\n};\n\n\n/**\n * Returns a callback that handles a standard form submission for the field\n *\n * Expected form parts are\n * - `field.paths.action` in `req.body` (`clear` or `delete`)\n * - `field.paths.upload` in `req.files` (uploads the file to s3file)\n *\n * @api public\n */\n\nazurefile.prototype.getRequestHandler = function(item, req, paths, callback) {\n\n\tvar field = this;\n\n\tif (utils.isFunction(paths)) {\n\t\tcallback = paths;\n\t\tpaths = field.paths;\n\t} else if (!paths) {\n\t\tpaths = field.paths;\n\t}\n\n\tcallback = callback || function() {};\n\n\treturn function() {\n\t\tif (req.body) {\n\t\t\tvar action = req.body[paths.action];\n\n\t\t\tif (/^(delete|reset)$/.test(action)) {\n\t\t\t\tfield.apply(item, action);\n\t\t\t}\n\t\t}\n\n\t\tif (req.files && req.files[paths.upload] && req.files[paths.upload].size) {\n\t\t\treturn field.uploadFile(item, req.files[paths.upload], true, callback);\n\t\t}\n\n\t\treturn callback();\n\n\t};\n\n};\n\n\n/**\n * Immediately handles a standard form submission for the field (see `getRequestHandler()`)\n *\n * @api public\n */\n\nazurefile.prototype.handleRequest = function(item, req, paths, callback) {\n\tthis.getRequestHandler(item, req, paths, callback)();\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = azurefile;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/boolean/BooleanType.js":"var FieldType = require('../Type');\nvar util = require('util');\n\n/**\n * Boolean FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction boolean(list, path, options) {\n\tthis._nativeType = Boolean;\n\tthis._properties = ['indent'];\n\tthis._fixedSize = 'full';\n\tthis.indent = (options.indent) ? true : false;\n\tboolean.super_.call(this, list, path, options);\n}\nutil.inherits(boolean, FieldType);\n\n/**\n * Add filters to a query\n */\nboolean.prototype.addFilterToQuery = function(filter, query) {\n\tquery = query || {};\n\tif (!filter.value || filter.value === 'false') {\n\t\tquery[this.path] = { $ne: true };\n\t} else {\n\t\tquery[this.path] = true;\n\t}\n\treturn query;\n};\n\n/**\n * Validates that a truthy value for this field has been provided in a data object.\n * Useful for checkboxes that are required to be true (e.g. agreed to terms and cond's)\n */\nboolean.prototype.validateInput = function(data, required) {\n\tif (required) {\n\t\treturn (data[this.path] === true || data[this.path] === 'true') ? true : false;\n\t} else {\n\t\treturn true;\n\t}\n};\n\n/**\n * Updates the value for this field in the item from a data object.\n * Only updates the value if it has changed.\n * Treats a falsy value or the string \"false\" as false, everything else as true.\n */\nboolean.prototype.updateItem = function(item, data) {\n\tvar value = this.getValueFromData(data);\n\tif (!value || value === 'false') {\n\t\tif (item.get(this.path) !== false) {\n\t\t\titem.set(this.path, false);\n\t\t}\n\t} else if (!item.get(this.path)) {\n\t\titem.set(this.path, true);\n\t}\n};\n\n/* Export Field Type */\nexports = module.exports = boolean;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/cloudinaryimage/CloudinaryImageType.js":"/*!\n * Module dependencies.\n */\n\nvar _ = require('underscore'),\n\tkeystone = require('../../../'),\n\tutil = require('util'),\n\tcloudinary = require('cloudinary'),\n\tMPromise = require('mpromise'),\n\tutils = require('keystone-utils'),\n\tsuper_ = require('../Type');\n\n/**\n * CloudinaryImage FieldType Constructor\n * @extends Field\n * @api public\n */\n\nfunction cloudinaryimage(list, path, options) {\n\n\tthis._underscoreMethods = ['format'];\n\tthis._fixedSize = 'full';\n\tthis._properties = ['select', 'selectPrefix', 'autoCleanup', 'publicID', 'folder', 'filenameAsPublicID'];\n\n\t// TODO: implement filtering, usage disabled for now\n\toptions.nofilter = true;\n\n\t// TODO: implement initial form, usage disabled for now\n\tif (options.initial) {\n\t\tthrow new Error(\n\t\t\t'Invalid Configuration\\n\\n' +\n\t\t\t'CloudinaryImage fields (' + list.key + '.' + path + ') do not currently support being used as initial fields.\\n'\n\t\t);\n\t}\n\n\tcloudinaryimage.super_.call(this, list, path, options);\n\n\t// validate cloudinary config\n\tif (!keystone.get('cloudinary config')) {\n\t\tthrow new Error(\n\t\t\t'Invalid Configuration\\n\\n' +\n\t\t\t'CloudinaryImage fields (' + list.key + '.' + this.path + ') require the \"cloudinary config\" option to be set.\\n\\n' +\n\t\t\t'See http://keystonejs.com/docs/configuration/#services-cloudinary for more information.\\n'\n\t\t);\n\t}\n\n}\n\n/*!\n * Inherit from Field\n */\n\nutil.inherits(cloudinaryimage, super_);\n\n\n/**\n * Registers the field on the List's Mongoose Schema.\n *\n * @api public\n */\n\ncloudinaryimage.prototype.addToSchema = function() {\n\n\tvar field = this,\n\t\tschema = this.list.schema;\n\n\tvar paths = this.paths = {\n\t\t// cloudinary fields\n\t\tpublic_id: \t\tthis._path.append('.public_id'),\n\t\tversion: \t\tthis._path.append('.version'),\n\t\tsignature: \t\tthis._path.append('.signature'),\n\t\tformat: \t\tthis._path.append('.format'),\n\t\tresource_type: \tthis._path.append('.resource_type'),\n\t\turl: \t\t\tthis._path.append('.url'),\n\t\twidth: \t\t\tthis._path.append('.width'),\n\t\theight: \t\tthis._path.append('.height'),\n\t\tsecure_url: \tthis._path.append('.secure_url'),\n\t\t// virtuals\n\t\texists: \t\tthis._path.append('.exists'),\n\t\tfolder: \t\tthis._path.append('.folder'),\n\t\t// form paths\n\t\tupload: \t\tthis._path.append('_upload'),\n\t\taction: \t\tthis._path.append('_action'),\n\t\tselect: \t\tthis._path.append('_select')\n\t};\n\n\tvar schemaPaths = this._path.addTo({}, {\n\t\tpublic_id:\t\tString,\n\t\tversion:\t\tNumber,\n\t\tsignature:\t\tString,\n\t\tformat:\t\t\tString,\n\t\tresource_type:\tString,\n\t\turl:\t\t\tString,\n\t\twidth:\t\t\tNumber,\n\t\theight:\t\t\tNumber,\n\t\tsecure_url:\t\tString\n\t});\n\n\tschema.add(schemaPaths);\n\n\tvar exists = function(item) {\n\t\treturn (item.get(paths.public_id) ? true : false);\n\t};\n\n\t// The .exists virtual indicates whether an image is stored\n\tschema.virtual(paths.exists).get(function() {\n\t\treturn schemaMethods.exists.apply(this);\n\t});\n\n\tvar folder = function(item) {//eslint-disable-line no-unused-vars\n\t\tvar folderValue = null;\n\n\t\tif (keystone.get('cloudinary folders')) {\n\t\t\tif (field.options.folder) {\n\t\t\t\tfolderValue = field.options.folder;\n\t\t\t} else {\n\t\t\t\tvar folderList = keystone.get('cloudinary prefix') ? [keystone.get('cloudinary prefix')] : [];\n\t\t\t\tfolderList.push(field.list.path);\n\t\t\t\tfolderList.push(field.path);\n\t\t\t\tfolderValue = folderList.join('/');\n\t\t\t}\n\t\t}\n\n\t\treturn folderValue;\n\t};\n\n\t// The .folder virtual returns the cloudinary folder used to upload/select images\n\tschema.virtual(paths.folder).get(function() {\n\t\treturn schemaMethods.folder.apply(this);\n\t});\n\n\tvar src = function(item, options) {\n\n\t\tif (!exists(item)) {\n\t\t\treturn '';\n\t\t}\n\n\t\toptions = ('object' === typeof options) ? options : {};\n\n\t\tif (!('fetch_format' in options) && keystone.get('cloudinary webp') !== false) {\n\t\t\toptions.fetch_format = 'auto';\n\t\t}\n\n\t\tif (!('progressive' in options) && keystone.get('cloudinary progressive') !== false) {\n\t\t\toptions.progressive = true;\n\t\t}\n\n\t\tif (!('secure' in options) && keystone.get('cloudinary secure')) {\n\t\t\toptions.secure = true;\n\t\t}\n\n\t\toptions.version = item.get(paths.version);\n\n\t\treturn cloudinary.url(item.get(paths.public_id) + '.' + item.get(paths.format), options);\n\n\t};\n\n\tvar reset = function(item) {\n\t\titem.set(field.path, {\n\t\t\tpublic_id: '',\n\t\t\tversion: 0,\n\t\t\tsignature: '',\n\t\t\tformat: '',\n\t\t\tresource_type: '',\n\t\t\turl: '',\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tsecure_url: ''\n\t\t});\n\t};\n\n\tvar addSize = function(options, width, height, other) {\n\t\tif (width) options.width = width;\n\t\tif (height) options.height = height;\n\t\tif ('object' === typeof other) {\n\t\t\t_.extend(options, other);\n\t\t}\n\t\treturn options;\n\t};\n\n\tvar schemaMethods = {\n\t\texists: function() {\n\t\t\treturn exists(this);\n\t\t},\n\t\tfolder: function() {\n\t\t\treturn folder(this);\n\t\t},\n\t\tsrc: function(options) {\n\t\t\treturn src(this, options);\n\t\t},\n\t\ttag: function(options) {\n\t\t\treturn exists(this) ? cloudinary.image(this.get(field.path), options) : '';\n\t\t},\n\t\tscale: function(width, height, options) {\n\t\t\treturn src(this, addSize({ crop: 'scale' }, width, height, options));\n\t\t},\n\t\tfill: function(width, height, options) {\n\t\t\treturn src(this, addSize({ crop: 'fill', gravity: 'faces' }, width, height, options));\n\t\t},\n\t\tlfill: function(width, height, options) {\n\t\t\treturn src(this, addSize({ crop: 'lfill', gravity: 'faces' }, width, height, options));\n\t\t},\n\t\tfit: function(width, height, options) {\n\t\t\treturn src(this, addSize({ crop: 'fit' }, width, height, options));\n\t\t},\n\t\tlimit: function(width, height, options) {\n\t\t\treturn src(this, addSize({ crop: 'limit' }, width, height, options));\n\t\t},\n\t\tpad: function(width, height, options) {\n\t\t\treturn src(this, addSize({ crop: 'pad' }, width, height, options));\n\t\t},\n\t\tlpad: function(width, height, options) {\n\t\t\treturn src(this, addSize({ crop: 'lpad' }, width, height, options));\n\t\t},\n\t\tcrop: function(width, height, options) {\n\t\t\treturn src(this, addSize({ crop: 'crop', gravity: 'faces' }, width, height, options));\n\t\t},\n\t\tthumbnail: function(width, height, options) {\n\t\t\treturn src(this, addSize({ crop: 'thumb', gravity: 'faces' }, width, height, options));\n\t\t},\n\t\t/**\n\t\t * Resets the value of the field\n\t\t *\n\t\t * @api public\n\t\t */\n\t\treset: function() {\n\t\t\treset(this);\n\t\t},\n\t\t/**\n\t\t * Deletes the image from Cloudinary and resets the field\n\t\t *\n\t\t * @api public\n\t\t */\n\t\tdelete: function() {\n\t\t\tvar promise = new MPromise();\n\n\t\t\tcloudinary.uploader.destroy(this.get(paths.public_id), function(result) {\n\t\t\t\tpromise.fulfill(result);\n\t\t\t});\n\t\t\treset(this);\n\n\t\t\treturn promise;\n\t\t},\n\t\t/**\n\t\t * Uploads the image to Cloudinary\n\t\t *\n\t\t * @api public\n\t\t */\n\t\tupload: function(file, options) {\n\t\t\tvar promise = new MPromise();\n\n\t\t\tcloudinary.uploader.upload(file, function(result) {\n\t\t\t\tpromise.fulfill(result);\n\t\t\t}, options);\n\n\t\t\treturn promise;\n\t\t}\n\t};\n\n\t_.each(schemaMethods, function(fn, key) {\n\t\tfield.underscoreMethod(key, fn);\n\t});\n\n\t// expose a method on the field to call schema methods\n\tthis.apply = function(item, method) {\n\t\treturn schemaMethods[method].apply(item, Array.prototype.slice.call(arguments, 2));\n\t};\n\n\tthis.bindUnderscoreMethods();\n};\n\n\n/**\n * Formats the field value\n *\n * @api public\n */\n\ncloudinaryimage.prototype.format = function(item) {\n\treturn item.get(this.paths.url);\n};\n\n\n/**\n * Detects whether the field has been modified\n *\n * @api public\n */\n\ncloudinaryimage.prototype.isModified = function(item) {\n\treturn item.isModified(this.paths.url);\n};\n\n\n/**\n * Validates that a value for this field has been provided in a data object\n *\n * @api public\n */\n\ncloudinaryimage.prototype.validateInput = function(data) {//eslint-disable-line no-unused-vars\n\t// TODO - how should image field input be validated?\n\treturn true;\n};\n\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * @api public\n */\n\ncloudinaryimage.prototype.updateItem = function(item, data) {\n\tvar paths = this.paths;\n\n\tvar setValue = function(key) {\n\t\tif (paths[key]) {\n\t\t\tvar index = paths[key].indexOf('.');\n\t\t\tvar field = paths[key].substr(0, index);\n\t\t\t// Note we allow implicit conversion here so that numbers submitted as strings in the data object\n\t\t\t// aren't treated as different values to the stored Number values\n\t\t\tif (data[field] && data[field][key] && data[field][key] != item.get(paths[key])) { // eslint-disable-line eqeqeq\n\t\t\t\titem.set(paths[key], data[field][key] || null);\n\t\t\t}\n\t\t}\n\t};\n\n\t_.each(['public_id', 'version', 'signature', 'format', 'resource_type', 'url', 'width', 'height', 'secure_url'], setValue);\n};\n\n\n/**\n * Returns a callback that handles a standard form submission for the field\n *\n * Expected form parts are\n * - `field.paths.action` in `req.body` (`clear` or `delete`)\n * - `field.paths.upload` in `req.files` (uploads the image to cloudinary)\n *\n * @api public\n */\n\ncloudinaryimage.prototype.getRequestHandler = function(item, req, paths, callback) {\n\n\tvar field = this;\n\n\tif (utils.isFunction(paths)) {\n\t\tcallback = paths;\n\t\tpaths = field.paths;\n\t} else if (!paths) {\n\t\tpaths = field.paths;\n\t}\n\n\tcallback = callback || function() {};\n\n\treturn function() {\n\n\t\tif (req.body) {\n\t\t\tvar action = req.body[paths.action];\n\n\t\t\tif (/^(delete|reset)$/.test(action)) {\n\t\t\t\tfield.apply(item, action);\n\t\t\t}\n\t\t}\n\n\t\tif (req.body && req.body[paths.select]) {\n\n\t\t\tcloudinary.api.resource(req.body[paths.select], function(result) {\n\t\t\t\tif (result.error) {\n\t\t\t\t\tcallback(result.error);\n\t\t\t\t} else {\n\t\t\t\t\titem.set(field.path, result);\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t});\n\n\t\t} else if (req.files && req.files[paths.upload] && req.files[paths.upload].size) {\n\n\t\t\tvar tp = keystone.get('cloudinary prefix') || '';\n\t\t\tvar imageDelete;\n\n\t\t\tif (tp.length) {\n\t\t\t\ttp += '_';\n\t\t\t}\n\n\t\t\tvar uploadOptions = {\n\t\t\t\ttags: [tp + field.list.path + '_' + field.path, tp + field.list.path + '_' + field.path + '_' + item.id]\n\t\t\t};\n\n\t\t\tif (keystone.get('cloudinary folders')) {\n\t\t\t\tuploadOptions.folder = item.get(paths.folder);\n\t\t\t}\n\n\t\t\tif (keystone.get('cloudinary prefix')) {\n\t\t\t\tuploadOptions.tags.push(keystone.get('cloudinary prefix'));\n\t\t\t}\n\n\t\t\tif (keystone.get('env') !== 'production') {\n\t\t\t\tuploadOptions.tags.push(tp + 'dev');\n\t\t\t}\n\n\t\t\tif (field.options.publicID) {\n\t\t\t\tvar publicIdValue = item.get(field.options.publicID);\n\t\t\t\tif (publicIdValue) {\n\t\t\t\t\tuploadOptions.public_id = publicIdValue;\n\t\t\t\t}\n\t\t\t} else if (field.options.filenameAsPublicID) {\n\t\t\t\tuploadOptions.public_id = req.files[paths.upload].originalname.substring(0, req.files[paths.upload].originalname.lastIndexOf('.'));\n\t\t\t}\n\n\t\t\tif (field.options.autoCleanup && item.get(field.paths.exists)) {\n\t\t\t\t// capture image delete promise\n\t\t\t\timageDelete = field.apply(item, 'delete');\n\t\t\t}\n\n\t\t\t// callback to be called upon completion of the 'upload' method\n\t\t\tvar uploadComplete = function(result) {\n\t\t\t\tif (result.error) {\n\t\t\t\t\tcallback(result.error);\n\t\t\t\t} else {\n\t\t\t\t\titem.set(field.path, result);\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// upload immediately if image is not being delete\n\t\t\tif (typeof imageDelete === 'undefined') {\n\t\t\t\tfield.apply(item, 'upload', req.files[paths.upload].path, uploadOptions).onFulfill(uploadComplete);\n\t\t\t} else {\n\t\t\t\t// otherwise wait until image is deleted before uploading\n\t\t\t\t// this avoids problems when deleting/uploading images with the same public_id (issue #598)\n\t\t\t\timageDelete.onFulfill(function(result) {\n\t\t\t\t\tif (result.error) {\n\t\t\t\t\t\tcallback(result.error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfield.apply(item, 'upload', req.files[paths.upload].path, uploadOptions).onFulfill(uploadComplete);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\n\t};\n\n};\n\n\n/**\n * Immediately handles a standard form submission for the field (see `getRequestHandler()`)\n *\n * @api public\n */\n\ncloudinaryimage.prototype.handleRequest = function(item, req, paths, callback) {\n\tthis.getRequestHandler(item, req, paths, callback)();\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = cloudinaryimage;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/cloudinaryimages/CloudinaryImagesType.js":"/*!\n * Module dependencies.\n */\n\nvar _ = require('underscore'),\n\tkeystone = require('../../../'),\n\tutil = require('util'),\n\tcloudinary = require('cloudinary'),\n\tutils = require('keystone-utils'),\n\tsuper_ = require('../Type'),\n\tasync = require('async');\n\n/**\n * CloudinaryImages FieldType Constructor\n * @extends Field\n * @api public\n */\n\nfunction cloudinaryimages(list, path, options) {\n\n\tthis._underscoreMethods = ['format'];\n\tthis._fixedSize = 'full';\n\tthis._properties = ['select', 'selectPrefix', 'autoCleanup', 'publicID', 'folder', 'filenameAsPublicID'];\n\n\t// TODO: implement filtering, usage disabled for now\n\toptions.nofilter = true;\n\t// TODO: implement initial form, usage disabled for now\n\tif (options.initial) {\n\t\tthrow new Error('Invalid Configuration\\n\\n' +\n\t\t\t'CloudinaryImages fields (' + list.key + '.' + path + ') do not currently support being used as initial fields.\\n');\n\t}\n\n\tcloudinaryimages.super_.call(this, list, path, options);\n\n\t// validate cloudinary config\n\tif (!keystone.get('cloudinary config')) {\n\t\tthrow new Error('Invalid Configuration\\n\\n' +\n\t\t\t'CloudinaryImages fields (' + list.key + '.' + this.path + ') require the \"cloudinary config\" option to be set.\\n\\n' +\n\t\t\t'See http://keystonejs.com/docs/configuration/#services-cloudinary for more information.\\n');\n\t}\n\n}\n\n/*!\n * Inherit from Field\n */\n\nutil.inherits(cloudinaryimages, super_);\n\n\n/**\n * Registers the field on the List's Mongoose Schema.\n *\n * @api public\n */\n\ncloudinaryimages.prototype.addToSchema = function() {\n\n\tvar mongoose = keystone.mongoose;\n\n\tvar field = this,\n\t\tschema = this.list.schema;\n\n\tthis.paths = {\n\t\t// virtuals\n\t\tfolder: \t\tthis._path.append('.folder'),\n\t\t// form paths\n\t\tupload: \t\tthis._path.append('_upload'),\n\t\tuploads: \t\tthis._path.append('_uploads'),\n\t\taction: \t\tthis._path.append('_action'),\n\t\torder: \t\t\tthis._path.append('_order')\n\t};\n\n\tvar ImageSchema = new mongoose.Schema({\n\t\tpublic_id:\t\tString,\n\t\tversion:\t\tNumber,\n\t\tsignature:\t\tString,\n\t\tformat:\t\t\tString,\n\t\tresource_type:\tString,\n\t\turl:\t\t\tString,\n\t\twidth:\t\t\tNumber,\n\t\theight:\t\t\tNumber,\n\t\tsecure_url:\t\tString\n\t});\n\n\t// Generate cloudinary folder used to upload/select images\n\tvar folder = function(item) {//eslint-disable-line no-unused-vars\n\t\tvar folderValue = '';\n\n\t\tif (keystone.get('cloudinary folders')) {\n\t\t\tif (field.options.folder) {\n\t\t\t\tfolderValue = field.options.folder;\n\t\t\t} else {\n\t\t\t\tvar folderList = keystone.get('cloudinary prefix') ? [keystone.get('cloudinary prefix')] : [];\n\t\t\t\tfolderList.push(field.list.path);\n\t\t\t\tfolderList.push(field.path);\n\t\t\t\tfolderValue = folderList.join('/');\n\t\t\t}\n\t\t}\n\n\t\treturn folderValue;\n\t};\n\n\t// The .folder virtual returns the cloudinary folder used to upload/select images\n\tschema.virtual(field.paths.folder).get(function() {\n\t\treturn folder(this);\n\t});\n\n\tvar src = function(img, options) {\n\t\tif (keystone.get('cloudinary secure')) {\n\t\t\toptions = options || {};\n\t\t\toptions.secure = true;\n\t\t}\n\t\treturn img.public_id ? cloudinary.url(img.public_id + '.' + img.format, options) : '';\n\t};\n\n\tvar addSize = function(options, width, height) {\n\t\tif (width) options.width = width;\n\t\tif (height) options.height = height;\n\t\treturn options;\n\t};\n\n\tImageSchema.method('src', function(options) {\n\t\treturn src(this, options);\n\t});\n\n\tImageSchema.method('scale', function(width, height) {\n\t\treturn src(this, addSize({ crop: 'scale' }, width, height));\n\t});\n\n\tImageSchema.method('fill', function(width, height) {\n\t\treturn src(this, addSize({ crop: 'fill', gravity: 'faces' }, width, height));\n\t});\n\n\tImageSchema.method('lfill', function(width, height) {\n\t\treturn src(this, addSize({ crop: 'lfill', gravity: 'faces' }, width, height));\n\t});\n\n\tImageSchema.method('fit', function(width, height) {\n\t\treturn src(this, addSize({ crop: 'fit' }, width, height));\n\t});\n\n\tImageSchema.method('limit', function(width, height) {\n\t\treturn src(this, addSize({ crop: 'limit' }, width, height));\n\t});\n\n\tImageSchema.method('pad', function(width, height) {\n\t\treturn src(this, addSize({ crop: 'pad' }, width, height));\n\t});\n\n\tImageSchema.method('lpad', function(width, height) {\n\t\treturn src(this, addSize({ crop: 'lpad' }, width, height));\n\t});\n\n\tImageSchema.method('crop', function(width, height) {\n\t\treturn src(this, addSize({ crop: 'crop', gravity: 'faces' }, width, height));\n\t});\n\n\tImageSchema.method('thumbnail', function(width, height) {\n\t\treturn src(this, addSize({ crop: 'thumb', gravity: 'faces' }, width, height));\n\t});\n\n\tschema.add(this._path.addTo({}, [ImageSchema]));\n\n\tthis.removeImage = function(item, id, method, callback) {\n\t\tvar images = item.get(field.path);\n\t\tif ('number' !== typeof id) {\n\t\t\tfor (var i = 0; i < images.length; i++) {\n\t\t\t\tif (images[i].public_id === id) {\n\t\t\t\t\tid = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar img = images[id];\n\t\tif (!img) return;\n\t\tif (method === 'delete') {\n\t\t\tcloudinary.uploader.destroy(img.public_id, function() {});\n\t\t}\n\t\timages.splice(id, 1);\n\t\tif (callback) {\n\t\t\titem.save(('function' !== typeof callback) ? callback : undefined);\n\t\t}\n\t};\n\n\tthis.underscoreMethod('remove', function(id, callback) {\n\t\tfield.removeImage(this, id, 'remove', callback);\n\t});\n\n\tthis.underscoreMethod('delete', function(id, callback) {\n\t\tfield.removeImage(this, id, 'delete', callback);\n\t});\n\n\tthis.bindUnderscoreMethods();\n};\n\n\n/**\n * Formats the field value\n *\n * @api public\n */\n\ncloudinaryimages.prototype.format = function(item) {\n\treturn _.map(item.get(this.path), function(img) {\n\t\treturn img.src();\n\t}).join(', ');\n};\n\n\n/**\n * Detects whether the field has been modified\n *\n * @api public\n */\n\ncloudinaryimages.prototype.isModified = function(item) {//eslint-disable-line no-unused-vars\n\t// TODO - how should this be detected?\n\treturn true;\n};\n\n\n/**\n * Validates that a value for this field has been provided in a data object\n *\n * @api public\n */\n\ncloudinaryimages.prototype.validateInput = function(data) {//eslint-disable-line no-unused-vars\n\t// TODO - how should image field input be validated?\n\treturn true;\n};\n\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * @api public\n */\n\ncloudinaryimages.prototype.updateItem = function(item, data) {//eslint-disable-line no-unused-vars\n\t// TODO - direct updating of data (not via upload)\n};\n\n\n/**\n * Returns a callback that handles a standard form submission for the field\n *\n * Expected form parts are\n * - `field.paths.action` in `req.body` in syntax `delete:public_id,public_id|remove:public_id,public_id`\n * - `field.paths.upload` in `req.files` (uploads the images to cloudinary)\n *\n * @api public\n */\n\ncloudinaryimages.prototype.getRequestHandler = function(item, req, paths, callback) {\n\n\tvar field = this;\n\n\tif (utils.isFunction(paths)) {\n\t\tcallback = paths;\n\t\tpaths = field.paths;\n\t} else if (!paths) {\n\t\tpaths = field.paths;\n\t}\n\n\tcallback = callback || function() {};\n\n\treturn function() {\n\n\t\t// Order\n\t\tif (req.body[paths.order]) {\n\t\t\tvar images = item.get(field.path),\n\t\t\t\tnewOrder = req.body[paths.order].split(',');\n\n\t\t\timages.sort(function(a, b) {\n\t\t\t\treturn (newOrder.indexOf(a.public_id) > newOrder.indexOf(b.public_id)) ? 1 : -1;\n\t\t\t});\n\t\t}\n\n\t\t// Removals & Deletes\n\t\tif (req.body && req.body[paths.action]) {\n\t\t\tvar actions = req.body[paths.action].split('|');\n\n\t\t\tactions.forEach(function(action) {\n\t\t\t\taction = action.split(':');\n\t\t\t\tvar method = action[0],\n\t\t\t\t\tids = action[1];\n\n\t\t\t\tif (!method.match(/^(remove|delete)$/) || !ids) return;\n\n\t\t\t\tids.split(',').forEach(function(id) {\n\t\t\t\t\tfield.removeImage(item, id, method);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// Upload References (direct uploading)\n\t\tif (req.body[paths.uploads]) {\n\t\t\tvar uploads = JSON.parse(req.body[paths.uploads]);\n\n\t\t\tuploads.forEach(function(file) {\n\t\t\t\titem.get(field.path).push(file);\n\t\t\t});\n\t\t}\n\n\t\t// Upload Data (form submissions)\n\t\tif (req.files && req.files[paths.upload]) {\n\t\t\tvar files = [].concat(req.files[paths.upload]);\n\n\t\t\tvar tp = keystone.get('cloudinary prefix') || '';\n\n\t\t\tif (tp.length) {\n\t\t\t\ttp += '_';\n\t\t\t}\n\n\t\t\tvar uploadOptions = {\n\t\t\t\ttags: [tp + field.list.path + '_' + field.path, tp + field.list.path + '_' + field.path + '_' + item.id]\n\t\t\t};\n\n\t\t\tif (keystone.get('cloudinary folders')) {\n\t\t\t\tuploadOptions.folder = item.get(paths.folder);\n\t\t\t}\n\n\t\t\tif (keystone.get('cloudinary prefix')) {\n\t\t\t\tuploadOptions.tags.push(keystone.get('cloudinary prefix'));\n\t\t\t}\n\n\t\t\tif (keystone.get('env') !== 'production') {\n\t\t\t\tuploadOptions.tags.push(tp + 'dev');\n\t\t\t}\n\n\n\t\t\tasync.each(files, function(file, next) {\n\n\t\t\t\tif (!file.size) return next();\n\n\t\t\t\tif (field.options.filenameAsPublicID) {\n\t\t\t\t\tuploadOptions.public_id = file.originalname.substring(0, file.originalname.lastIndexOf('.'));\n\t\t\t\t}\n\n\t\t\t\tcloudinary.uploader.upload(file.path, function(result) {\n\t\t\t\t\tif (result.error) {\n\t\t\t\t\t\treturn next(result.error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\titem.get(field.path).push(result);\n\t\t\t\t\t\treturn next();\n\t\t\t\t\t}\n\t\t\t\t}, uploadOptions);\n\n\t\t\t}, function(err) {\n\t\t\t\treturn callback(err);\n\t\t\t});\n\t\t} else {\n\t\t\treturn callback();\n\t\t}\n\t};\n};\n\n\n/**\n * Immediately handles a standard form submission for the field (see `getRequestHandler()`)\n *\n * @api public\n */\n\ncloudinaryimages.prototype.handleRequest = function(item, req, paths, callback) {\n\tthis.getRequestHandler(item, req, paths, callback)();\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = cloudinaryimages;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/code/CodeType.js":"var _ = require('underscore');\nvar FieldType = require('../Type');\nvar TextType = require('../text/TextType');\nvar util = require('util');\n\n/**\n * HTML FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction code(list, path, options) {\n\tthis._nativeType = String;\n\tthis._defaultSize = 'full';\n\tthis.height = options.height || 180;\n\tthis.lang = options.lang || options.language;\n\tthis._properties = ['editor', 'height', 'lang'];\n\tthis.codemirror = options.codemirror || {};\n\tthis.editor = _.defaults(this.codemirror, { mode : this.lang });\n\tcode.super_.call(this, list, path, options);\n}\nutil.inherits(code, FieldType);\n\n/* Inherit from TextType prototype */\ncode.prototype.addFilterToQuery = TextType.prototype.addFilterToQuery;\n\n/* Export Field Type */\nexports = module.exports = code;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/text/TextType.js":"var FieldType = require('../Type');\nvar util = require('util');\nvar utils = require('keystone-utils');\n\n/**\n * Text FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction text(list, path, options) {\n\tthis._nativeType = String;\n\tthis._underscoreMethods = ['crop'];\n\ttext.super_.call(this, list, path, options);\n}\nutil.inherits(text, FieldType);\n\n/**\n * Add filters to a query\n */\ntext.prototype.addFilterToQuery = function(filter, query) {\n\tquery = query || {};\n\tif (filter.mode === 'match' && !filter.value) {\n\t\tquery[this.path] = filter.invert ? { $nin: ['', null] } : { $in: ['', null] };\n\t\treturn;\n\t}\n\tvar value = utils.escapeRegExp(filter.value);\n\tif (filter.mode === 'startsWith') {\n\t\tvalue = '^' + value;\n\t} else if (filter.mode === 'endsWith') {\n\t\tvalue = value + '$';\n\t} else if (filter.mode === 'match') {\n\t\tvalue = '^' + value + '$';\n\t}\n\tvalue = new RegExp(value, filter.caseSensitive ? '' : 'i');\n\tquery[this.path] = filter.invert ? { $not: value } : value;\n\treturn query;\n};\n\n/**\n * Crops the string to the specifed length.\n */\ntext.prototype.crop = function(item, length, append, preserveWords) {\n\treturn utils.cropString(item.get(this.path), length, append, preserveWords);\n};\n\n/* Export Field Type */\nexports = module.exports = text;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/color/ColorType.js":"/*!\n * Module dependencies.\n */\n\nvar util = require('util'),\n\tsuper_ = require('../Type');\n\n/**\n * Color FieldType Constructor\n * @extends Field\n * @api public\n */\n\nfunction color(list, path, options) {\n\t\n\tthis._nativeType = String;\n\tthis._underscoreMethods = [];\n\tthis._fixedSize = 'small';\n\t\n\tcolor.super_.call(this, list, path, options);\n\t\n}\n\n/*!\n * Inherit from Field\n */\n\nutil.inherits(color, super_);\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = color;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/date/DateType.js":"var FieldType = require('../Type');\nvar moment = require('moment');\nvar util = require('util');\n\n/**\n * Date FieldType Constructor\n * @extends Field\n * @api public\n */\n\nfunction date(list, path, options) {\n\tthis._nativeType = Date;\n\tthis._underscoreMethods = ['format', 'moment', 'parse'];\n\tthis._fixedSize = 'large';\n\tthis._properties = ['dateFormat', 'datePlaceholder', 'yearRange', 'isUTC'];\n\tthis.parseDateFormat = options.format || 'YYYY-MM-DD';\n\tthis.dateFormat = (options.format === false) ? false : (options.format || 'YYYY-MM-DD');\n\tthis.datePlaceholder = this.dateFormat ? 'e.g. ' + moment().format(this.parseDateFormat) : '';\n\tthis.yearRange = options.yearRange;\n\tthis.isUTC = options.utc || false;\n\tif (this.dateFormat && 'string' !== typeof this.dateFormat) {\n\t\tthrow new Error('FieldType.Date: options.format must be a string.');\n\t}\n\tdate.super_.call(this, list, path, options);\n}\nutil.inherits(date, FieldType);\n\n/**\n * Add filters to a query\n */\ndate.prototype.addFilterToQuery = function(filter, query) {\n\tquery = query || {};\n\tif (filter.mode === 'between') {\n\t\tif (filter.after && filter.before) {\n\t\t\tfilter.after = moment(filter.after);\n\t\t\tfilter.before = moment(filter.before);\n\t\t\tif (filter.after.isValid() && filter.before.isValid()) {\n\t\t\t\tquery[this.path] = {\n\t\t\t\t\t$gte: filter.after.startOf('day').toDate(),\n\t\t\t\t\t$lte: filter.before.endOf('day').toDate()\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t} else if (filter.value) {\n\t\tfilter.value = moment(filter.value);\n\t\tif (filter.value.isValid()) {\n\t\t\tvar after = filter.value.startOf('day').toDate();\n\t\t\tvar before = filter.value.endOf('day').toDate();\n\t\t\tif (filter.mode === 'after') {\n\t\t\t\tquery[this.path] = { $gte: after };\n\t\t\t} else if (filter.mode === 'before') {\n\t\t\t\tquery[this.path] = { $lte: before };\n\t\t\t} else {\n\t\t\t\tquery[this.path] = { $gte: after, $lte: before };\n\t\t\t}\n\t\t}\n\t}\n\treturn query;\n};\n\n/**\n * Formats the field value\n */\ndate.prototype.format = function(item, format) {\n\tif (format || this.dateFormat) {\n\t\treturn item.get(this.path) ? this.moment(item).format(format || this.dateFormat) : '';\n\t} else {\n\t\treturn item.get(this.path) || '';\n\t}\n};\n\n/**\n * Returns a new `moment` object with the field value\n */\ndate.prototype.moment = function(item) {\n\tvar m = moment(item.get(this.path));\n\tif (this.isUTC) m.utc();\n\treturn m;\n};\n\n/**\n * Parses input using moment, sets the value, and returns the moment object.\n */\ndate.prototype.parse = function(item) {\n\tvar m = this.isUTC ? moment.utc : moment;\n\tvar newValue = m.apply(m, Array.prototype.slice.call(arguments, 1));\n\titem.set(this.path, (newValue && newValue.isValid()) ? newValue.toDate() : null);\n\treturn newValue;\n};\n\n/**\n * Checks that a valid date has been provided in a data object\n * An empty value clears the stored value and is considered valid\n */\ndate.prototype.validateInput = function(data, required, item) {\n\tif (!(this.path in data) && item && item.get(this.path)) return true;\n\tvar newValue = moment(data[this.path], this.parseDateFormat);\n\tif (required && (!newValue.isValid())) {\n\t\treturn false;\n\t} else if (data[this.path] && newValue && !newValue.isValid()) {\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n};\n\n/**\n * Updates the value for this field in the item from a data object\n */\ndate.prototype.updateItem = function(item, data) {\n\tif (!(this.path in data)) {\n\t\treturn;\n\t}\n\tvar m = this.isUTC ? moment.utc : moment;\n\tvar newValue = m(data[this.path], this.parseDateFormat);\n\tif (newValue.isValid()) {\n\t\tif (!item.get(this.path) || !newValue.isSame(item.get(this.path))) {\n\t\t\titem.set(this.path, newValue.toDate());\n\t\t}\n\t} else if (item.get(this.path)) {\n\t\titem.set(this.path, null);\n\t}\n};\n\n/* Export Field Type */\nexports = module.exports = date;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/datearray/DateArrayType.js":"/*!\n * Module dependencies.\n */\n\nvar util = require('util'),\n\tmoment = require('moment'),\n\tsuper_ = require('../Type');\n\n/**\n * Date FieldType Constructor\n * @extends Field\n * @api public\n */\n\nfunction datearray(list, path, options) {\n\t\n\tthis._nativeType = [Date];\n\tthis._fixedSize = 'large';\n\tthis._underscoreMethods = ['format'];\n\tthis._properties = ['formatString'];\n\n\tthis.parseFormatString = options.parseFormat || 'YYYY-MM-DD';\n\tthis.formatString = (options.format === false) ? false : (options.format || 'Do MMM YYYY');\n\t\n\tif (this.formatString && 'string' !== typeof this.formatString) {\n\t\tthrow new Error('FieldType.Date: options.format must be a string.');\n\t}\n\t\n\tdatearray.super_.call(this, list, path, options);\n}\n\n/*!\n * Inherit from Field\n */\n\nutil.inherits(datearray, super_);\n\n/**\n * Formats the field value\n *\n * @api public\n */\n\ndatearray.prototype.format = function(item, format) {\n\tif (format || this.formatString) {\n\t\treturn item.get(this.path) ? moment(item.get(this.path)).format(format || this.formatString) : '';\n\t} else {\n\t\treturn item.get(this.path) || '';\n\t}\n};\n\n/**\n * Checks that a valid array of dates has been provided in a data object\n *\n * An empty value clears the stored value and is considered valid\n *\n * @api public\n */\n\ndatearray.prototype.validateInput = function(data, required, item) {\n\n\tvar value = this.getValueFromData(data);\n\tvar parseFormatString = this.parseFormatString;\n\n\tif ('string' === typeof value) {\n\t\tif (!moment(value, parseFormatString).isValid()) {\n\t\t\treturn false;\n\t\t}\n\t\tvalue = [value];\n\t}\n\t\n\tif (required) {\n\t\tif (value === undefined && item && item.get(this.path) && item.get(this.path).length) {\n\t\t\treturn true;\n\t\t}\n\t\tif (value === undefined || !Array.isArray(value)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (Array.isArray(value) && !value.length) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tif (Array.isArray(value)) {\n\t\t// filter out empty fields\n\t\tvalue = value.filter(function(date) {\n\t\t\treturn date.trim() !== '';\n\t\t});\n\t\t// if there are no values left, and requried is true, return false\n\t\tif (required && !value.length) {\n\t\t\treturn false;\n\t\t}\n\t\t// if any date in the array is invalid, return false\n\t\tif (value.some(function (dateValue) { return !moment(dateValue, parseFormatString).isValid(); })) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn (value === undefined || Array.isArray(value));\n\n};\n\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * @api public\n */\n\ndatearray.prototype.updateItem = function(item, data) {\n\n\tvar value = this.getValueFromData(data);\n\t\n\tif (value !== undefined) {\n\t\tif (Array.isArray(value)) {\n\t\t\t// Only save valid dates\n\t\t\tvalue = value.filter(function(date) {\n\t\t\t\treturn moment(date).isValid();\n\t\t\t});\n\t\t}\n\t\tif (value === null) {\n\t\t\tvalue = [];\n\t\t}\n\t\tif ('string' === typeof value) {\n\t\t\tif (moment(value).isValid()) {\n\t\t\t\tvalue = [value];\n\t\t\t}\n\t\t}\n\t\tif (Array.isArray(value)) {\n\t\t\titem.set(this.path, value);\n\t\t}\n\t} else item.set(this.path, []);\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = datearray;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/datetime/DatetimeType.js":"var moment = require('moment');\nvar DateType = require('../date/DateType');\nvar FieldType = require('../Type');\nvar util = require('util');\nvar _ = require('underscore');\n\nvar parseFormats = ['YYYY-MM-DD', 'YYYY-MM-DD h:m:s a', 'YYYY-MM-DD h:m a', 'YYYY-MM-DD H:m:s', 'YYYY-MM-DD H:m'];\n\n/**\n * DateTime FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction datetime(list, path, options) {\n\tthis._nativeType = Date;\n\tthis._underscoreMethods = ['format', 'moment', 'parse'];\n\tthis._fixedSize = 'large';\n\tthis._properties = ['formatString', 'dateFormat', 'timeFormat', 'datePlaceholder', 'timePlaceholder', 'isUTC'];\n\tthis.typeDescription = 'date and time';\n\tthis.parseFormatString = options.parseFormat || parseFormats;\n\tthis.formatString = (options.format === false) ? false : (options.format || 'YYYY-MM-DD h:mm:ss a');\n\n\t// Create an array of moment time format characters to help find where the time portion of the format string beings\n\tvar timeOptions = ['h', 'H', 'm', 's', 'S'];\n\tvar timeIndex = -1;\n\n\tvar that = this;\n\n\tif(this.formatString) {\n\t\t// Loop through each moment time format character to determine which begins the time portion of format to segregate date from time\n\t\t_.each(timeOptions, function(timeChar) {\n\t\t\tvar charIndex = that.formatString.indexOf(timeChar);\n\n\t\t\tif((charIndex !== -1 && charIndex < timeIndex) || (charIndex !== -1 && timeIndex === -1)) {\n\t\t\t\ttimeIndex = charIndex;\n\t\t\t}\n\t\t});\n\n\t\tthis.dateFormat = this.formatString.slice(0, timeIndex).trim();\n\t\tthis.timeFormat = this.formatString.slice(timeIndex).trim();\n\t\tthis.datePlaceholder = 'e.g. ' + moment().format(this.dateFormat);\n\t\tthis.timePlaceholder = 'e.g. ' + moment().format(this.timeFormat);\n\n\t} else {\n\t\tthis.dateFormat = '';\n\t\tthis.timeFormat = '';\n\t\tthis.datePlaceholder = '';\n\t\tthis.timePlaceholder = '';\n\t}\n\n\tthis.isUTC = options.utc || false;\n\tif (this.formatString && 'string' !== typeof this.formatString) {\n\t\tthrow new Error('FieldType.DateTime: options.format must be a string.');\n\t}\n\tdatetime.super_.call(this, list, path, options);\n\tthis.paths = {\n\t\tdate: this._path.append('_date'),\n\t\ttime: this._path.append('_time')\n\t};\n}\nutil.inherits(datetime, FieldType);\n\n/* Inherit from DateType prototype */\ndatetime.prototype.addFilterToQuery = DateType.prototype.addFilterToQuery;\ndatetime.prototype.format = DateType.prototype.format;\ndatetime.prototype.moment = DateType.prototype.moment;\ndatetime.prototype.parse = DateType.prototype.parse;\n\n/**\n * Get the value from a data object; may be simple or a pair of fields\n */\ndatetime.prototype.getInputFromData = function(data) {\n\tif (this.paths.date in data && this.paths.time in data) {\n\t\treturn (data[this.paths.date] + ' ' + data[this.paths.time]).trim();\n\t} else {\n\t\treturn data[this.path];\n\t}\n};\n\n/**\n * Checks that a valid date has been provided in a data object\n * An empty value clears the stored value and is considered valid\n */\ndatetime.prototype.validateInput = function(data, required, item) {\n\tif (!(this.path in data && !(this.paths.date in data && this.paths.time in data)) && item && item.get(this.path)) return true;\n\tvar newValue = moment(this.getInputFromData(data), parseFormats);\n\tif (required && (!newValue || !newValue.isValid())) {\n\t\treturn false;\n\t} else if (this.getInputFromData(data) && newValue && !newValue.isValid()) {\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n};\n\n/**\n * Updates the value for this field in the item from a data object\n */\ndatetime.prototype.updateItem = function(item, data) {\n\tif (!(this.path in data || (this.paths.date in data && this.paths.time in data))) {\n\t\treturn;\n\t}\n\tvar m = this.isUTC ? moment.utc : moment;\n\tvar newValue = m(this.getInputFromData(data), this.formatString);\n\tif (newValue.isValid()) {\n\t\tif (!item.get(this.path) || !newValue.isSame(item.get(this.path))) {\n\t\t\titem.set(this.path, newValue.toDate());\n\t\t}\n\t} else if (item.get(this.path)) {\n\t\titem.set(this.path, null);\n\t}\n};\n\n/* Export Field Type */\nexports = module.exports = datetime;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/email/EmailType.js":"var crypto = require('crypto');\nvar FieldType = require('../Type');\nvar TextType = require('../text/TextType');\nvar util = require('util');\nvar utils = require('keystone-utils');\n\n/**\n * Email FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction email(list, path, options) {\n\tthis._nativeType = String;\n\tthis._underscoreMethods = ['gravatarUrl'];\n\tthis._fixedSize = 'large';\n\tthis.typeDescription = 'email address';\n\temail.super_.call(this, list, path, options);\n}\nutil.inherits(email, FieldType);\n\n/* Inherit from TextType prototype */\nemail.prototype.addFilterToQuery = TextType.prototype.addFilterToQuery;\n\n/**\n * Generate a gravatar image request url\n */\nemail.prototype.gravatarUrl = function(item, size, defaultImage, rating) {\n\tvar value = item.get(this.path);\n\tif ('string' !== typeof value) {\n\t\treturn '';\n\t}\n\treturn [\n\t\t// base url protocol-less for both http/https\n\t\t'//www.gravatar.com/avatar/',\n\t\t// md5 hash the trimmed lowercase email\n\t\tcrypto.createHash('md5').update(value.toLowerCase().trim()).digest('hex'),\n\t\t// size of images ranging from 1 to 2048 pixels, square\n\t\t'?s=' + (/^(?:[1-9][0-9]{0,2}|1[0-9]{3}|20[0-3][0-9]|204[0-8])$/.test(size) ? size : 80),\n\t\t// default image url encoded href or one of the built in options: 404, mm, identicon, monsterid, wavatar, retro, blank\n\t\t'&d=' + (defaultImage ? encodeURIComponent(defaultImage) : 'identicon'),\n\t\t// rating, g, pg, r or x\n\t\t'&r=' + (/^(?:g|pg|r|x)$/i.test(rating) ? rating.toLowerCase() : 'g')\n\t].join('');\n};\n\n/**\n * Validates that a valid email has been provided in a data object\n */\nemail.prototype.validateInput = function(data, required, item) {\n\tvar value = this.getValueFromData(data);\n\tif (value) {\n\t\treturn utils.isEmail(value);\n\t} else {\n\t\treturn (!required || (value !== undefined && item && item.get(this.path))) ? true : false;\n\t}\n};\n\n/**\n * Updates the value for this field in the item from a data object\n * Ensures that the email address is lowercase\n */\nemail.prototype.updateItem = function(item, data) {\n\tvar newValue = this.getValueFromData(data);\n\tif ('string' === typeof newValue) {\n\t\tnewValue = newValue.toLowerCase();\n\t}\n\tif (newValue !== undefined && newValue !== item.get(this.path)) {\n\t\titem.set(this.path, newValue);\n\t}\n};\n\n/* Export Field Type */\nexports = module.exports = email;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/embedly/EmbedlyType.js":"/*!\n * Module dependencies.\n */\n\nvar _ = require('underscore'),\n\tkeystone = require('../../../'),\n\tutil = require('util'),\n\tEmbedlyAPI = require('embedly'),\n\tsuper_ = require('../Type');\n\n/**\n * Embedly FieldType Constructor\n *\n * Reqires the option `from` to refer to another path in the schema\n * that provides the url to expand\n *\n * @extends Field\n * @api public\n */\n\nfunction embedly(list, path, options) {\n\n\tthis._underscoreMethods = ['reset'];\n\tthis._fixedSize = 'full';\n\t\n\tthis.fromPath = options.from;\n\tthis.embedlyOptions = options.options || {};\n\n\t// TODO: implement filtering, usage disabled for now\n\toptions.nofilter = true;\n\n\t// check and api key has been set, or bail.\n\tif (!keystone.get('embedly api key')) {\n\t\tthrow new Error('Invalid Configuration\\n\\n' +\n\t\t\t'Embedly fields (' + list.key + '.' + path + ') require the \"embedly api key\" option to be set.\\n\\n' +\n\t\t\t'See http://keystonejs.com/docs/configuration/#services-embedly for more information.\\n');\n\t}\n\n\t// ensure a fromPath has been defined\n\tif (!options.from) {\n\t\tthrow new Error('Invalid Configuration\\n\\n' +\n\t\t\t'Embedly fields (' + list.key + '.' + path + ') require a fromPath option to be set.\\n' +\n\t\t\t'See http://keystonejs.com/docs/database/#fieldtypes-embedly for more information.\\n');\n\t}\n\n\t// embedly fields cannot be set as initial fields\n\tif (options.initial) {\n\t\tthrow new Error('Invalid Configuration\\n\\n' +\n\t\t\t'Embedly fields (' + list.key + '.' + path + ') cannot be set as initial fields.\\n');\n\t}\n\n\tembedly.super_.call(this, list, path, options);\n\n}\n\n/*!\n * Inherit from Field\n */\n\nutil.inherits(embedly, super_);\n\n\n/**\n * Registers the field on the List's Mongoose Schema.\n *\n * @api public\n */\n\nembedly.prototype.addToSchema = function() {\n\n\tvar field = this,\n\t\tschema = this.list.schema;\n\n\tthis.paths = {\n\t\texists: \t\t\t\tthis._path.append('.exists'),\n\t\ttype: \t\t\t\t\tthis._path.append('.type'),\n\t\ttitle: \t\t\t\t\tthis._path.append('.title'),\n\t\turl: \t\t\t\t\tthis._path.append('.url'),\n\t\twidth: \t\t\t\t\tthis._path.append('.width'),\n\t\theight: \t\t\t\tthis._path.append('.height'),\n\t\tversion: \t\t\t\tthis._path.append('.version'),\n\t\tdescription: \t\t\tthis._path.append('.description'),\n\t\thtml: \t\t\t\t\tthis._path.append('.html'),\n\t\tauthorName: \t\t\tthis._path.append('.authorName'),\n\t\tauthorUrl: \t\t\t\tthis._path.append('.authorUrl'),\n\t\tproviderName: \t\t\tthis._path.append('.providerName'),\n\t\tproviderUrl: \t\t\tthis._path.append('.providerUrl'),\n\t\tthumbnailUrl: \t\t\tthis._path.append('.thumbnailUrl'),\n\t\tthumbnailWidth: \t\tthis._path.append('.thumbnailWidth'),\n\t\tthumbnailHeight: \t\tthis._path.append('.thumbnailHeight')\n\t};\n\n\tschema.nested[this.path] = true;\n\tschema.add({\n\t\texists: \t\t\t\tBoolean,\n\t\ttype: \t\t\t\t\tString,\n\t\ttitle: \t\t\t\t\tString,\n\t\turl: \t\t\t\t\tString,\n\t\twidth: \t\t\t\t\tNumber,\n\t\theight: \t\t\t\tNumber,\n\t\tversion: \t\t\t\tString,\n\t\tdescription: \t\t\tString,\n\t\thtml: \t\t\t\t\tString,\n\t\tauthorName: \t\t\tString,\n\t\tauthorUrl: \t\t\t\tString,\n\t\tproviderName: \t\t\tString,\n\t\tproviderUrl: \t\t\tString,\n\t\tthumbnailUrl: \t\t\tString,\n\t\tthumbnailWidth: \t\tNumber,\n\t\tthumbnailHeight: \t\tNumber\n\t}, this.path + '.');\n\n\t// Bind the pre-save hook to hit the embedly api if the source path has changed\n\n\tschema.pre('save', function(next) {\n\n\t\tif (!this.isModified(field.fromPath)) {\n\t\t\treturn next();\n\t\t}\n\n\t\tvar fromValue = this.get(field.fromPath);\n\n\t\tif (!fromValue) {\n\t\t\tfield.reset(this);\n\t\t\treturn next();\n\t\t}\n\n\t\tvar post = this;\n\n\t\tnew EmbedlyAPI({ key: keystone.get('embedly api key') }, function(err, api) {//eslint-disable-line no-new\n\n\t\t\tif (err) {\n\t\t\t\tconsole.error('Error creating Embedly api:');\n\t\t\t\tconsole.error(err, api);\n\t\t\t\tfield.reset(this);\n\t\t\t\treturn next();\n\t\t\t}\n\n\t\t\tvar opts = _.defaults({ url: fromValue }, field.embedlyOptions);\n\n\t\t\tapi.oembed(opts, function(err, objs) {\n\n\t\t\t\tif (err) {\n\t\t\t\t\tconsole.error('Embedly API Error:');\n\t\t\t\t\tconsole.error(err, objs);\n\t\t\t\t\tfield.reset(post);\n\t\t\t\t} else {\n\t\t\t\t\tvar data = objs[0];\n\t\t\t\t\tif (data && data.type !== 'error') {\n\t\t\t\t\t\tpost.set(field.path, {\n\t\t\t\t\t\t\texists: \t\t\ttrue,\n\t\t\t\t\t\t\ttype: \t\t\t\tdata.type,\n\t\t\t\t\t\t\ttitle: \t\t\t\tdata.title,\n\t\t\t\t\t\t\turl: \t\t\t\tdata.url,\n\t\t\t\t\t\t\twidth: \t\t\t\tdata.width,\n\t\t\t\t\t\t\theight: \t\t\tdata.height,\n\t\t\t\t\t\t\tversion: \t\t\tdata.version,\n\t\t\t\t\t\t\tdescription: \t\tdata.description,\n\t\t\t\t\t\t\thtml: \t\t\t\tdata.html,\n\t\t\t\t\t\t\tauthorName: \t\tdata.author_name,\n\t\t\t\t\t\t\tauthorUrl: \t\t\tdata.author_url,\n\t\t\t\t\t\t\tproviderName: \t\tdata.provider_name,\n\t\t\t\t\t\t\tproviderUrl: \t\tdata.provider_url,\n\t\t\t\t\t\t\tthumbnailUrl: \t\tdata.thumbnail_url,\n\t\t\t\t\t\t\tthumbnailWidth: \tdata.thumbnail_width,\n\t\t\t\t\t\t\tthumbnailHeight: \tdata.thumbnail_height\n\t\t\t\t\t\t});\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfield.reset(post);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn next();\n\n\t\t\t});\n\t\t});\n\n\t});\n\n\tthis.bindUnderscoreMethods();\n\n};\n\n\n/**\n * Resets the value of the field\n *\n * @api public\n */\n\nembedly.prototype.reset = function(item) {\n\treturn item.set(item.set(this.path, {\n\t\texists: \t\t\tfalse,\n\t\ttype: \t\t\t\tnull,\n\t\ttitle: \t\t\t\tnull,\n\t\turl: \t\t\t\tnull,\n\t\twidth: \t\t\t\tnull,\n\t\theight: \t\t\tnull,\n\t\tversion: \t\t\tnull,\n\t\tdescription: \t\tnull,\n\t\thtml: \t\t\t\tnull,\n\t\tauthorName: \t\tnull,\n\t\tauthorUrl: \t\t\tnull,\n\t\tproviderName: \t\tnull,\n\t\tproviderUrl: \t\tnull,\n\t\tthumbnailUrl: \t\tnull,\n\t\tthumbnailWidth: \tnull,\n\t\tthumbnailHeight: \tnull\n\t}));\n};\n\n\n/**\n * Formats the field value\n *\n * @api public\n */\n\nembedly.prototype.format = function(item) {\n\treturn item.get(this.paths.html);\n};\n\n\n/**\n * Detects whether the field has been modified\n *\n * @api public\n */\n\nembedly.prototype.isModified = function(item) {\n\t// Assume that it has changed if the url is different\n\treturn item.isModified(this.paths.url);\n};\n\n\n/**\n * Validates that a value for this field has been provided in a data object\n *\n * @api public\n */\n\nembedly.prototype.validateInput = function(data) {//eslint-disable-line no-unused-vars\n\t// TODO: I don't think embedly fields need to be validated...\n\treturn true;\n};\n\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * @api public\n */\n\nembedly.prototype.updateItem = function(item, data) {\n\t// TODO: This could be more granular and check for actual changes to values,\n\t// see the Location field for an example\n\treturn item.set(item.set(this.path, {\n\t\texists: \t\t\tdata[this.paths.exists],\n\t\ttype: \t\t\t\tdata[this.paths.type],\n\t\ttitle: \t\t\t\tdata[this.paths.title],\n\t\turl: \t\t\t\tdata[this.paths.url],\n\t\twidth: \t\t\t\tdata[this.paths.width],\n\t\theight: \t\t\tdata[this.paths.height],\n\t\tversion: \t\t\tdata[this.paths.version],\n\t\tdescription: \t\tdata[this.paths.description],\n\t\thtml: \t\t\t\tdata[this.paths.html],\n\t\tauthorName: \t\tdata[this.paths.authorName],\n\t\tauthorUrl: \t\t\tdata[this.paths.authorUrl],\n\t\tproviderName: \t\tdata[this.paths.providerName],\n\t\tproviderUrl: \t\tdata[this.paths.providerUrl],\n\t\tthumbnailUrl: \t\tdata[this.paths.thumbnailUrl],\n\t\tthumbnailWidth: \tdata[this.paths.thumbnailWidth],\n\t\tthumbnailHeight: \tdata[this.paths.thumbnailHeight]\n\t}));\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = embedly;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/geopoint/GeoPointType.js":"/*!\n * Module dependencies.\n */\n\nvar _ = require('underscore'),\n\tutil = require('util'),\n\tsuper_ = require('../Type');\n\t\nvar REGEXP_LNGLAT = /^\\s*(\\-?\\d+(?:\\.\\d+)?)\\s*\\,\\s*(\\-?\\d+(?:\\.\\d+)?)\\s*$/;\n\n/**\n * Geo FieldType Constructor\n * @extends Field\n * @api public\n */\n\nfunction geopoint(list, path, options) {\n\t\n\tthis._fixedSize = 'medium';\n\t\n\t// TODO: implement filtering, hard-coded as disabled for now\n\toptions.nofilter = true;\n\tgeopoint.super_.call(this, list, path, options);\n\t\n}\n\n/*!\n * Inherit from Field\n */\n\nutil.inherits(geopoint, super_);\n\n\n/**\n * Registers the field on the List's Mongoose Schema.\n *\n * Adds a 2dsphere indexed lat/lng pair\n *\n * @api public\n */\n\ngeopoint.prototype.addToSchema = function() {\n\tthis.list.schema.path(this.path, _.defaults({ type: [Number], index: '2dsphere' }, this.options));\n\tthis.bindUnderscoreMethods();\n};\n\n\n/**\n * Gets the field's data from an Item, as used by the React components\n */\n\ngeopoint.prototype.getData = function(item) {\n\tvar points = item.get(this.path);\n\treturn (points && points.length === 2) ? points : [];\n};\n\n\n/**\n * Formats the field value\n *\n * @api public\n */\n\ngeopoint.prototype.format = function(item) {\n\tif (item.get(this.path)) {\n\t\treturn item.get(this.path).reverse().join(', ');\t\n\t}\n\treturn null;\n};\n\n\n/**\n * Validates that a value for this field has been provided in a data object\n *\n * @api public\n */\n\ngeopoint.prototype.validateInput = function(data, required, item) {//eslint-disable-line no-unused-vars\n\t\n\tvar values = this.getValueFromData(data);\n\n\t// Input is valid if the field is not required, and not present\n\tif (values === undefined && !required) return true;\n\t\n\tif (_.isArray(values)) {\n\t\tvalues = _.compact(values).join(',');\n\t}\n\t\n\tif (values === '' && !required) return true;\n\t\n\treturn REGEXP_LNGLAT.test(values);\n\n};\n\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * @api public\n */\n\ngeopoint.prototype.updateItem = function(item, data) {\n\t\n\tif (!_.isObject(data)) return;\n\t\n\tvar value = this.getValueFromData(data);\n\tif (value === undefined) return;\n\n\tif (_.isString(value)) {\n\t\t\n\t\t// Value should be formatted lng,lat\n\t\tvar values = REGEXP_LNGLAT.exec(value);\n\t\t\n\t\tif (values) {\n\t\t\titem.set(this.path, [values[1], values[2]]);\n\t\t} else {\n\t\t\titem.set(this.path, undefined);\n\t\t}\n\t\t\n\t} else if (_.isArray(value)) {\n\t\t\n\t\tif (value.length === 2 && REGEXP_LNGLAT.test(_.compact(value).join(','))) {\n\t\t\titem.set(this.path, value);\n\t\t} else {\n\t\t\titem.set(this.path, undefined);\n\t\t}\n\t\t\n\t}\n\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = geopoint;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/html/HtmlType.js":"var FieldType = require('../Type');\nvar TextType = require('../text/TextType');\nvar util = require('util');\n\n/**\n * HTML FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction html(list, path, options) {\n\tthis._nativeType = String;\n\tthis._defaultSize = 'full';\n\tthis.wysiwyg = options.wysiwyg || false;\n\tthis.height = options.height || 180;\n\tthis._properties = ['wysiwyg', 'height'];\n\thtml.super_.call(this, list, path, options);\n}\nutil.inherits(html, FieldType);\n\n/* Inherit from TextType prototype */\nhtml.prototype.addFilterToQuery = TextType.prototype.addFilterToQuery;\n\n/* Export Field Type */\nexports = module.exports = html;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/key/KeyType.js":"var FieldType = require('../Type');\nvar TextType = require('../text/TextType');\nvar util = require('util');\nvar utils = require('keystone-utils');\n\n/**\n * Key FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction key(list, path, options) {\n\tthis._nativeType = String;\n\tthis._defaultSize = 'medium';\n\tthis.separator = options.separator || '-';\n\tkey.super_.call(this, list, path, options);\n}\nutil.inherits(key, FieldType);\n\n/* Inherit from TextType prototype */\nkey.prototype.addFilterToQuery = TextType.prototype.addFilterToQuery;\n\n/**\n * Generates a valid key from a string\n */\nkey.prototype.generateKey = function(str) {\n\treturn utils.slug(String(str), this.separator);\n};\n\n/**\n * Checks that a valid key has been provided in a data object\n */\nkey.prototype.validateInput = function(data, required, item) {\n\tvar value = this.getValueFromData(data);\n\tif (value === undefined && item && item.get(this.path)) {\n\t\treturn true;\n\t}\n\tvalue = this.generateKey(value);\n\treturn (value || !required) ? true : false;\n};\n\n/**\n * Updates the value for this field in the item from a data object\n */\nkey.prototype.updateItem = function(item, data) {\n\tvar value = this.getValueFromData(data);\n\tif (value === undefined) {\n\t\treturn;\n\t}\n\tvalue = this.generateKey(value);\n\tif (item.get(this.path) !== value) {\n\t\titem.set(this.path, value);\n\t}\n};\n\n/* Export Field Type */\nexports = module.exports = key;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/localfile/LocalFileType.js":"/*!\n * Module dependencies.\n */\n\nvar fs = require('fs-extra'),\n\tpath = require('path'),\n\t_ = require('underscore'),\n\tmoment = require('moment'),\n\tgrappling = require('grappling-hook'),\n\tutil = require('util'),\n\tutils = require('keystone-utils'),\n\tsuper_ = require('../Type');\n\n/**\n * localfile FieldType Constructor\n * @extends Field\n * @api public\n */\n\nfunction localfile(list, path, options) {\n\tgrappling.mixin(this)\n\t\t.allowHooks('move');\n\tthis._underscoreMethods = ['format', 'uploadFile'];\n\tthis._fixedSize = 'full';\n\n\t// TODO: implement filtering, usage disabled for now\n\toptions.nofilter = true;\n\t\n\t// TODO: implement initial form, usage disabled for now\n\tif (options.initial) {\n\t\tthrow new Error('Invalid Configuration\\n\\n' +\n\t\t\t'localfile fields (' + list.key + '.' + path + ') do not currently support being used as initial fields.\\n');\n\t}\n\t\n\tif (options.overwrite !== false) {\n\t\toptions.overwrite = true;\n\t}\n\t\n\tlocalfile.super_.call(this, list, path, options);\n\t\n\t// validate destination dir\n\tif (!options.dest) {\n\t\tthrow new Error('Invalid Configuration\\n\\n' +\n\t\t\t'localfile fields (' + list.key + '.' + path + ') require the \"dest\" option to be set.');\n\t}\n\t// Allow hook into before and after\n\tif (options.pre && options.pre.move) {\n\t\tthis.pre('move', options.pre.move);\n\t}\n\t\n\tif (options.post && options.post.move) {\n\t\tthis.post('move', options.post.move);\n\t}\n\t\n}\n\n/*!\n * Inherit from Field\n */\n\nutil.inherits(localfile, super_);\n\n\n\n/**\n * Registers the field on the List's Mongoose Schema.\n *\n * @api public\n */\n\nlocalfile.prototype.addToSchema = function() {\n\t\n\tvar field = this,\n\t\tschema = this.list.schema;\n\t\n\tvar paths = this.paths = {\n\t\t// fields\n\t\tfilename:\t\tthis._path.append('.filename'),\n\t\toriginalname:\t\tthis._path.append('.originalname'),\n\t\tpath:\t\t\tthis._path.append('.path'),\n\t\tsize:\t\t\tthis._path.append('.size'),\n\t\tfiletype:\t\tthis._path.append('.filetype'),\n\t\t// virtuals\n\t\texists:\t\t\tthis._path.append('.exists'),\n\t\thref:\t\t\tthis._path.append('.href'),\n\t\tupload:\t\t\tthis._path.append('_upload'),\n\t\taction:\t\t\tthis._path.append('_action')\n\t};\n\t\n\tvar schemaPaths = this._path.addTo({}, {\n\t\tfilename:\t\tString,\n\t\toriginalname:   String,\n\t\tpath:\t\t\tString,\n\t\tsize:\t\t\tNumber,\n\t\tfiletype:\t\tString\n\t});\n\t\n\tschema.add(schemaPaths);\n\t\n\t// exists checks for a matching file at run-time\n\tvar exists = function(item) {\n\t\tvar filepath = item.get(paths.path),\n\t\t\tfilename = item.get(paths.filename);\n\n\t\tif (!filepath || !filename) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn fs.existsSync(path.join(filepath, filename));\n\t};\n\t\n\t// The .exists virtual indicates whether a file is stored\n\tschema.virtual(paths.exists).get(function() {\n\t\treturn schemaMethods.exists.apply(this);\n\t});\n\t\n\t// The .href virtual returns the public path of the file\n\tschema.virtual(paths.href).get(function() {\n\t\treturn field.href.call(field, this);\n\t});\n\t\n\t// reset clears the value of the field\n\tvar reset = function(item) {\n\t\titem.set(field.path, {\n\t\t\tfilename: '',\n\t\t\tpath: '',\n\t\t\tsize: 0,\n\t\t\tfiletype: ''\n\t\t});\n\t};\n\n\tvar schemaMethods = {\n\t\texists: function() {\n\t\t\treturn exists(this);\n\t\t},\n\t\t/**\n\t\t * Resets the value of the field\n\t\t *\n\t\t * @api public\n\t\t */\n\t\treset: function() {\n\t\t\treset(this);\n\t\t},\n\t\t/**\n\t\t * Deletes the file from localfile and resets the field\n\t\t *\n\t\t * @api public\n\t\t */\n\t\tdelete: function() {\n\t\t\tif (exists(this)) {\n\t\t\t\tfs.unlinkSync(path.join(this.get(paths.path), this.get(paths.filename)));\n\t\t\t}\n\t\t\treset(this);\n\t\t}\n\t};\n\n\t_.each(schemaMethods, function(fn, key) {\n\t\tfield.underscoreMethod(key, fn);\n\t});\n\n\t// expose a method on the field to call schema methods\n\tthis.apply = function(item, method) {\n\t\treturn schemaMethods[method].apply(item, Array.prototype.slice.call(arguments, 2));\n\t};\n\n\tthis.bindUnderscoreMethods();\n};\n\n\n/**\n * Formats the field value\n *\n * Delegates to the options.format function if it exists.\n * @api public\n */\n\nlocalfile.prototype.format = function(item) {\n\tif (!item.get(this.paths.filename)) return '';\n\tif (this.hasFormatter()) {\n\t\tvar file = item.get(this.path);\n\t\tfile.href = this.href(item);\n\t\treturn this.options.format.call(this, item, file);\n\t}\n\treturn this.href(item);\n};\n\n\n/**\n * Detects whether the field has formatter function\n *\n * @api public\n */\n\nlocalfile.prototype.hasFormatter = function() {\n\treturn 'function' === typeof this.options.format;\n};\n\n\n/**\n * Return the public href for the stored file\n *\n * @api public\n */\n\nlocalfile.prototype.href = function(item) {\n\tif (!item.get(this.paths.filename)) return '';\n\tvar prefix = this.options.prefix ? this.options.prefix : item.get(this.paths.path);\n\treturn prefix + '/' + item.get(this.paths.filename);\n};\n\n\n/**\n * Detects whether the field has been modified\n *\n * @api public\n */\n\nlocalfile.prototype.isModified = function(item) {\n\treturn item.isModified(this.paths.path);\n};\n\n\n/**\n * Validates that a value for this field has been provided in a data object\n *\n * @api public\n */\n\nlocalfile.prototype.validateInput = function(data) {//eslint-disable-line no-unused-vars\n\t// TODO - how should file field input be validated?\n\treturn true;\n};\n\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * @api public\n */\n\nlocalfile.prototype.updateItem = function(item, data) {//eslint-disable-line no-unused-vars\n\t// TODO - direct updating of data (not via upload)\n};\n\n\n/**\n * Uploads the file for this field\n *\n * @api public\n */\n\nlocalfile.prototype.uploadFile = function(item, file, update, callback) {\n\tvar field = this,\n\t\tprefix = field.options.datePrefix ? moment().format(field.options.datePrefix) + '-' : '',\n\t\tfilename = prefix + file.name,\n\t\tfiletype = file.mimetype || file.type;\n\n\tif (field.options.allowedTypes && !_.contains(field.options.allowedTypes, filetype)) {\n\t\treturn callback(new Error('Unsupported File Type: ' + filetype));\n\t}\n\n\tif ('function' === typeof update) {\n\t\tcallback = update;\n\t\tupdate = false;\n\t}\n\n\tvar doMove = function(callback) {\n\t\t\n\t\tif ('function' === typeof field.options.filename) {\n\t\t\tfilename = field.options.filename(item, file);\n\t\t}\n\n\t\tfs.move(file.path, path.join(field.options.dest, filename), { clobber: field.options.overwrite }, function(err) {\n\t\t\t\n\t\t\tif (err) return callback(err);\n\n\t\t\tvar fileData = {\n\t\t\t\tfilename: filename,\n\t\t\t\toriginalname: file.originalname,\n\t\t\t\tpath: field.options.dest,\n\t\t\t\tsize: file.size,\n\t\t\t\tfiletype: filetype\n\t\t\t};\n\n\t\t\tif (update) {\n\t\t\t\titem.set(field.path, fileData);\n\t\t\t}\n\n\t\t\tcallback(null, fileData);\n\t\t\t\n\t\t});\n\t};\n\n\tfield.callHook('pre:move', item, file, function(err) {\n\t\tif (err) return callback(err);\n\t\tdoMove(function(err, fileData) {\n\t\t\tif (err) return callback(err);\n\t\t\tfield.callHook('post:move', [item, file, fileData], function(err) {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tcallback(null, fileData);\n\t\t\t});\n\t\t});\n\t});\n};\n\n\n/**\n * Returns a callback that handles a standard form submission for the field\n *\n * Expected form parts are\n * - `field.paths.action` in `req.body` (`clear` or `delete`)\n * - `field.paths.upload` in `req.files` (uploads the file to localfile)\n *\n * @api public\n */\n\nlocalfile.prototype.getRequestHandler = function(item, req, paths, callback) {\n\n\tvar field = this;\n\n\tif (utils.isFunction(paths)) {\n\t\tcallback = paths;\n\t\tpaths = field.paths;\n\t} else if (!paths) {\n\t\tpaths = field.paths;\n\t}\n\n\tcallback = callback || function() {};\n\n\treturn function() {\n\n\t\tif (req.body) {\n\t\t\tvar action = req.body[paths.action];\n\n\t\t\tif (/^(delete|reset)$/.test(action)) {\n\t\t\t\tfield.apply(item, action);\n\t\t\t}\n\t\t}\n\n\t\tif (req.files && req.files[paths.upload] && req.files[paths.upload].size) {\n\t\t\treturn field.uploadFile(item, req.files[paths.upload], true, callback);\n\t\t}\n\n\t\treturn callback();\n\n\t};\n\n};\n\n\n/**\n * Immediately handles a standard form submission for the field (see `getRequestHandler()`)\n *\n * @api public\n */\n\nlocalfile.prototype.handleRequest = function(item, req, paths, callback) {\n\tthis.getRequestHandler(item, req, paths, callback)();\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = localfile;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/localfiles/LocalFilesType.js":"/*!\n * Module dependencies.\n */\n\nvar fs = require('fs-extra'),\n\tpath = require('path'),\n\t_ = require('underscore'),\n\tmoment = require('moment'),\n\tkeystone = require('../../../'),\n\tutil = require('util'),\n\tutils = require('keystone-utils'),\n\tsuper_ = require('../Type'),\n\tasync = require('async'),\n\tgrappling = require('grappling-hook');\n\n/**\n * localfiles FieldType Constructor\n * @extends Field\n * @api public\n */\n\nfunction localfiles(list, path, options) {\n\tgrappling.mixin(this)\n\t\t.allowHooks('move');\n\tthis._underscoreMethods = ['format', 'uploadFiles'];\n\tthis._fixedSize = 'full';\n\n\t// TODO: implement filtering, usage disabled for now\n\toptions.nofilter = true;\n\n\t// TODO: implement initial form, usage disabled for now\n\tif (options.initial) {\n\t\tthrow new Error('Invalid Configuration\\n\\n' +\n\t\t\t'localfiles fields (' + list.key + '.' + path + ') do not currently support being used as initial fields.\\n');\n\t}\n\n\tif (options.overwrite !== false) {\n\t\toptions.overwrite = true;\n\t}\n\n\tlocalfiles.super_.call(this, list, path, options);\n\n\t// validate destination dir\n\tif (!options.dest) {\n\t\tthrow new Error('Invalid Configuration\\n\\n' +\n\t\t\t'localfiles fields (' + list.key + '.' + path + ') require the \"dest\" option to be set.');\n\t}\n\n\t// Allow hook into before and after\n\tif (options.pre && options.pre.move) {\n\t\tthis.pre('move', options.pre.move);\n\t}\n\n\tif (options.post && options.post.move) {\n\t\tthis.post('move', options.post.move);\n\t}\n\n}\n\n/*!\n * Inherit from Field\n */\n\nutil.inherits(localfiles, super_);\n\n\n/**\n * Registers the field on the List's Mongoose Schema.\n *\n * @api public\n */\n\nlocalfiles.prototype.addToSchema = function() {\n\n\tvar field = this,\n\t\tschema = this.list.schema;\n\tvar mongoose = keystone.mongoose;\n\n\tvar paths = this.paths = {\n\t\t// fields\n\t\tfilename:\t\tthis._path.append('.filename'),\n\t\tpath:\t\t\tthis._path.append('.path'),\n\t\toriginalname:\tthis._path.append('.originalname'),\n\t\tsize:\t\t\tthis._path.append('.size'),\n\t\tfiletype:\t\tthis._path.append('.filetype'),\n\t\t// virtuals\n\t\texists:\t\t\tthis._path.append('.exists'),\n\t\tupload:\t\t\tthis._path.append('_upload'),\n\t\taction:\t\t\tthis._path.append('_action'),\n\t\torder: \t\t\tthis._path.append('_order')\n\t};\n\n\tvar schemaPaths = new mongoose.Schema({\n\t\tfilename:\t\tString,\n\t\toriginalname:\tString,\n\t\tpath:\t\t\tString,\n\t\tsize:\t\t\tNumber,\n\t\tfiletype:\t\tString\n\t});\n\n\t// The .href virtual returns the public path of the file\n\tschemaPaths.virtual('href').get(function() {\n\t\treturn field.href.call(field, this);\n\t});\n\n\tschema.add(this._path.addTo({}, [schemaPaths]));\n\n\tvar exists = function(item, element_id) {\n\t\tvar values = item.get(field.path);\n\t\tvar value;\n\n\t\tif (typeof values === 'undefined' || values.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// if current Field contains any file, it means it exists\n\t\tif (typeof element_id === 'undefined') {\n\t\t\tvalue = values[0];\n\t\t} else {\n\t\t\tvalue = _.findWhere(values, { 'id': element_id });\n\t\t}\n\n\t\tif (typeof value === 'undefined') {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar filepaths = value.path,\n\t\t\tfilename = value.filename;\n\n\t\tif (!filepaths || !filename) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn fs.existsSync(path.join(filepaths, filename));\n\t};\n\n\t// The .exists virtual indicates whether a file is stored\n\tschema.virtual(paths.exists).get(function() {\n\t\treturn schemaMethods.exists.apply(this);\n\t});\n\n\tvar reset = function(item, element_id) {\n\t\tif (typeof element_id === 'undefined') {\n\t\t\titem.set(field.path, []);\n\t\t} else {\n\t\t\tvar values = item.get(field.path);\n\t\t\tvar value = _.findWhere(values, { 'id': element_id });\n\t\t\tif (typeof value !== 'undefined') {\n\t\t\t\tvalues.splice(values.indexOf(value), 1);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar schemaMethods = {\n\t\texists: function() {\n\t\t\treturn exists(this);\n\t\t},\n\t\t/**\n\t\t * Resets the value of the field\n\t\t *\n\t\t * @api public\n\t\t */\n\t\treset: function() {\n\t\t\treset(this);\n\t\t},\n\t\t/**\n\t\t * Deletes the file from localfiles and resets the field\n\t\t *\n\t\t * @api public\n\t\t */\n\t\tdelete: function(element_id) {\n\t\t\tif (exists(this, element_id)) {\n\t\t\t\tvar values = this.get(field.path);\n\t\t\t\tvar value = _.findWhere(values, { 'id': element_id });\n\t\t\t\tif (typeof value !== 'undefined') {\n\t\t\t\t\tfs.unlinkSync(path.join(value.path, value.filename));\n\t\t\t\t}\n\t\t\t}\n\t\t\treset(this, element_id);\n\t\t}\n\t};\n\n\t_.each(schemaMethods, function(fn, key) {\n\t\tfield.underscoreMethod(key, fn);\n\t});\n\n\t// expose a method on the field to call schema methods\n\tthis.apply = function(item, method) {\n\t\treturn schemaMethods[method].apply(item, Array.prototype.slice.call(arguments, 2));\n\t};\n\n\tthis.bindUnderscoreMethods();\n};\n\n\n/**\n * Formats the field value\n *\n * @api public\n */\n\nlocalfiles.prototype.format = function(item, i) {\n\tvar files = item.get(this.path);\n\tif (typeof i === 'undefined') {\n\t\treturn utils.plural(files.length, '* File');\n\t}\n\tvar file = files[i];\n\tif (!file) return '';\n\tif (this.hasFormatter()) {\n\t\tfile.href = this.href(file);\n\t\treturn this.options.format.call(this, item, file);\n\t}\n\treturn file.filename;\n};\n\n\n/**\n * Detects whether the field has a formatter function\n *\n * @api public\n */\n\nlocalfiles.prototype.hasFormatter = function() {\n\treturn 'function' === typeof this.options.format;\n};\n\n\n/**\n * Return the public href for a single stored file\n *\n * @api public\n */\n\nlocalfiles.prototype.href = function(file) {\n\tif (!file.filename) return '';\n\tvar prefix = this.options.prefix ? this.options.prefix : file.path;\n\treturn prefix + '/' + file.filename;\n};\n\n\n/**\n * Detects whether the field has been modified\n *\n * @api public\n */\n\nlocalfiles.prototype.isModified = function(item) {\n\treturn item.isModified(this.paths.path);\n};\n\n\n/**\n * Validates that a value for this field has been provided in a data object\n *\n * @api public\n */\n\nlocalfiles.prototype.validateInput = function(data) {//eslint-disable-line no-unused-vars\n\t// TODO - how should file field input be validated?\n\treturn true;\n};\n\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * @api public\n */\n\nlocalfiles.prototype.updateItem = function(item, data) {//eslint-disable-line no-unused-vars\n\t// TODO - direct updating of data (not via upload)\n};\n\n\n/**\n * Uploads the file for this field\n *\n * @api public\n */\n\nlocalfiles.prototype.uploadFiles = function(item, files, update, callback) {\n\n\tvar field = this;\n\n\tif ('function' === typeof update) {\n\t\tcallback = update;\n\t\tupdate = false;\n\t}\n\n\tasync.map(files, function(file, processedFile) {\n\n\t\tvar prefix = field.options.datePrefix ? moment().format(field.options.datePrefix) + '-' : '',\n\t\t\tfilename = prefix + file.name,\n\t\t\tfiletype = file.mimetype || file.type;\n\n\t\tif (field.options.allowedTypes && !_.contains(field.options.allowedTypes, filetype)) {\n\t\t\treturn processedFile(new Error('Unsupported File Type: ' + filetype));\n\t\t}\n\n\t\tvar doMove = function(doneMove) {\n\n\t\t\tif ('function' === typeof field.options.filename) {\n\t\t\t\tfilename = field.options.filename(item, file);\n\t\t\t}\n\n\t\t\tfs.move(file.path, path.join(field.options.dest, filename), { clobber: field.options.overwrite }, function(err) {\n\t\t\t\tif (err) return doneMove(err);\n\n\t\t\t\tvar fileData = {\n\t\t\t\t\tfilename: filename,\n\t\t\t\t\toriginalname: file.originalname,\n\t\t\t\t\tpath: field.options.dest,\n\t\t\t\t\tsize: file.size,\n\t\t\t\t\tfiletype: filetype\n\t\t\t\t};\n\n\t\t\t\tif (update) {\n\t\t\t\t\titem.get(field.path).push(fileData);\n\t\t\t\t}\n\n\t\t\t\tdoneMove(null, fileData);\n\t\t\t});\n\n\t\t};\n\n\t\tfield.callHook('pre:move', item, file, function(err) {\n\t\t\tif (err) return processedFile(err);\n\n\t\t\tdoMove(function(err, fileData) {\n\t\t\t\tif (err) return processedFile(err);\n\t\t\t\tfield.callHook('post:move', item, file, fileData, function(err) {\n\t\t\t\t\treturn processedFile(err, fileData);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t}, callback);\n\n};\n\n\n/**\n * Returns a callback that handles a standard form submission for the field\n *\n * Expected form parts are\n * - `field.paths.action` in `req.body` (`clear` or `delete`)\n * - `field.paths.upload` in `req.files` (uploads the file to localfiles)\n *\n * @api public\n */\n\nlocalfiles.prototype.getRequestHandler = function(item, req, paths, callback) {\n\n\tvar field = this;\n\n\tif (utils.isFunction(paths)) {\n\t\tcallback = paths;\n\t\tpaths = field.paths;\n\t} else if (!paths) {\n\t\tpaths = field.paths;\n\t}\n\n\tcallback = callback || function() {};\n\n\treturn function() {\n\n\t\t// Order\n\t\tif (req.body[paths.order]) {\n\t\t\tvar files = item.get(field.path),\n\t\t\t\tnewOrder = req.body[paths.order].split(',');\n\n\t\t\tfiles.sort(function(a, b) {\n\t\t\t\treturn (newOrder.indexOf(a._id.toString()) > newOrder.indexOf(b._id.toString())) ? 1 : -1;\n\t\t\t});\n\t\t}\n\n\t\t// Removals\n\t\tif (req.body && req.body[paths.action]) {\n\t\t\tvar actions = req.body[paths.action].split('|');\n\n\t\t\tactions.forEach(function(action) {\n\n\t\t\t\taction = action.split(':');\n\n\t\t\t\tvar method = action[0],\n\t\t\t\t\tids = action[1];\n\n\t\t\t\tif (!(/^(delete|reset)$/.test(method)) || !ids) return;\n\n\t\t\t\tids.split(',').forEach(function(id) {\n\t\t\t\t\tfield.apply(item, method, id);\n\t\t\t\t});\n\n\t\t\t});\n\t\t}\n\n\t\t// Upload new files\n\t\tif (req.files) {\n\n\t\t\tvar upFiles = req.files[paths.upload];\n\t\t\tif (upFiles) {\n\t\t\t\tif (!Array.isArray(upFiles)) {\n\t\t\t\t\tupFiles = [upFiles];\n\t\t\t\t}\n\n\t\t\t\tif (upFiles.length > 0) {\n\t\t\t\t\tupFiles = _.filter(upFiles, function(f) { return typeof f.name !== 'undefined' && f.name.length > 0; });\n\n\t\t\t\t\tif (upFiles.length > 0) {\n\t\t\t\t\t\tconsole.log('uploading files:');\n\t\t\t\t\t\tconsole.log(upFiles);\n\t\t\t\t\t\treturn field.uploadFiles(item, upFiles, true, callback);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn callback();\n\t};\n\n};\n\n\n/**\n * Immediately handles a standard form submission for the field (see `getRequestHandler()`)\n *\n * @api public\n */\n\nlocalfiles.prototype.handleRequest = function(item, req, paths, callback) {\n\tthis.getRequestHandler(item, req, paths, callback)();\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = localfiles;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/location/LocationType.js":"/*!\n * Module dependencies.\n */\n\nvar _ = require('underscore'),\n\tkeystone = require('../../../'),\n\tquerystring = require('querystring'),\n\thttps = require('https'),\n\tutil = require('util'),\n\tutils = require('keystone-utils'),\n\tsuper_ = require('../Type');\n\nvar RADIUS_KM = 6371,\n\tRADIUS_MILES = 3959;\n\n/**\n * Location FieldType Constructor\n * @extends Field\n * @api public\n */\n\nfunction location(list, path, options) {\n\n\tthis._underscoreMethods = ['format', 'googleLookup', 'kmFrom', 'milesFrom'];\n\tthis._fixedSize = 'full';\n\n\tthis.enableMapsAPI = (options.geocodeGoogle===true || (options.geocodeGoogle !== false && keystone.get('google server api key'))) ? true : false;\n\n\tthis._properties = ['enableMapsAPI'];\n\n\tif (!options.defaults) {\n\t\toptions.defaults = {};\n\t}\n\n\tif (options.required) {\n\t\tif (Array.isArray(options.required)) {\n\t\t\t// required can be specified as an array of paths\n\t\t\tthis.requiredPaths = options.required;\n\t\t} else if ('string' === typeof options.required) {\n\t\t\t// or it can be specified as a comma-delimited list\n\t\t\tthis.requiredPaths = options.required.replace(/,/g, ' ').split(/\\s+/);\n\t\t}\n\t\t// options.required should always be simplified to a boolean\n\t\toptions.required = true;\n\t}\n\t// default this.requiredPaths\n\tif (!this.requiredPaths) {\n\t\tthis.requiredPaths = ['street1', 'suburb'];\n\t}\n\n\tlocation.super_.call(this, list, path, options);\n\n}\n\n/*!\n * Inherit from Field\n */\n\nutil.inherits(location, super_);\n\n\n/**\n * Registers the field on the List's Mongoose Schema.\n *\n * @api public\n */\n\nlocation.prototype.addToSchema = function() {\n\n\tvar field = this,\n\t\tschema = this.list.schema,\n\t\toptions = this.options;\n\n\tvar paths = this.paths = {\n\t\tnumber: this._path.append('.number'),\n\t\tname: this._path.append('.name'),\n\t\tstreet1: this._path.append('.street1'),\n\t\tstreet2: this._path.append('.street2'),\n\t\tsuburb: this._path.append('.suburb'),\n\t\tstate: this._path.append('.state'),\n\t\tpostcode: this._path.append('.postcode'),\n\t\tcountry: this._path.append('.country'),\n\t\tgeo: this._path.append('.geo'),\n\t\tgeo_lat: this._path.append('.geo_lat'),\n\t\tgeo_lng: this._path.append('.geo_lng'),\n\t\tserialised: this._path.append('.serialised'),\n\t\timprove: this._path.append('_improve'),\n\t\toverwrite: this._path.append('_improve_overwrite')\n\t};\n\n\tvar getFieldDef = function(type, key) {\n\t\tvar def = { type: type };\n\t\tif (options.defaults[key]) {\n\t\t\tdef.default = options.defaults[key];\n\t\t}\n\t\treturn def;\n\t};\n\n\tschema.nested[this.path] = true;\n\tschema.add({\n\t\tnumber: getFieldDef(String, 'number'),\n\t\tname: getFieldDef(String, 'name'),\n\t\tstreet1: getFieldDef(String, 'street1'),\n\t\tstreet2: getFieldDef(String, 'street2'),\n\t\tstreet3: getFieldDef(String, 'street3'),\n\t\tsuburb: getFieldDef(String, 'suburb'),\n\t\tstate: getFieldDef(String, 'state'),\n\t\tpostcode: getFieldDef(String, 'postcode'),\n\t\tcountry: getFieldDef(String, 'country'),\n\t\tgeo: { type: [Number], index: '2dsphere' }\n\t}, this.path + '.');\n\n\tschema.virtual(paths.serialised).get(function() {\n\t\treturn _.compact([\n\t\t\tthis.get(paths.number),\n\t\t\tthis.get(paths.name),\n\t\t\tthis.get(paths.street1),\n\t\t\tthis.get(paths.street2),\n\t\t\tthis.get(paths.suburb),\n\t\t\tthis.get(paths.state),\n\t\t\tthis.get(paths.postcode),\n\t\t\tthis.get(paths.country)\n\t\t]).join(', ');\n\t});\n\n\t// pre-save hook to fix blank geo fields\n\t// see http://stackoverflow.com/questions/16388836/does-applying-a-2dsphere-index-on-a-mongoose-schema-force-the-location-field-to\n\tschema.pre('save', function(next) {\n\t\tvar obj = field._path.get(this);\n\t\tif (Array.isArray(obj.geo) && (obj.geo.length !== 2 || (obj.geo[0] === null && obj.geo[1] === null))) {\n\t\t\tobj.geo = undefined;\n\t\t}\n\t\tnext();\n\t});\n\n\tthis.bindUnderscoreMethods();\n\n};\n\n\n/**\n * Formats a list of the values stored by the field. Only paths that\n * have values will be included.\n *\n * Optionally provide a space-separated list of values to include.\n *\n * Delimiter defaults to `', '`.\n *\n * @api public\n */\n\nlocation.prototype.format = function(item, values, delimiter) {\n\n\tif (!values) {\n\t\treturn item.get(this.paths.serialised);\n\t}\n\n\tvar paths = this.paths;\n\n\tvalues = values.split(' ').map(function(i) {\n\t\treturn item.get(paths[i]);\n\t});\n\n\treturn _.compact(values).join(delimiter || ', ');\n\n};\n\n\n/**\n * Detects whether the field has been modified\n *\n * @api public\n */\n\nlocation.prototype.isModified = function(item) {\n\treturn item.isModified(this.paths.number) ||\n\t\titem.isModified(this.paths.name) ||\n\t\titem.isModified(this.paths.street1) ||\n\t\titem.isModified(this.paths.street2) ||\n\t\titem.isModified(this.paths.suburb) ||\n\t\titem.isModified(this.paths.state) ||\n\t\titem.isModified(this.paths.postcode) ||\n\t\titem.isModified(this.paths.country) ||\n\t\titem.isModified(this.paths.geo);\n};\n\n\n/**\n * Validates that a value for this field has been provided in a data object\n *\n * options.required specifies an array or space-delimited list of paths that\n * are required (defaults to street1, suburb)\n *\n * @api public\n */\n\nlocation.prototype.validateInput = function(data, required, item) {\n\n\tif (!required) {\n\t\treturn true;\n\t}\n\n\tvar paths = this.paths,\n\t\tnested = this._path.get(data),\n\t\tvalues = nested || data,\n\t\tvalid = true;\n\n\tthis.requiredPaths.forEach(function(path) {\n\n\t\tif (nested) {\n\t\t\tif (!(path in values) && item && item.get(paths[path])) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!values[path]) {\n\t\t\t\tvalid = false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(paths[path] in values) && item && item.get(paths[path])) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!values[paths[path]]) {\n\t\t\t\tvalid = false;\n\t\t\t}\n\t\t}\n\n\t});\n\n\treturn valid;\n\n};\n\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * @api public\n */\n\nlocation.prototype.updateItem = function(item, data) {\n\n\tvar paths = this.paths,\n\t\tfieldKeys = ['number', 'name', 'street1', 'street2', 'suburb', 'state', 'postcode', 'country'],\n\t\tgeoKeys = ['geo', 'geo_lat', 'geo_lng'],\n\t\tvalueKeys = fieldKeys.concat(geoKeys),\n\t\tvaluePaths = valueKeys,\n\t\tvalues = this._path.get(data);\n\n\tif (!values) {\n\t\t// Handle flattened values\n\t\tvaluePaths = valueKeys.map(function(i) {\n\t\t\treturn paths[i];\n\t\t});\n\t\tvalues = _.pick(data, valuePaths);\n\t}\n\n\t// convert valuePaths to a map for easier usage\n\tvaluePaths = _.object(valueKeys, valuePaths);\n\n\tvar setValue = function(key) {\n\t\tif (valuePaths[key] in values && values[valuePaths[key]] !== item.get(paths[key])) {\n\t\t\titem.set(paths[key], values[valuePaths[key]] || null);\n\t\t}\n\t};\n\n\t_.each(fieldKeys, setValue);\n\n\tif (valuePaths.geo in values) {\n\n\t\tvar oldGeo = item.get(paths.geo) || [];\n\t\tif (oldGeo.length > 1) {\n\t\t\toldGeo[0] = item.get(paths.geo)[1];\n\t\t\toldGeo[1] = item.get(paths.geo)[0];\n\t\t}\n\t\tvar newGeo = values[valuePaths.geo];\n\n\t\tif (!Array.isArray(newGeo) || newGeo.length !== 2) {\n\t\t\tnewGeo = [];\n\t\t}\n\n\t\tif (newGeo[0] !== oldGeo[0] || newGeo[1] !== oldGeo[1]) {\n\t\t\titem.set(paths.geo, newGeo);\n\t\t}\n\n\t} else if (valuePaths.geo_lat in values && valuePaths.geo_lng in values) {\n\n\t\tvar lat = utils.number(values[valuePaths.geo_lat]),\n\t\t\tlng = utils.number(values[valuePaths.geo_lng]);\n\n\t\titem.set(paths.geo, (lat && lng) ? [lng, lat] : undefined);\n\n\t}\n\n};\n\n\n/**\n * Returns a callback that handles a standard form submission for the field\n *\n * Handles:\n * - `field.paths.improve` in `req.body` - improves data via `.googleLookup()`\n * - `field.paths.overwrite` in `req.body` - in conjunction with `improve`, overwrites existing data\n *\n * @api public\n */\n\nlocation.prototype.getRequestHandler = function(item, req, paths, callback) {\n\n\tvar field = this;\n\n\tif (utils.isFunction(paths)) {\n\t\tcallback = paths;\n\t\tpaths = field.paths;\n\t} else if (!paths) {\n\t\tpaths = field.paths;\n\t}\n\n\tcallback = callback || function() {};\n\n\treturn function() {\n\n\t\tvar update = req.body[paths.overwrite] ? 'overwrite' : true;\n\n\t\tif (req.body && req.body[paths.improve]) {\n\t\t\tfield.googleLookup(item, false, update, function() {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\n\t};\n\n};\n\n\n/**\n * Immediately handles a standard form submission for the field (see `getRequestHandler()`)\n *\n * @api public\n */\n\nlocation.prototype.handleRequest = function(item, req, paths, callback) {\n\tthis.getRequestHandler(item, req, paths, callback)();\n};\n\n\n/**\n * Internal Google geocode request method\n *\n * @api private\n */\n\nfunction doGoogleGeocodeRequest(address, region, callback) {\n\n\t// https://developers.google.com/maps/documentation/geocoding/\n\t// Use of the Google Geocoding API is subject to a query limit of 2,500 geolocation requests per day, except with an enterprise license.\n\t// Note: the Geocoding API may only be used in conjunction with a Google map; geocoding results without displaying them on a map is prohibited.\n\t// Please make sure your Keystone app complies with the Google Maps API License.\n\n\tvar options = {\n\t\tsensor: false,\n\t\tlanguage: 'en',\n\t\taddress: address\n\t};\n\n\tif (arguments.length === 2 && _.isFunction(region)) {\n\t\tcallback = region;\n\t\tregion = null;\n\t}\n\n\tif (region) {\n\t\toptions.region = region;\n\t}\n\n\tif (keystone.get('google server api key')){\n\t\toptions.key = keystone.get('google server api key');\n\t}\n\n\tvar endpoint = 'https://maps.googleapis.com/maps/api/geocode/json?' + querystring.stringify(options);\n\n\thttps.get(endpoint, function(res) {\n\t\tvar data = [];\n\t\tres.on('data', function(chunk) {\n\t\t\t\tdata.push(chunk);\n\t\t\t})\n\t\t\t.on('end', function() {\n\t\t\t\tvar dataBuff = data.join('').trim();\n\t\t\t\tvar result;\n\t\t\t\ttry {\n\t\t\t\t\tresult = JSON.parse(dataBuff);\n\t\t\t\t}\n\t\t\t\tcatch (exp) {\n\t\t\t\t\tresult = { 'status_code': 500, 'status_text': 'JSON Parse Failed', 'status': 'UNKNOWN_ERROR' };\n\t\t\t\t}\n\t\t\t\tcallback(null, result);\n\t\t\t});\n\t})\n\t.on('error', function(err) {\n\t\tcallback(err);\n\t});\n}\n\n\n/**\n * Autodetect the full address and lat, lng from the stored value.\n *\n * Uses Google's Maps API and may only be used in conjunction with a Google map.\n * Geocoding results without displaying them on a map is prohibited.\n * Please make sure your Keystone app complies with the Google Maps API License.\n *\n * Internal status codes mimic the Google API status codes.\n *\n * @api private\n */\n\nlocation.prototype.googleLookup = function(item, region, update, callback) {\n\n\tif (_.isFunction(update)) {\n\t\tcallback = update;\n\t\tupdate = false;\n\t}\n\n\tvar field = this,\n\t\tstored = item.get(this.path),\n\t\taddress = item.get(this.paths.serialised);\n\n\tif (address.length === 0) {\n\t\treturn callback({ 'status_code': 500, 'status_text': 'No address to geocode', 'status': 'NO_ADDRESS' });\n\t}\n\n\tdoGoogleGeocodeRequest(address, region || keystone.get('default region'), function(err, geocode){\n\n\t\tif (err || geocode.status !== 'OK') {\n\t\t\treturn callback(err || new Error(geocode.status + ': ' + geocode.error_message));\n\t\t}\n\n\t\t// use the first result\n\t\t// if there were no results in the array, status would be ZERO_RESULTS\n\t\tvar result = geocode.results[0];\n\n\t\t// parse the address components into a location object\n\n\t\tvar location = {};\n\n\t\t_.each(result.address_components, function(val){\n\t\t\tif ( _.indexOf(val.types, 'street_number') >= 0 ) {\n\t\t\t\tlocation.street1 = location.street1 || [];\n\t\t\t\tlocation.street1.push(val.long_name);\n\t\t\t}\n\t\t\tif ( _.indexOf(val.types, 'route') >= 0 ) {\n\t\t\t\tlocation.street1 = location.street1 || [];\n\t\t\t\tlocation.street1.push(val.short_name);\n\t\t\t}\n\t\t\t// in some cases, you get suburb, city as locality - so only use the first\n\t\t\tif ( _.indexOf(val.types, 'locality') >= 0 && !location.suburb) {\n\t\t\t\tlocation.suburb = val.long_name;\n\t\t\t}\n\t\t\tif ( _.indexOf(val.types, 'administrative_area_level_1') >= 0 ) {\n\t\t\t\tlocation.state = val.short_name;\n\t\t\t}\n\t\t\tif ( _.indexOf(val.types, 'country') >= 0 ) {\n\t\t\t\tlocation.country = val.long_name;\n\t\t\t}\n\t\t\tif ( _.indexOf(val.types, 'postal_code') >= 0 ) {\n\t\t\t\tlocation.postcode = val.short_name;\n\t\t\t}\n\t\t});\n\n\t\tif (Array.isArray(location.street1)) {\n\t\t\tlocation.street1 = location.street1.join(' ');\n\t\t}\n\n\t\tlocation.geo = [\n\t\t\tresult.geometry.location.lng,\n\t\t\tresult.geometry.location.lat\n\t\t];\n\n\t\t//console.log('------ Google Geocode Results ------');\n\t\t//console.log(address);\n\t\t//console.log(result);\n\t\t//console.log(location);\n\n\t\tif (update === 'overwrite') {\n\t\t\titem.set(field.path, location);\n\t\t} else if (update) {\n\t\t\t_.each(location, function(value, key) {\n\t\t\t\tif (key === 'geo') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!stored[key]) {\n\t\t\t\t\titem.set(field.paths[key], value);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (!Array.isArray(stored.geo) || !stored.geo[0] || !stored.geo[1]) {\n\t\t\t\titem.set(field.paths.geo, location.geo);\n\t\t\t}\n\t\t}\n\n\t\tcallback(null, location, result);\n\n\t});\n};\n\n\n/**\n * Internal Distance calculation function\n *\n * See http://en.wikipedia.org/wiki/Haversine_formula\n *\n * @api private\n */\n\nfunction calculateDistance(point1, point2) {\n\n\tvar dLng = (point2[0] - point1[0]) * Math.PI / 180;\n\tvar dLat = (point2[1] - point1[1]) * Math.PI / 180;\n\tvar lat1 = (point1[1]) * Math.PI / 180;\n\tvar lat2 = (point2[1]) * Math.PI / 180;\n\n\t/* eslint-disable space-infix-ops */\n\tvar a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.sin(dLng/2) * Math.sin(dLng/2) * Math.cos(lat1) * Math.cos(lat2);\n\tvar c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\t/* eslint-enable space-infix-ops */\n\treturn c;\n\n}\n\n\n/**\n * Returns the distance from a [lat, lng] point in kilometres\n *\n * @api public\n */\n\nlocation.prototype.kmFrom = function(item, point) {\n\treturn calculateDistance(this.get(this.paths.geo), point) * RADIUS_KM;\n};\n\n\n/**\n * Returns the distance from a [lat, lng] point in miles\n *\n * @api public\n */\n\nlocation.prototype.milesFrom = function(item, point) {\n\treturn calculateDistance(this.get(this.paths.geo), point) * RADIUS_MILES;\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = location;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/markdown/MarkdownType.js":"/*!\n * Module dependencies.\n */\n\nvar util = require('util'),\n\tmarked = require('marked'),\n\tsuper_ = require('../Type');\n\n/**\n * Markdown FieldType Constructor\n * @extends Field\n * @api public\n */\n\nfunction markdown(list, path, options) {\n\t\n\tthis._defaultSize = 'full';\n\t\n\t// TODO: implement filtering, usage disabled for now\n\toptions.nofilter = true;\n\n\tthis.toolbarOptions = options.toolbarOptions || {};\n\tthis.height = options.height || 90;\n\n\t// since wysiwyg option can be falsey this needs to use `in` instead of ||\n\tthis.wysiwyg = ('wysiwyg' in options) ? options.wysiwyg : true;\n\n\tthis._properties = ['wysiwyg', 'height', 'toolbarOptions'];\n\n\tmarkdown.super_.call(this, list, path, options);\n\n}\n\n/*!\n * Inherit from Field\n */\n\nutil.inherits(markdown, super_);\n\n\n/**\n * Registers the field on the List's Mongoose Schema.\n *\n * Adds String properties for .markdown and .html markdown, and a setter\n * for .markdown that generates html when it is updated.\n *\n * @api public\n */\n\nmarkdown.prototype.addToSchema = function() {\n\n\tvar schema = this.list.schema;\n\n\tvar paths = this.paths = {\n\t\tmd: this._path.append('.md'),\n\t\thtml: this._path.append('.html')\n\t};\n\n\tvar setMarkdown = function(value) {\n\n\t\tif (value === this.get(paths.md)) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.set(paths.html, marked(value));\n\t\t\treturn value;\n\t\t} else {\n\t\t\tthis.set(paths.html, undefined);\n\t\t\treturn undefined;\n\t\t}\n\n\t};\n\n\tschema.nested[this.path] = true;\n\tschema.add({\n\t\thtml: { type: String },\n\t\tmd: { type: String, set: setMarkdown }\n\t}, this.path + '.');\n\n\tthis.bindUnderscoreMethods();\n};\n\n\n/**\n * Formats the field value\n *\n * @api public\n */\n\nmarkdown.prototype.format = function(item) {\n\treturn item.get(this.paths.html);\n};\n\n\n/**\n * Validates that a value for this field has been provided in a data object\n *\n * Will accept either the field path, or paths.md\n *\n * @api public\n */\n\nmarkdown.prototype.validateInput = function(data, required, item) {\n\tif (!(this.path in data || this.paths.md in data) && item && item.get(this.paths.md)) {\n\t\treturn true;\n\t}\n\treturn (!required || data[this.path] || data[this.paths.md]) ? true : false;\n};\n\n\n/**\n * Detects whether the field has been modified\n *\n * @api public\n */\n\nmarkdown.prototype.isModified = function(item) {\n\treturn item.isModified(this.paths.md);\n};\n\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * Will accept either the field path, or paths.md\n *\n * @api public\n */\n\nmarkdown.prototype.updateItem = function(item, data) {\n\tvar value = this.getValueFromData(data);\n\tif (value !== undefined) {\n\t\titem.set(this.paths.md, value);\n\t} else if (this.paths.md in data) {\n\t\titem.set(this.paths.md, data[this.paths.md]);\n\t}\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = markdown;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/money/MoneyType.js":"var FieldType = require('../Type');\nvar NumberType = require('../number/NumberType');\nvar numeral = require('numeral');\nvar util = require('util');\n\n/**\n * Money FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction money(list, path, options) {\n\tthis.currency = options.currency;\n\tthis._nativeType = Number;\n\tthis._underscoreMethods = ['format'];\n\tthis._properties = ['currency'];\n\tthis._fixedSize = 'small';\n\tthis._formatString = (options.format === false) ? false : (options.format || '$0,0.00');\n\tif (this._formatString && 'string' !== typeof this._formatString) {\n\t\tthrow new Error('FieldType.Money: options.format must be a string.');\n\t}\n\tmoney.super_.call(this, list, path, options);\n}\nutil.inherits(money, FieldType);\n\n/* Inherit from NumberType prototype */\nmoney.prototype.updateItem = NumberType.prototype.updateItem;\nmoney.prototype.validateInput = NumberType.prototype.validateInput;\n\n/**\n * Formats the field value\n */\nmoney.prototype.format = function(item, format) {\n\tif (this.currency) {\n\t\ttry {\n\t\t\tnumeral.language(this.currency, require('numeral/languages/' + this.currency));\n\t\t\tnumeral.language(this.currency);\n\t\t} catch (err) {\n\t\t\tthrow new Error('FieldType.Money: options.currency failed to load.');\n\t\t}\n\t}\n\tif (format || this._formatString) {\n\t\treturn ('number' === typeof item.get(this.path)) ? numeral(item.get(this.path)).format(format || this._formatString) : '';\n\t} else {\n\t\treturn item.get(this.path) || '';\n\t}\n};\n\n/* Export Field Type */\nexports = module.exports = money;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/number/NumberType.js":"var FieldType = require('../Type');\nvar numeral = require('numeral');\nvar util = require('util');\nvar utils = require('keystone-utils');\n\n/**\n * Number FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction number(list, path, options) {\n\tthis._nativeType = Number;\n\tthis._fixedSize = 'small';\n\tthis._underscoreMethods = ['format'];\n\tthis._formatString = (options.format === false) ? false : (options.format || '0,0[.][000000000000]');\n\tif (this._formatString && 'string' !== typeof this._formatString) {\n\t\tthrow new Error('FieldType.Number: options.format must be a string.');\n\t}\n\tnumber.super_.call(this, list, path, options);\n}\nutil.inherits(number, FieldType);\n\n/**\n * Add filters to a query\n */\nnumber.prototype.addFilterToQuery = function(filter, query) {\n\tquery = query || {};\n\tif (filter.mode === 'equals' && !filter.value) {\n\t\tquery[this.path] = filter.invert ? { $nin: ['', 0, null] } : { $in: ['', 0, null] };\n\t\treturn;\n\t}\n\tif (filter.mode === 'between') {\n\t\tvar min = utils.number(value.min);\n\t\tvar max = utils.number(value.max);\n\t\tif (!isNaN(min) && !isNaN(max)) {\n\t\t\tquery[this.path] = {\n\t\t\t\t$gte: min,\n\t\t\t\t$lte: max\n\t\t\t};\n\t\t}\n\t\treturn;\n\t}\n\tvar value = utils.number(filter.value);\n\tif (!isNaN(value)) {\n\t\tif (filter.mode === 'gt') {\n\t\t\tquery[this.path] = { $gt: value };\n\t\t}\n\t\telse if (filter.mode === 'lt') {\n\t\t\tquery[this.path] = { $lt: value };\n\t\t}\n\t\telse {\n\t\t\tquery[this.path] = value;\n\t\t}\n\t}\n\treturn query;\n};\n\n/**\n * Formats the field value\n */\nnumber.prototype.format = function(item, format) {\n\tif (format || this._formatString) {\n\t\treturn ('number' === typeof item.get(this.path)) ? numeral(item.get(this.path)).format(format || this._formatString) : '';\n\t} else {\n\t\treturn item.get(this.path) || '';\n\t}\n};\n\n/**\n * Checks that a valid number has been provided in a data object\n * An empty value clears the stored value and is considered valid\n */\nnumber.prototype.validateInput = function(data, required, item) {\n\tvar value = this.getValueFromData(data);\n\tif (value === undefined && item && (item.get(this.path) || item.get(this.path) === 0)) {\n\t\treturn true;\n\t}\n\tif (value !== undefined && value !== '') {\n\t\tvar newValue = utils.number(value);\n\t\treturn (!isNaN(newValue));\n\t} else {\n\t\treturn (required) ? false : true;\n\t}\n};\n\n/**\n * Updates the value for this field in the item from a data object\n */\nnumber.prototype.updateItem = function(item, data) {\n\tvar value = this.getValueFromData(data);\n\tif (value === undefined) {\n\t\treturn;\n\t}\n\tvar newValue = utils.number(value);\n\tif (!isNaN(newValue)) {\n\t\tif (newValue !== item.get(this.path)) {\n\t\t\titem.set(this.path, newValue);\n\t\t}\n\t} else if ('number' === typeof item.get(this.path)) {\n\t\titem.set(this.path, null);\n\t}\n};\n\n/* Export Field Type */\nexports = module.exports = number;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/name/NameType.js":"var _ = require('underscore');\nvar FieldType = require('../Type');\nvar util = require('util');\n\n/**\n * Name FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction name(list, path, options) {\n\tthis._fixedSize = 'large';\n\toptions.nofilter = true; // TODO: remove this when 0.4 is merged\n\tname.super_.call(this, list, path, options);\n}\nutil.inherits(name, FieldType);\n\n\n/**\n * Registers the field on the List's Mongoose Schema.\n *\n * Adds String properties for .first and .last name, and a virtual\n * with get() and set() methods for .full\n *\n * @api public\n */\n\nname.prototype.addToSchema = function() {\n\tvar schema = this.list.schema;\n\tvar paths = this.paths = {\n\t\tfirst: this._path.append('.first'),\n\t\tlast: this._path.append('.last'),\n\t\tfull: this._path.append('.full')\n\t};\n\n\tschema.nested[this.path] = true;\n\tschema.add({\n\t\tfirst: String,\n\t\tlast: String\n\t}, this.path + '.');\n\n\tschema.virtual(paths.full).get(function () {\n\t\treturn _.compact([this.get(paths.first), this.get(paths.last)]).join(' ');\n\t});\n\n\tschema.virtual(paths.full).set(function(value) {\n\t\tif (typeof value !== 'string') {\n\t\t\tthis.set(paths.first, undefined);\n\t\t\tthis.set(paths.last, undefined);\n\t\t\treturn;\n\t\t}\n\t\tvar split = value.split(' ');\n\t\tthis.set(paths.first, split.shift());\n\t\tthis.set(paths.last, split.join(' ') || undefined);\n\t});\n\n\tthis.bindUnderscoreMethods();\n};\n\n/**\n * Formats the field value\n */\n\nname.prototype.format = function(item) {\n\treturn item.get(this.paths.full);\n};\n\n/**\n * Validates that a value for this field has been provided in a data object\n */\nname.prototype.validateInput = function(data, required, item) {\n\t// Input is valid if none was provided, but the item has data\n\tif (!(this.path in data || this.paths.first in data || this.paths.last in data || this.paths.full in data) && item && item.get(this.paths.full)) return true;\n\t// Input is valid if the field is not required\n\tif (!required) return true;\n\t// Otherwise check for valid strings in the provided data,\n\t// which may be nested or use flattened paths.\n\tif (_.isObject(data[this.path])) {\n\t\treturn (data[this.path].full || data[this.path].first || data[this.path].last) ? true : false;\n\t} else {\n\t\treturn (data[this.paths.full] || data[this.paths.first] || data[this.paths.last]) ? true : false;\n\t}\n};\n\n/**\n * Detects whether the field has been modified\n *\n * @api public\n */\nname.prototype.isModified = function(item) {\n\treturn item.isModified(this.paths.first) || item.isModified(this.paths.last);\n};\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * @api public\n */\nname.prototype.updateItem = function(item, data) {\n\tif (!_.isObject(data)) return;\n\tvar paths = this.paths;\n\tvar setValue;\n\tif (this.path in data && _.isString(data[this.path])) {\n\t\t// Allow the root path as an alias to {path}.full\n\t\titem.set(paths.full, data[this.path]);\n\t} else if (this.path in data && _.isObject(data[this.path])) {\n\t\t// Allow a nested object like { path: { first: 'Jed' } }\n\t\tvar valueObj = data[this.path];\n\t\tsetValue = function(key) {\n\t\t\tif (key in valueObj && valueObj[key] !== item.get(paths[key])) {\n\t\t\t\titem.set(paths[key], valueObj[key]);\n\t\t\t}\n\t\t};\n\t} else {\n\t\t// Default to flattened paths like { 'path.first': 'Jed' }\n\t\tsetValue = function(key) {\n\t\t\tif (paths[key] in data && data[paths[key]] !== item.get(paths[key])) {\n\t\t\t\titem.set(paths[key], data[paths[key]]);\n\t\t\t}\n\t\t};\n\t}\n\tif (setValue) {\n\t\t_.each(['full', 'first', 'last'], setValue);\n\t}\n};\n\n\n/* Export Field Type */\nexports = module.exports = name;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/numberarray/NumberArrayType.js":"/*!\n * Module dependencies.\n */\n\nvar util = require('util'),\n\tnumeral = require('numeral'),\n\tutils = require('keystone-utils'),\n\tsuper_ = require('../Type');\n\n/**\n * Number FieldType Constructor\n * @extends Field\n * @api public\n */\n\nfunction numberarray(list, path, options) {\n\t\n\tthis._nativeType = [Number];\n\n\tthis._underscoreMethods = ['format'];\n\tthis._formatString = (options.format === false) ? false : (options.format || '0,0[.][000000000000]');\n\tthis._fixedSize = 'small';\n\t\n\tif (this._formatString && 'string' !== typeof this._formatString) {\n\t\tthrow new Error('FieldType.Number: options.format must be a string.');\n\t}\n\t\n\tnumberarray.super_.call(this, list, path, options);\n\t\n}\n\n/*!\n * Inherit from Field\n */\n\nutil.inherits(numberarray, super_);\n\n\n/**\n * Formats the field value\n *\n * @api public\n */\n\nnumberarray.prototype.format = function(item, format) {\n\tif (format || this._formatString) {\n\t\treturn ('number' === typeof item.get(this.path)) ? numeral(item.get(this.path)).format(format || this._formatString) : '';\n\t} else {\n\t\treturn item.get(this.path) || '';\n\t}\n};\n\n/**\n * Checks if a value is a valid number\n *\n * @api private\n */\n\nfunction isValidNumber(value) {\n\treturn !isNaN(utils.number(value));\n}\n\n/**\n * Checks that a valid array of number has been provided in a data object\n *\n * An empty value clears the stored value and is considered valid\n *\n * @api public\n */\n\nnumberarray.prototype.validateInput = function(data, required, item) {\n\tvar value = this.getValueFromData(data);\n\n\tif (required) {\n\t\tif (value === undefined && item && item.get(this.path) && item.get(this.path).length) {\n\t\t\treturn true;\n\t\t}\n\t\tif (value === undefined || !Array.isArray(value) || ('string' !== typeof value) || ('number' !== typeof value)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (Array.isArray(value) && !value.length) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif ('string' === typeof value) {\n\t\tif (!isValidNumber(value)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (Array.isArray(value)) {\n\t\tfor (var index = 0; index < value.length; index++) {\n\t\t\tif (!isValidNumber(value[index])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (value === undefined || Array.isArray(value) || ('string' === typeof value) || ('number' === typeof value));\n};\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * @api public\n */\n\n\nnumberarray.prototype.updateItem = function(item, data) {\n\tvar value = this.getValueFromData(data);\n\t\n\tif ('undefined' !== typeof value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tvar temp = value.filter(function(temp) {\n\t\t\t\tif (isValidNumber(temp)) {\n\t\t\t\t\treturn utils.number(temp);\n\t\t\t\t}\n\t\t\t});\n\t\t\tvalue = temp;\n\t\t}\n\t\tif (value === null) {\n\t\t\tvalue = [];\n\t\t}\n\t\tif ('string' === typeof value) {\n\t\t\tif (isValidNumber(value)) {\n\t\t\t\tvalue = [utils.number(value)];\n\t\t\t}\n\t\t}\n\t\tif ('number' === typeof value) {\n\t\t\tvalue = [value];\n\t\t}\n\t\tif (Array.isArray(value)) {\n\t\t\titem.set(this.path, value);\n\t\t}\n\t}\n\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = numberarray;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/password/PasswordType.js":"var _ = require('underscore');\nvar bcrypt = require('bcrypt-nodejs');\nvar FieldType = require('../Type');\nvar util = require('util');\n\n/**\n * password FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction password(list, path, options) {\n\tthis._nativeType = String;\n\tthis._underscoreMethods = ['format', 'compare'];\n\tthis._fixedSize = 'large';\n\t// You can't sort on password fields\n\toptions.nosort = true;\n\toptions.nofilter = true; // TODO: remove this when 0.4 is merged\n\tthis.workFactor = options.workFactor || 10;\n\tpassword.super_.call(this, list, path, options);\n}\nutil.inherits(password, FieldType);\n\n/**\n * Registers the field on the List's Mongoose Schema.\n *\n * Adds ...\n *\n * @api public\n */\npassword.prototype.addToSchema = function() {\n\tvar field = this;\n\tvar schema = this.list.schema;\n\tvar needs_hashing = '__' + field.path + '_needs_hashing';\n\n\tthis.paths = {\n\t\thash: this.options.hashPath || this._path.append('_hash'),\n\t\tconfirm: this.options.confirmPath || this._path.append('_confirm')\n\t};\n\n\tschema.path(this.path, _.defaults({\n\t\ttype: String,\n\t\tset: function(newValue) {\n\t\t\tthis[needs_hashing] = true;\n\t\t\treturn newValue;\n\t\t}\n\t}, this.options));\n\n\tschema.virtual(this.paths.hash).set(function(newValue) {\n\t\tthis.set(field.path, newValue);\n\t\tthis[needs_hashing] = false;\n\t});\n\n\tschema.pre('save', function(next) {\n\t\tif (!this.isModified(field.path) || !this[needs_hashing]) {\n\t\t\treturn next();\n\t\t}\n\t\tif (!this.get(field.path)) {\n\t\t\tthis.set(field.path, undefined);\n\t\t\treturn next();\n\t\t}\n\t\tvar item = this;\n        bcrypt.genSalt(field.workFactor, function(err, salt) {\n            if (err) {\n                return next(err);\n            }\n            bcrypt.hash(item.get(field.path), salt, function () {}, function(err, hash) {\n                if (err) {\n                    return next(err);\n                }\n                // override the cleartext password with the hashed one\n                item.set(field.path, hash);\n                // reset the [needs_hashing] flag so that new values can't be hashed more than once\n\t\t\t\t// (inherited models double up on pre save handlers for password fields)\n\t\t\t\titem[needs_hashing] = false;\n\n                next();\n            });\n        });\n\t});\n\tthis.bindUnderscoreMethods();\n};\n\n/**\n * Add filters to a query\n */\npassword.prototype.addFilterToQuery = function(filter, query) {\n\tquery = query || {};\n\tquery[this.path] = (filter.exists) ? { $ne: null } : null;\n\treturn query;\n};\n\n/**\n * Formats the field value\n *\n * Password fields are always formatted as a random no. of asterisks,\n * because the saved hash should never be displayed nor the length\n * of the actual password hinted at.\n *\n * @api public\n */\npassword.prototype.format = function(item) {\n\tif (!item.get(this.path)) return '';\n\tvar len = Math.round(Math.random() * 4) + 6;\n\tvar stars = '';\n\tfor (var i = 0; i < len; i++) stars += '*';\n\treturn stars;\n};\n\n/**\n * Compares\n *\n * @api public\n */\npassword.prototype.compare = function(item, candidate, callback) {\n\tif ('function' !== typeof callback) throw new Error('Password.compare() requires a callback function.');\n\tvar value = item.get(this.path);\n\tif (!value) return callback(null, false);\n\tbcrypt.compare(candidate, item.get(this.path), callback);\n};\n\n/**\n * If password fields are required, check that either a value has been\n * provided or already exists in the field.\n *\n * Otherwise, input is always considered valid, as providing an empty\n * value will not change the password.\n *\n * @api public\n */\npassword.prototype.validateInput = function(data, required, item) {\n\tif (data[this.path] && this.paths.confirm in data) {\n\t\treturn data[this.path] === data[this.paths.confirm] ? true : false;\n\t}\n\tif (data[this.path] || data[this.paths.hash] || (item && item.get(this.path))) return true;\n\treturn required ? false : true;\n};\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * Will accept either the field path, or paths.hash to bypass bcrypt\n *\n * @api public\n */\npassword.prototype.updateItem = function(item, data) {\n\tif (this.path in data) {\n\t\titem.set(this.path, data[this.path]);\n\t} else if (this.paths.hash in data) {\n\t\titem.set(this.paths.hash, data[this.paths.hash]);\n\t}\n};\n\n/* Export Field Type */\nexports = module.exports = password;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/relationship/RelationshipType.js":"var _ = require('underscore');\nvar FieldType = require('../Type');\nvar keystone = require('../../../');\nvar util = require('util');\nvar utils = require('keystone-utils');\n\n/**\n * Relationship FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction relationship(list, path, options) {\n\tthis.many = (options.many) ? true : false;\n\tthis.filters = options.filters;\n\tthis._defaultSize = this.many ? 'full' : 'large';\n\tthis._nativeType = keystone.mongoose.Schema.Types.ObjectId;\n\tthis._underscoreMethods = ['format'];\n\tthis._properties = ['isValid', 'many', 'filters'];\n\trelationship.super_.call(this, list, path, options);\n}\nutil.inherits(relationship, FieldType);\n\n/**\n * Get client-side properties to pass to react field.\n */\nrelationship.prototype.getProperties = function () {\n\tvar refList = this.refList;\n\treturn {\n\t\trefList: {\n\t\t\tsingular: refList.singular,\n\t\t\tplural:   refList.plural,\n\t\t\tpath:     refList.path\n\t\t}\n\t};\n};\n\n/**\n * Registers the field on the List's Mongoose Schema.\n */\nrelationship.prototype.addToSchema = function() {\n\tvar field = this;\n\tvar schema = this.list.schema;\n\tvar def = {\n\t\ttype: this._nativeType,\n\t\tref: this.options.ref,\n\t\tindex: (this.options.index ? true : false),\n\t\trequired: (this.options.required ? true : false),\n\t\tunique: (this.options.unique ? true : false)\n\t};\n\tthis.paths = {\n\t\trefList: this.options.refListPath || this._path.append('RefList')\n\t};\n\tschema.path(this.path, this.many ? [def] : def);\n\tschema.virtual(this.paths.refList).get(function () {\n\t\treturn keystone.list(field.options.ref);\n\t});\n\tif (this.many) {\n\t\tthis.underscoreMethod('contains', function(find) {\n\t\t\tvar value = this.populated(field.path) || this.get(field.path);\n\t\t\tif ('object' === typeof find) {\n\t\t\t\tfind = find.id;\n\t\t\t}\n\t\t\tvar result = _.some(value, function(value) {\n\t\t\t\treturn (value + '' === find);\n\t\t\t});\n\t\t\treturn result;\n\t\t});\n\t}\n\tthis.bindUnderscoreMethods();\n};\n\n/**\n * Add filters to a query\n */\nrelationship.prototype.addFilterToQuery = function(filter, query) {\n\tquery = query || {};\n\tif (this.many) {\n\t\tif (filter.value) {\n\t\t\tquery[this.path] = (filter.inverse) ? { $nin: [filter.value] } : { $in: [filter.value] };\n\t\t} else {\n\t\t\tquery[this.path] = (filter.inverse) ? { $not: { $size: 0 } } : { $size: 0 };\n\t\t}\n\t} else {\n\t\tif (filter.value) {\n\t\t\tquery[this.path] = (filter.inverse) ? { $ne: filter.value } : filter.value;\n\t\t} else {\n\t\t\tquery[this.path] = (filter.inverse) ? { $ne: null } : null;\n\t\t}\n\t}\n\treturn query;\n};\n\n/**\n * Formats the field value\n */\nrelationship.prototype.format = function(item) {\n\tvar value = item.get(this.path);\n\t// force the formatted value to be a string - unexpected things happen with ObjectIds.\n\treturn this.many ? value.join(', ') : (value || '') + '';\n};\n\n/**\n * Validates that a value for this field has been provided in a data object\n */\nrelationship.prototype.validateInput = function(data, required, item) {\n\tif (!required) return true;\n\tif (!(this.path in data) && item && ((this.many && item.get(this.path).length) || item.get(this.path))) return true;\n\tif ('string' === typeof data[this.path]) {\n\t\treturn (data[this.path].trim()) ? true : false;\n\t} else {\n\t\treturn (data[this.path]) ? true : false;\n\t}\n};\n\n/**\n * Updates the value for this field in the item from a data object.\n * Only updates the value if it has changed.\n * Treats an empty string as a null value.\n */\nrelationship.prototype.updateItem = function(item, data) {\n\tif (!(this.path in data)) {\n\t\treturn;\n\t}\n\tif (item.populated(this.path)) {\n\t\tthrow new Error('fieldTypes.relationship.updateItem() Error - You cannot update populated relationships.');\n\t}\n\tif (this.many) {\n\t\tvar arr = item.get(this.path);\n\t\tvar _old = arr.map(function(i) { return String(i); });\n\t\tvar _new = data[this.path];\n\t\tif (!utils.isArray(_new)) {\n\t\t\t_new = String(_new || '').split(',');\n\t\t}\n\t\t_new = _.compact(_new);\n\t\t// Only update if the lists aren't the same\n\t\tif (!_.isEqual(_old, _new)) {\n\t\t\titem.set(this.path, _new);\n\t\t}\n\t} else {\n\t\tif (data[this.path]) {\n\t\t\tif (data[this.path] !== item.get(this.path)) {\n\t\t\t\titem.set(this.path, data[this.path]);\n\t\t\t}\n\t\t} else if (item.get(this.path)) {\n\t\t\titem.set(this.path, null);\n\t\t}\n\t}\n};\n\n/**\n * Returns true if the relationship configuration is valid\n */\nObject.defineProperty(relationship.prototype, 'isValid', {\n\tget: function() {\n\t\treturn keystone.list(this.options.ref) ? true : false;\n\t}\n});\n\n/**\n * Returns the Related List\n */\nObject.defineProperty(relationship.prototype, 'refList', {\n\tget: function() {\n\t\treturn keystone.list(this.options.ref);\n\t}\n});\n\n/**\n * Whether the field has any filters defined\n */\nObject.defineProperty(relationship.prototype, 'hasFilters', {\n\tget: function() {\n\t\treturn (this.filters && _.keys(this.filters).length);\n\t}\n});\n\n/**\n * Adds relationship filters to a query\n */\n// TODO: Deprecate this? Not sure it's used anywhere - JW\nrelationship.prototype.addFilters = function(query, item) {\n\t_.each(this.filters, function(filters, path) {\n\t\tif (!utils.isObject(filters)) {\n\t\t\tfilters = { equals: filters };\n\t\t}\n\t\tquery.where(path);\n\t\t_.each(filters, function(value, method) {\n\t\t\tif ('string' === typeof value && value.substr(0, 1) === ':') {\n\t\t\t\tif (!item) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvalue = item.get(value.substr(1));\n\t\t\t}\n\t\t\tquery[method](value);\n\t\t});\n\t});\n};\n\n/* Export Field Type */\nexports = module.exports = relationship;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/s3file/S3FileType.js":"/*!\n * Module dependencies.\n */\n\nvar _ = require('underscore'),\n\tmoment = require('moment'),\n\tkeystone = require('../../../'),\n\tutil = require('util'),\n\tknox = require('knox'),\n\t// s3 = require('s3'),\n\tutils = require('keystone-utils'),\n\tgrappling = require('grappling-hook'),\n\tsuper_ = require('../Type');\n\n/**\n * S3File FieldType Constructor\n * @extends Field\n * @api public\n */\n\nfunction s3file(list, path, options) {\n\tgrappling.mixin(this)\n\t\t.allowHooks('pre:upload');\n\tthis._underscoreMethods = ['format', 'uploadFile'];\n\tthis._fixedSize = 'full';\n\n\t// TODO: implement filtering, usage disabled for now\n\toptions.nofilter = true;\n\n\t// TODO: implement initial form, usage disabled for now\n\tif (options.initial) {\n\t\tthrow new Error('Invalid Configuration\\n\\n' +\n\t\t\t'S3File fields (' + list.key + '.' + path + ') do not currently support being used as initial fields.\\n');\n\t}\n\n\ts3file.super_.call(this, list, path, options);\n\n\t// validate s3 config (has to happen after super_.call)\n\tif (!this.s3config) {\n\t\tthrow new Error('Invalid Configuration\\n\\n' +\n\t\t\t'S3File fields (' + list.key + '.' + path + ') require the \"s3 config\" option to be set.\\n\\n' +\n\t\t\t'See http://keystonejs.com/docs/configuration/#services-amazons3 for more information.\\n');\n\t}\n\n\t// Could be more pre- hooks, just upload for now\n\tif (options.pre && options.pre.upload) {\n\t\tthis.pre('upload', options.pre.upload);\n\t}\n\n}\n\n/*!\n * Inherit from Field\n */\n\nutil.inherits(s3file, super_);\n\n/**\n * Exposes the custom or keystone s3 config settings\n */\n\nObject.defineProperty(s3file.prototype, 's3config', {\n\tget: function() {\n\t\treturn this.options.s3config || keystone.get('s3 config');\n\t}\n});\n\n\n/**\n * Registers the field on the List's Mongoose Schema.\n *\n * @api public\n */\n\ns3file.prototype.addToSchema = function() {\n\n\tvar field = this,\n\t\tschema = this.list.schema;\n\n\tvar paths = this.paths = {\n\t\t// fields\n\t\tfilename:   this._path.append('.filename'),\n\t\toriginalname: this._path.append('.originalname'),\n\t\tpath:     this._path.append('.path'),\n\t\tsize:     this._path.append('.size'),\n\t\tfiletype:   this._path.append('.filetype'),\n\t\turl:      this._path.append('.url'),\n\t\t// virtuals\n\t\texists:     this._path.append('.exists'),\n\t\tupload:     this._path.append('_upload'),\n\t\taction:     this._path.append('_action')\n\t};\n\n\tvar schemaPaths = this._path.addTo({}, {\n\t\tfilename:   String,\n\t\toriginalname: String,\n\t\tpath:     String,\n\t\tsize:     Number,\n\t\tfiletype:   String,\n\t\turl:      String\n\t});\n\n\tschema.add(schemaPaths);\n\n\tvar exists = function(item) {\n\t\treturn (item.get(paths.url) ? true : false);\n\t};\n\n\t// The .exists virtual indicates whether a file is stored\n\tschema.virtual(paths.exists).get(function() {\n\t\treturn schemaMethods.exists.apply(this);\n\t});\n\n\tvar reset = function(item) {\n\t\titem.set(field.path, {\n\t\t\tfilename: '',\n\t\t\toriginalname: '',\n\t\t\tpath: '',\n\t\t\tsize: 0,\n\t\t\tfiletype: '',\n\t\t\turl: ''\n\t\t});\n\t};\n\n\tvar schemaMethods = {\n\t\texists: function() {\n\t\t\treturn exists(this);\n\t\t},\n\t\t/**\n\t\t * Resets the value of the field\n\t\t *\n\t\t * @api public\n\t\t */\n\t\treset: function() {\n\t\t\treset(this);\n\t\t},\n\t\t/**\n\t\t * Deletes the file from S3File and resets the field\n\t\t *\n\t\t * @api public\n\t\t */\n\t\tdelete: function() {\n\t\t\ttry {\n\t\t\t\tvar client = knox.createClient(field.s3config);\n\t\t\t\tclient.deleteFile(this.get(paths.path) + this.get(paths.filename), function(err, res){ return res ? res.resume() : false; });//eslint-disable-line handle-callback-err\n\t\t\t} catch(e) {}// eslint-disable-line no-empty\n\t\t\treset(this);\n\t\t}\n\t};\n\n\t_.each(schemaMethods, function(fn, key) {\n\t\tfield.underscoreMethod(key, fn);\n\t});\n\n\t// expose a method on the field to call schema methods\n\tthis.apply = function(item, method) {\n\t\treturn schemaMethods[method].apply(item, Array.prototype.slice.call(arguments, 2));\n\t};\n\n\tthis.bindUnderscoreMethods();\n};\n\n\n/**\n * Formats the field value\n *\n * @api public\n */\n\ns3file.prototype.format = function(item) {\n\tif (this.hasFormatter()) {\n\t\treturn this.options.format(item, item[this.path]);\n\t}\n\treturn item.get(this.paths.url);\n};\n\n\n/**\n * Detects the field have formatter function\n *\n * @api public\n */\n\ns3file.prototype.hasFormatter = function() {\n\treturn 'function' === typeof this.options.format;\n};\n\n\n/**\n * Detects whether the field has been modified\n *\n * @api public\n */\n\ns3file.prototype.isModified = function(item) {\n\treturn item.isModified(this.paths.url);\n};\n\n\n/**\n * Validates that a value for this field has been provided in a data object\n *\n * @api public\n */\n\ns3file.prototype.validateInput = function(data) {//eslint-disable-line no-unused-vars\n\t// TODO - how should file field input be validated?\n\treturn true;\n};\n\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * @api public\n */\n\n// s3file.prototype.updateItem = function(item, data) {//eslint-disable-line no-unused-vars\n\t// TODO - direct updating of data (not via upload)\n\t// commented out for now so super's updateItem will be called and S3FileType can be seeded with an application update\n// };\n\n\n/**\n * Validates a header option value provided for this item, throwing an error otherwise\n * @param header {Object} the header object to validate\n * @param callback {Function} a callback function to call when validation is complete\n * @return {Boolean}\n * @api private\n */\n\nvar validateHeader = function(header, callback) {\n\tvar HEADER_NAME_KEY = 'name',\n\t\tHEADER_VALUE_KEY = 'value',\n\t\tvalidKeys = [HEADER_NAME_KEY, HEADER_VALUE_KEY],\n\t\tfilteredKeys;\n\n\tif (!_.has(header, HEADER_NAME_KEY)){\n\t\treturn callback(new Error('Unsupported Header option: missing required key \"' + HEADER_NAME_KEY + '\" in ' + JSON.stringify(header)));\n\t}\n\tif (!_.has(header, HEADER_VALUE_KEY)){\n\t\treturn callback(new Error('Unsupported Header option: missing required key \"' + HEADER_VALUE_KEY + '\" in ' + JSON.stringify(header)));\n\t}\n\n\tfilteredKeys = _.filter(_.keys(header), function (key){ return _.indexOf(validKeys, key) > -1; });\n\n\t_.each(filteredKeys, function (key){\n\t\tif (!_.isString(header[key])){\n\t\t\treturn callback(new Error('Unsupported Header option: value for ' + key + ' header must be a String ' + header[key].toString()));\n\t\t}\n\t});\n\n\treturn true;\n};\n\n\n/**\n * Convenience method to validate a headers object\n * @param headers {Object} the headers object to validate\n * @param callback {Function} a callback function to call when validation is complete\n * @return {Boolean}\n * @api private\n */\n\nvar validateHeaders = function(headers, callback) {\n\tvar _headers = [];\n\n\tif (!_.isObject(headers)){\n\t\treturn callback(new Error('Unsupported Header option: headers must be an Object ' + JSON.stringify(headers)));\n\t}\n\n\t_.each(headers, function (value, key){\n\t\t_headers.push({ name: key, value: value });\n\t});\n\n\t_.each(_headers, function (header){\n\t\tvalidateHeader(header, callback);\n\t});\n\n\treturn true;\n};\n\n\n/**\n * Generates a headers object for this item to use during upload\n * @param item {Object} the list item\n * @param file {Object} the uploaded file\n * @param callback {Function} a callback function to call when validation is complete\n * @return {Object}\n * @api public\n */\n\ns3file.prototype.generateHeaders = function (item, file, callback){\n\tvar field = this,\n\t\tfiletype = file.mimetype || file.type,\n\t\theaders = {\n\t\t\t'Content-Type': filetype,\n\t\t\t'x-amz-acl': 'public-read'\n\t\t},\n\t\tcustomHeaders = {},\n\t\theadersOption = {},\n\t\tcomputedHeaders,\n\t\tdefaultHeaders;\n\n\n\tif (_.has(field.s3config, 'default headers')){\n\t\tdefaultHeaders = field.s3config['default headers'];\n\t\tif (_.isArray(defaultHeaders)){\n\t\t\t_.each(defaultHeaders, function (header){\n\t\t\t\tvar _header = {};\n\t\t\t\tif (validateHeader(header, callback)){\n\t\t\t\t\t_header[header.name] = header.value;\n\t\t\t\t\tcustomHeaders = _.extend(customHeaders, _header);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (_.isObject(defaultHeaders)){\n\t\t\tcustomHeaders = _.extend(customHeaders, defaultHeaders);\n\t\t} else {\n\t\t\treturn callback(new Error('Unsupported Header option: defaults headers must be either an Object or Array ' + JSON.stringify(defaultHeaders)));\n\t\t}\n\t}\n\n\tif (field.options.headers){\n\t\theadersOption = field.options.headers;\n\n\t\tif (_.isFunction(headersOption)){\n\t\t\tcomputedHeaders = headersOption.call(field, item, file);\n\n\t\t\tif (_.isArray(computedHeaders)){\n\t\t\t\t_.each(computedHeaders, function (header){\n\t\t\t\t\tvar _header = {};\n\t\t\t\t\tif (validateHeader(header, callback)){\n\t\t\t\t\t\t_header[header.name] = header.value;\n\t\t\t\t\t\tcustomHeaders = _.extend(customHeaders, _header);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (_.isObject(computedHeaders)){\n\t\t\t\tcustomHeaders = _.extend(customHeaders, computedHeaders);\n\t\t\t} else {\n\t\t\t\treturn callback(new Error('Unsupported Header option: computed headers must be either an Object or Array ' + JSON.stringify(computedHeaders)));\n\t\t\t}\n\n\t\t} else if (_.isArray(headersOption)){\n\t\t\t_.each(headersOption, function (header){\n\t\t\t\tvar _header = {};\n\t\t\t\tif (validateHeader(header, callback)){\n\t\t\t\t\t_header[header.name] = header.value;\n\t\t\t\t\tcustomHeaders = _.extend(customHeaders, _header);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (_.isObject(headersOption)){\n\t\t\tcustomHeaders = _.extend(customHeaders, headersOption);\n\t\t}\n\t}\n\n\tif (validateHeaders(customHeaders, callback)){\n\t\theaders = _.extend(headers, customHeaders);\n\t}\n\n\treturn headers;\n\n};\n\n\n\n/**\n * Uploads the file for this field\n *\n * @api public\n */\n\ns3file.prototype.uploadFile = function(item, file, update, callback) {\n\n\tvar field = this,\n\t\tpath = field.options.s3path ? field.options.s3path + '/' : '',\n\t\tprefix = field.options.datePrefix ? moment().format(field.options.datePrefix) + '-' : '',\n\t\tfilename = prefix + file.name,\n\t\toriginalname = file.originalname,\n\t\tfiletype = file.mimetype || file.type,\n\t\theaders;\n\n\tif ('function' === typeof update) {\n\t\tcallback = update;\n\t\tupdate = false;\n\t}\n\n\tif (field.options.allowedTypes && !_.contains(field.options.allowedTypes, filetype)) {\n\t\treturn callback(new Error('Unsupported File Type: ' + filetype));\n\t}\n\n\tvar doUpload = function() {\n\n\t\tif ('function' === typeof field.options.path) {\n\t\t\tpath = field.options.path(item, path);\n\t\t}\n\n\t\tif ('function' === typeof field.options.filename) {\n\t\t\tfilename = field.options.filename(item, filename, originalname);\n\t\t}\n\n\t\theaders = field.generateHeaders(item, file, callback);\n\n\t\tknox.createClient(field.s3config).putFile(file.path, path + filename, headers, function(err, res) {\n\n\t\t\tif (err) return callback(err);\n\t\t\tif (res) {\n\t\t\t\tif (res.statusCode !== 200) {\n\t\t\t\t\treturn callback(new Error('Amazon returned Http Code: ' + res.statusCode));\n\t\t\t\t} else {\n\t\t\t\t\tres.resume();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar protocol = (field.s3config.protocol && field.s3config.protocol + ':') || '',\n\t\t\t\turl = res.req.url.replace(/^https?:/i, protocol);\n\n\t\t\tvar fileData = {\n\t\t\t\tfilename: filename,\n\t\t\t\toriginalname: originalname,\n\t\t\t\tpath: path,\n\t\t\t\tsize: file.size,\n\t\t\t\tfiletype: filetype,\n\t\t\t\turl: url\n\t\t\t};\n\n\t\t\tif (update) {\n\t\t\t\titem.set(field.path, fileData);\n\t\t\t}\n\n\t\t\tcallback(null, fileData);\n\n\t\t});\n\t};\n\n\tthis.callHook('pre:upload', item, file, function(err) {\n\t\tif (err) return callback(err);\n\t\tdoUpload();\n\t});\n\n};\n\n\n/**\n * Returns a callback that handles a standard form submission for the field\n *\n * Expected form parts are\n * - `field.paths.action` in `req.body` (`clear` or `delete`)\n * - `field.paths.upload` in `req.files` (uploads the file to s3file)\n *\n * @api public\n */\n\ns3file.prototype.getRequestHandler = function(item, req, paths, callback) {\n\n\tvar field = this;\n\n\tif (utils.isFunction(paths)) {\n\t\tcallback = paths;\n\t\tpaths = field.paths;\n\t} else if (!paths) {\n\t\tpaths = field.paths;\n\t}\n\n\tcallback = callback || function() {};\n\n\treturn function() {\n\n\t\tif (req.body) {\n\t\t\tvar action = req.body[paths.action];\n\n\t\t\tif (/^(delete|reset)$/.test(action)) {\n\t\t\t\tfield.apply(item, action);\n\t\t\t}\n\t\t}\n\n\t\tif (req.files && req.files[paths.upload] && req.files[paths.upload].size) {\n\t\t\treturn field.uploadFile(item, req.files[paths.upload], true, callback);\n\t\t}\n\n\t\treturn callback();\n\n\t};\n\n};\n\n\n/**\n * Immediately handles a standard form submission for the field (see `getRequestHandler()`)\n *\n * @api public\n */\n\ns3file.prototype.handleRequest = function(item, req, paths, callback) {\n\tthis.getRequestHandler(item, req, paths, callback)();\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = s3file;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/select/SelectType.js":"var _ = require('underscore');\nvar FieldType = require('../Type');\nvar util = require('util');\nvar utils = require('keystone-utils');\n\n/**\n * Select FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction select(list, path, options) {\n\tthis.ui = options.ui || 'select';\n\tthis.numeric = options.numeric ? true : false;\n\tthis._nativeType = (options.numeric) ? Number : String;\n\tthis._underscoreMethods = ['format'];\n\tthis._properties = ['ops', 'numeric'];\n\tif (typeof options.options === 'string') {\n\t\toptions.options = options.options.split(',');\n\t}\n\tif (!Array.isArray(options.options)) {\n\t\tthrow new Error('Select fields require an options array.');\n\t}\n\tthis.ops = options.options.map(function(i) {\n\t\tvar op = _.isString(i) ? { value: i.trim(), label: utils.keyToLabel(i) } : i;\n\t\tif (!_.isObject(op)) {\n\t\t\top = { label: '' + i, value: '' + i };\n\t\t}\n\t\tif (options.numeric && !_.isNumber(op.value)) {\n\t\t\top.value = Number(op.value);\n\t\t}\n\t\treturn op;\n\t});\n\t// undefined options.emptyOption defaults to true\n\tif (options.emptyOption === undefined) {\n\t\toptions.emptyOption = true;\n\t}\n\t// ensure this.emptyOption is a boolean\n\tthis.emptyOption = options.emptyOption ? true : false;\n\t// cached maps for options, labels and values\n\tthis.map = utils.optionsMap(this.ops);\n\tthis.labels = utils.optionsMap(this.ops, 'label');\n\tthis.values = _.pluck(this.ops, 'value');\n\tselect.super_.call(this, list, path, options);\n}\nutil.inherits(select, FieldType);\n\n/**\n * Registers the field on the List's Mongoose Schema.\n *\n * Adds a virtual for accessing the label of the selected value,\n * and statics to the Schema for converting a value to a label,\n * and retrieving all of the defined options.\n */\nselect.prototype.addToSchema = function() {\n\tvar field = this;\n\tvar schema = this.list.schema;\n\tthis.paths = {\n\t\tdata: this.options.dataPath || this._path.append('Data'),\n\t\tlabel: this.options.labelPath || this._path.append('Label'),\n\t\toptions: this.options.optionsPath || this._path.append('Options'),\n\t\tmap: this.options.optionsMapPath || this._path.append('OptionsMap')\n\t};\n\tschema.path(this.path, _.defaults({\n\t\ttype: this._nativeType,\n\t\tenum: this.values,\n\t\tset: function(val) {\n\t\t\treturn (val === '' || val === null || val === false) ? undefined : val;\n\t\t}\n\t}, this.options));\n\tschema.virtual(this.paths.data).get(function () {\n\t\treturn field.map[this.get(field.path)];\n\t});\n\tschema.virtual(this.paths.label).get(function () {\n\t\treturn field.labels[this.get(field.path)];\n\t});\n\tschema.virtual(this.paths.options).get(function() {\n\t\treturn field.ops;\n\t});\n\tschema.virtual(this.paths.map).get(function() {\n\t\treturn field.map;\n\t});\n\tthis.underscoreMethod('pluck', function(property, d) {\n\t\tvar option = this.get(field.paths.data);\n\t\treturn (option) ? option[property] : d;\n\t});\n\tthis.bindUnderscoreMethods();\n};\n\n/**\n * Retrieves a shallow clone of the options array\n */\nselect.prototype.cloneOps = function() {\n\treturn _.map(this.ops, _.clone);\n};\n\n/**\n * Retrieves a shallow clone of the options map\n */\nselect.prototype.cloneMap = function() {\n\treturn utils.optionsMap(this.ops, true);\n};\n\n/**\n * Add filters to a query\n */\nselect.prototype.addFilterToQuery = function(filter, query) {\n\tquery = query || {};\n\tif (filter.value) {\n\t\tquery[this.path] = (filter.invert) ? { $ne: filter.value } : filter.value;\n\t} else {\n\t\tquery[this.path] = (filter.inverse) ? { $nin: ['', null] } : { $in: ['', null] };\n\t}\n\treturn query;\n};\n\n/**\n * Validates that a valid option has been provided in a data object\n */\nselect.prototype.validateInput = function(data, required, item) {\n\tif (data[this.path]) {\n\t\treturn (data[this.path] in this.map) ? true : false;\n\t} else {\n\t\treturn (!required || (!(this.path in data) && item && item.get(this.path))) ? true : false;\n\t}\n};\n\n/**\n * Formats the field value\n */\nselect.prototype.format = function(item) {\n\treturn this.labels[item.get(this.path)];\n};\n\n/* Export Field Type */\nexports = module.exports = select;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/textarray/TextArrayType.js":"/*!\n * Module dependencies.\n */\n\nvar util = require('util'),\n\tsuper_ = require('../Type');\n\n/**\n * TextArray FieldType Constructor\n * @extends Field\n * @api public\n */\n\nfunction textarray(list, path, options) {\n\tthis._nativeType = [String];\n\n\ttextarray.super_.call(this, list, path, options);\n}\n\n/*!\n * Inherit from Field\n */\n\nutil.inherits(textarray, super_);\n\n/**\n * Validates that a value for this field has been provided in a data object\n *\n * @api public\n */\n\ntextarray.prototype.validateInput = function(data, required, item) {\n\tvar value = this.getValueFromData(data);\n\n\tif (required) {\n\t\tif (value === undefined && item && item.get(this.path) && item.get(this.path).length) {\n\t\t\treturn true;\n\t\t}\n\t\tif (value === undefined || !Array.isArray(value) || ('string' !== typeof value) || ('number' !== typeof value)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (Array.isArray(value) && !value.length) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn (value === undefined || Array.isArray(value) || ('string' === typeof value) || ('number' === typeof value));\n};\n\n/**\n * Updates the value for this field in the item from a data object\n *\n * @api public\n */\n\ntextarray.prototype.updateItem = function(item, data) {\n\tvar value = this.getValueFromData(data);\n\t\n\tif ('undefined' !== typeof value) {\n\t\tif (value === null) {\n\t\t\tvalue = [];\n\t\t}\n\t\tif ('string' === typeof value) {\n\t\t\tvalue = [value];\n\t\t}\n\t\tif ('number' === typeof value) {\n\t\t\tvalue = [value.toString()];\n\t\t}\n\t\tif (Array.isArray(value)) {\n\t\t\titem.set(this.path, value);\n\t\t}\n\t}\n};\n\n/*!\n * Export class\n */\n\nexports = module.exports = textarray;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/textarea/TextareaType.js":"var FieldType = require('../Type');\nvar TextType = require('../text/TextType');\nvar util = require('util');\nvar utils = require('keystone-utils');\n\n/**\n * Text FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction textarea(list, path, options) {\n\tthis._nativeType = String;\n\tthis._underscoreMethods = ['format', 'crop'];\n\tthis.height = options.height || 90;\n\tthis._properties = ['height'];\n\ttextarea.super_.call(this, list, path, options);\n}\nutil.inherits(textarea, FieldType);\n\n/* Inherit from TextType prototype */\ntextarea.prototype.addFilterToQuery = TextType.prototype.addFilterToQuery;\ntextarea.prototype.crop = TextType.prototype.crop;\n\n/**\n * Formats the field value\n * @api public\n */\ntextarea.prototype.format = function(item) {\n\treturn utils.textToHTML(item.get(this.path));\n};\n\n/* Export Field Type */\nexports = module.exports = textarea;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/fields/types/url/UrlType.js":"var FieldType = require('../Type');\nvar TextType = require('../text/TextType');\nvar util = require('util');\n\n/**\n * URL FieldType Constructor\n * @extends Field\n * @api public\n */\nfunction url(list, path, options) {\n\tthis._nativeType = String;\n\tthis._underscoreMethods = ['format'];\n\tthis._formatUrl = options.format || removeProtocolPrefix;\n\turl.super_.call(this, list, path, options);\n}\nutil.inherits(url, FieldType);\n\n/* Inherit from TextType prototype */\nurl.prototype.addFilterToQuery = TextType.prototype.addFilterToQuery;\n\n/**\n * Formats the field value using either a supplied format function or default\n * which strips the leading protocol from the value for simpler display\n */\nurl.prototype.format = function(item) {\n\tvar url = (item.get(this.path) || '');\n\treturn this._formatUrl(url);\n};\n\n/**\n * Remove the protocol prefix from url\n */\nfunction removeProtocolPrefix(url) {\n\treturn url.replace(/^[a-zA-Z]+\\:\\/\\//, '');\n}\n\n// TODO: Proper url validation\n\n/* Export Field Type */\nexports = module.exports = url;\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/gulpfile.js":"var browserify = require('browserify');\nvar git = require('gulp-git');\nvar gulp = require('gulp');\nvar source = require('vinyl-source-stream');\nvar streamify = require('gulp-streamify');\nvar uglify = require('gulp-uglify');\n\n/**\n * Build Tasks\n */\n\ngulp.task('build-packages', function() {\n\tvar packages = require('./admin/packages');\n\tvar b = browserify();\n\tpackages.forEach(function(i) { b.require(i); });\n\tb = b.bundle().pipe(source('packages.js'));\n\tif (process.env.NODE_ENV === 'production') {\n\t\tb.pipe(streamify(uglify()));\n\t}\n\treturn b.pipe(gulp.dest('./admin/public/js'));\n});\n\n/**\n * Release Tasks\n */\n\ngulp.task('publish:tag', function(done) {\n\tvar pkg = JSON.parse(require('fs').readFileSync('./package.json'));\n\tvar v = 'v' + pkg.version;\n\tvar message = 'Release ' + v;\n\n\tgit.tag(v, message, function (err) {\n\t\tif (err) throw err;\n\t\tgit.push('origin', v, function (err) {\n\t\t\tif (err) throw err;\n\t\t\tdone();\n\t\t});\n\t});\n});\n\ngulp.task('publish:npm', function(done) {\n\trequire('child_process')\n\t\t.spawn('npm', ['publish'], { stdio: 'inherit' })\n\t\t.on('close', done);\n});\n\ngulp.task('release', ['publish:tag', 'publish:npm']);\n\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/lib/updates.js":"var _ = require('underscore');\nvar async = require('async');\nvar fs = require('fs');\nvar keystone = require('../');\nvar mongoose = keystone.mongoose;\nvar path = require('path');\nvar semver = require('semver');\nvar utils = require('keystone-utils');\n\nvar _dashes_ = '------------------------------------------------';\n\n// Update Schema - automatically created and managed by Keystone when updates are used\nvar UpdateModel = new mongoose.Schema({\n\tkey: { type: String, index: true },\n\tappliedOn: { type: Date, default: Date.now }\n}, { collection: keystone.prefixModel('App_Update') });\nmongoose.model('App_Update', UpdateModel);\n\n// Apply method - loads the available updates and applies any that haven't been, in order\nexports.apply = function(callback) {\n\n\tvar Update = mongoose.model('App_Update');\n\tvar updateCount = 0;\n\tvar deferCount = 0;\n\tvar skipCount = 0;\n\n\tvar updatesPath = keystone.getPath('updates', 'updates');\n\n\t// logError is used to log errors before the process exits since it is more synchronous than console.error.  Using \n\t// console.error gets into race condition issues with process.exit, which has higher priority.\n\tvar logError = function() {\n\t\tfor (var i = 0, len = arguments.length; i < len; ++i) {\n\t\t\tprocess.stderr.write(arguments[i] + '\\n');\n\t\t}\n\t};\n\n\tvar applyUpdate = function(file, done) {\n\t\tUpdate.findOne({ key: file }, function(err, updateRecord) {\n\t\t\tif (err) {\n\t\t\t\tconsole.error('Error searching database for update ' + file + ':');\n\t\t\t\tconsole.dir(err);\n\t\t\t\tdone(err);\n\t\t\t} else if (!updateRecord) {\n\t\t\t\tvar update = require(path.join(updatesPath, file));\n\t\t\t\t// skip updates that export a falsy value\n\t\t\t\tif (!update) {\n\t\t\t\t\tskipCount++;\n\t\t\t\t\treturn done();\n\t\t\t\t}\n\t\t\t\t// auto-wrap create scripts for a friendlier shorthand syntax\n\t\t\t\tif (_.isObject(update.create)) {\n\t\t\t\t\tvar items = update.create,\n\t\t\t\t\t\tops = update.options || {};\n\t\t\t\t\tvar background_mode = update.__background__ ? ' (background mode) ' : '';\n\t\t\t\t\t\n\t\t\t\t\tupdate = function(done) {\n\t\t\t\t\t\tkeystone.createItems(items, ops, function(err, stats) {\n\t\t\t\t\t\t\tif (!err) {\n\t\t\t\t\t\t\t\tvar statsMsg = stats ? stats.message : '';\n\n\t\t\t\t\t\t\t\tconsole.log('\\n' + _dashes_,\n\t\t\t\t\t\t\t\t\t'\\n' + keystone.get('name') + ': Successfully applied update ' + file + background_mode + '.',\n\t\t\t\t\t\t\t\t\t'\\n' + statsMsg,\n\t\t\t\t\t\t\t\t\t'\\n');\n\t\t\t\t\t\t\t\tdone(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlogError('\\n' + _dashes_,\n\t\t\t\t\t\t\t\t\t'\\n' + keystone.get('name') + ': Update ' + file + background_mode + ' failed with errors:',\n\t\t\t\t\t\t\t\t\t'\\n' + err,\n\t\t\t\t\t\t\t\t\t'\\n');\n\n\t\t\t\t\t\t\t\t// give the logging some time to finish\n\t\t\t\t\t\t\t\tprocess.nextTick(function() {\n\t\t\t\t\t\t\t\t\tdone(err);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// ensure type\n\t\t\t\tif (!_.isFunction(update)) {\n\t\t\t\t\tconsole.log('\\nError in update file ./updates/' + file + '.js\\nUpdate files must export a function\\n');\n\t\t\t\t\tprocess.exit();\n\t\t\t\t}\n\t\t\t\t// if an update is deferred, don't process it\n\t\t\t\tif (update.__defer__) {\n\t\t\t\t\tdeferCount++;\n\t\t\t\t\treturn done();\n\t\t\t\t}\n\t\t\t\t// if there are deferred updates, don't process any subsequent ones\n\t\t\t\tif (deferCount) {\n\t\t\t\t\tskipCount++;\n\t\t\t\t\treturn done();\n\t\t\t\t}\n\t\t\t\tconsole.log(_dashes_ + '\\nApplying update ' + file + '...');\n\t\t\t\tif (update.__background__) {\n\t\t\t\t\tupdateCount++;\n\t\t\t\t\tupdate(function(err) {\n\t\t\t\t\t\tif (!err) {\n\t\t\t\t\t\t\tif (update.__commit__ !== false) {\n\t\t\t\t\t\t\t\tnew Update({ key: file }).save();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tdone();\n\t\t\t\t} else {\n\t\t\t\t\tupdate(function(err) {\n\t\t\t\t\t\tif (!err) {\n\t\t\t\t\t\t\tupdateCount++;\n\t\t\t\t\t\t\tif (update.__commit__ === false) {\n\t\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnew Update({ key: file }).save(done);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdone();\n\t\t\t}\n\t\t});\n\t};\n\n\tif (!fs.existsSync(updatesPath)) {\n\t\tconsole.log('\\nKeystoneJS Update Error:\\n\\n' +\n\t\t\t'An updates folder must exist in your project root to use automatic updates.\\n' +\n\t\t\t'If you want to use a custom path for your updates, set the `updates` option.\\n' +\n\t\t\t'If you don\\'t want to use updates, set the `auto update` option to `false`.\\n' +\n\t\t\t'See http://keystonejs.com/docs/configuration/#updates for more information.\\n');\n\t\tprocess.exit();\n\t}\n\n\tvar updates = fs.readdirSync(updatesPath)\n\t\t.map(function(i) {\n\t\t\t// exclude non-javascript or coffee files in the updates folder\n\t\t\treturn (path.extname(i) !== '.js' && path.extname(i) !== '.coffee') ? false : path.basename(i, '.js');\n\t\t}).filter(function(i) {\n\t\t\t// exclude falsy values and filenames that without a valid semver\n\t\t\treturn i && semver.valid(i.split('-')[0]);\n\t\t}).sort(function(a, b) {\n\t\t\t// exclude anything after a hyphen from the version number\n\t\t\treturn semver.compare(a.split('-')[0], b.split('-')[0]);\n\t\t});\n\n\tasync.eachSeries(updates, applyUpdate, function(err) {\n\t\tif (updateCount || deferCount || skipCount) {\n\t\t\tvar status = '';\n\t\t\tif (updateCount) {\n\t\t\t\tstatus += 'Successfully applied ' + utils.plural(updateCount, '* update');\n\t\t\t\tif (skipCount || deferCount) {\n\t\t\t\t\tstatus += ', ';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (deferCount) {\n\t\t\t\tstatus += 'Deferred ' + utils.plural(deferCount, '* update');\n\t\t\t\tif (skipCount) {\n\t\t\t\t\tstatus += ', ';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skipCount) {\n\t\t\t\tstatus += 'Skipped ' + utils.plural(skipCount, '* update');\n\t\t\t}\n\t\t\tstatus += '.';\n\t\t\tconsole.log(_dashes_ + '\\n' + status + '\\n' + _dashes_);\n\t\t}\n\t\tif (err) {\n\t\t\tvar errmsg = 'An error occurred applying updates, bailing on Keystone init.\\n\\nError details:';\n\t\t\tif (!(updateCount || deferCount || skipCount)) {\n\t\t\t\terrmsg = _dashes_ + '\\n' + errmsg;\n\t\t\t}\n\t\t\tlogError(errmsg);\n\t\t\tlogError(err);\n\t\t\t// wait till nextTick to exit so the trace completes.\n\t\t\tprocess.nextTick(function() {\n\t\t\t\tprocess.exit(1);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tcallback && callback();// eslint-disable-line no-unused-expressions\n\t});\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/node_modules/keystone/server/startLetsEncrypt.js":"/**\n * Configures and starts express server via Let's Encrypt.\n *\n * Events are fired during initialisation to allow customisation, including:\n *   - onHttpServerCreated\n *\n * consumed by lib/core/start.js\n *\n * @api private\n */\n\nvar async = require('async');\nvar http = require('http');\nvar https;\ntry {\n\t// Use spdy if available\n\thttps = require('spdy');\n} catch (e) {\n\thttps = require('https');\n}\nvar path = require('path');\nvar letsencrypt = require('letsencrypt-express');\nvar letsencryptDir = path.join(require('os').homedir(), 'letsencrypt', 'etc');\n\nfunction makeSslRedirect (app) {\n\treturn function sslRedirect (req, res) {\n\t\t// This runs outside Express, so use pure NodeJS only\n\t\tconst s = req.socket\n\t\tif (s && s.remoteAddress === '127.0.0.1' && s.localAddress === '127.0.0.1' && !req.headers['x-forwarded-for']) {\n\t\t\treturn app(req, res);\n\t\t} else {\n\t\t\tres.setHeader('Location', 'https://' + req.headers.host + req.url);\n\t\t\tres.statusCode = 302;\n\t\t\tres.end();\n\t\t}\n\t}\n}\n\nfunction autoRegister (domains, email) {\n\tif (!Array.isArray(domains)) {\n\t\tdomains = [domains];\n\t}\n\treturn function (hostname, approve) {\n\t\tif (domains.indexOf(hostname) !== -1) {\n\t\t\tconsole.warn(\"Keystone Let's Encrypt: Approving registration for \" + hostname);\n\t\t\tapprove(null, {\n\t\t\t\tdomains: domains,\n\t\t\t\temail: email,\n\t\t\t\tagreeTos: true,\n\t\t\t});\n\t\t} else {\n\t\t\tconsole.log(\"Keystone Let's Encrypt: Denying registration for \" + hostname);\n\t\t\tapprove('Nope.');\n\t\t}\n\t};\n}\nmodule.exports = function (keystone, app, callback) {\n\n\tvar name = keystone.get('name');\n\tvar host = keystone.get('host') || '0.0.0.0';\n\tvar port = keystone.get('port') || 3000;\n\tvar forceSsl = (keystone.get('ssl') === 'force');\n\tvar sslHost = keystone.get('ssl host') || host;\n\tvar sslPort = keystone.get('ssl port') || port + 1;\n\n\tvar options = keystone.get('letsencrypt');\n\tvar email = options.email;\n\tvar domains = options.domains;\n\tvar approveRegistration;\n\tif (options.register) {\n\t\tif (options.tos && email && domains) {\n\t\t\tapproveRegistration = autoRegister(domains, email);\n\t\t} else {\n\t\t\tcallback(\"For auto registation with Let's Encrypt you should agree to the TOS, provide domains and a domain owner email\");\n\t\t\treturn;\n\t\t}\n\t}\n\tvar instance = letsencrypt.create({\n\t\tconfigDir: options.configDir || letsencryptDir,\n\t\tonRequest: app,\n\t\tapproveRegistration: approveRegistration,\n\t\t// TODO handleRenewFailure\n\t});\n\n\tasync.parallel([\n\t\tfunction (done) {\n\t\t\tvar serve = (forceSsl) ? makeSslRedirect(app) : app;\n\t\t\tkeystone.httpServer = http.createServer(\n\t\t\t\tletsencrypt.createAcmeResponder(instance, serve)\n\t\t\t).listen(port, host, done);\n\t\t},\n\t\tfunction (done) {\n\t\t\tkeystone.httpsServer = https.createServer(\n\t\t\t\tinstance.httpsOptions,\n\t\t\t\tletsencrypt.createAcmeResponder(instance, app)\n\t\t\t).listen(sslPort, sslHost, done);\n\t\t},\n\t], \tfunction ready (err) {\n\t\tif (err) { return callback(err); }\n\n\t\tvar message = name + ' is ready on '\n\t\t+ 'http://' + host + ':' + port\n\t\t+ (forceSsl ? ' (SSL redirect)' : '')\n\t\t+ ' and ' + 'https://' + sslHost + ':' + sslPort;\n\t\tcallback(null, message);\n\t});\n\n};\n"}