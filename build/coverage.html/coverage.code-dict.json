{"/home/travis/build/npmtest/node-npmtest-keystone/test.js":"/* istanbul instrument in package npmtest_keystone */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-keystone/lib.npmtest_keystone.js":"/* istanbul instrument in package npmtest_keystone */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_keystone = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_keystone = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-keystone/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-keystone && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_keystone */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_keystone\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_keystone.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_keystone.rollup.js'] =\n            local.assetsDict['/assets.npmtest_keystone.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_keystone.__dirname +\n                    '/lib.npmtest_keystone.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/index.js":"var _ = require('underscore');\nvar express = require('express');\nvar fs = require('fs');\nvar grappling = require('grappling-hook');\nvar path = require('path');\nvar utils = require('keystone-utils');\n\n/**\n * Don't use process.cwd() as it breaks module encapsulation\n * Instead, let's use module.parent if it's present, or the module itself if there is no parent (probably testing keystone directly if that's the case)\n * This way, the consuming app/module can be an embedded node_module and path resolutions will still work\n * (process.cwd() breaks module encapsulation if the consuming app/module is itself a node_module)\n */\nvar moduleRoot = (function(_rootPath) {\n\tvar parts = _rootPath.split(path.sep);\n\tparts.pop(); //get rid of /node_modules from the end of the path\n\treturn parts.join(path.sep);\n})(module.parent ? module.parent.paths[0] : module.paths[0]);\n\n\n/**\n * Keystone Class\n *\n * @api public\n */\nvar Keystone = function() {\n\tgrappling.mixin(this).allowHooks('pre:static', 'pre:bodyparser', 'pre:session', 'pre:routes', 'pre:render', 'updates', 'signout', 'signin', 'pre:logger');\n\tthis.lists = {};\n\tthis.paths = {};\n\tthis._options = {\n\t\t'name': 'Keystone',\n\t\t'brand': 'Keystone',\n\t\t'compress': true,\n\t\t'headless': false,\n\t\t'logger': ':method :url :status :response-time ms',\n\t\t'auto update': false,\n\t\t'model prefix': null,\n\t\t'module root': moduleRoot,\n\t\t'frame guard': 'sameorigin'\n\t};\n\tthis._redirects = {};\n\n\t// expose express\n\tthis.express = express;\n\n\t// init environment defaults\n\tthis.set('env', process.env.NODE_ENV || 'development');\n\n\tthis.set('port', process.env.PORT || process.env.OPENSHIFT_NODEJS_PORT);\n\tthis.set('host', process.env.HOST || process.env.IP || process.env.OPENSHIFT_NODEJS_IP);\n\tthis.set('listen', process.env.LISTEN);\n\n\tthis.set('ssl', process.env.SSL);\n\tthis.set('ssl port', process.env.SSL_PORT);\n\tthis.set('ssl host', process.env.SSL_HOST || process.env.SSL_IP);\n\tthis.set('ssl key', process.env.SSL_KEY);\n\tthis.set('ssl cert', process.env.SSL_CERT);\n\n\tthis.set('cookie secret', process.env.COOKIE_SECRET);\n\tthis.set('cookie signin', (this.get('env') === 'development') ? true : false);\n\n\tthis.set('embedly api key', process.env.EMBEDLY_API_KEY || process.env.EMBEDLY_APIKEY);\n\tthis.set('mandrill api key', process.env.MANDRILL_API_KEY || process.env.MANDRILL_APIKEY);\n\tthis.set('mandrill username', process.env.MANDRILL_USERNAME);\n\tthis.set('google api key', process.env.GOOGLE_BROWSER_KEY);\n\tthis.set('google server api key', process.env.GOOGLE_SERVER_KEY);\n\tthis.set('ga property', process.env.GA_PROPERTY);\n\tthis.set('ga domain', process.env.GA_DOMAIN);\n\tthis.set('chartbeat property', process.env.CHARTBEAT_PROPERTY);\n\tthis.set('chartbeat domain', process.env.CHARTBEAT_DOMAIN);\n\tthis.set('allowed ip ranges', process.env.ALLOWED_IP_RANGES);\n\n\tif (process.env.S3_BUCKET && process.env.S3_KEY && process.env.S3_SECRET) {\n\t\tthis.set('s3 config', { bucket: process.env.S3_BUCKET, key: process.env.S3_KEY, secret: process.env.S3_SECRET, region: process.env.S3_REGION });\n\t}\n\n\tif (process.env.AZURE_STORAGE_ACCOUNT && process.env.AZURE_STORAGE_ACCESS_KEY) {\n\t\tthis.set('azurefile config', { account: process.env.AZURE_STORAGE_ACCOUNT, key: process.env.AZURE_STORAGE_ACCESS_KEY });\n\t}\n\n\tif (process.env.CLOUDINARY_URL) {\n\t\t// process.env.CLOUDINARY_URL is processed by the cloudinary package when this is set\n\t\tthis.set('cloudinary config', true);\n\t}\n\n\t// Attach middleware packages, bound to this instance\n\tthis.middleware = {\n\t\tapi: require('./lib/middleware/api')(this),\n\t\tcors: require('./lib/middleware/cors')(this)\n\t};\n};\n\n_.extend(Keystone.prototype, require('./lib/core/options')());\n\n\nKeystone.prototype.prefixModel = function (key) {\n\tvar modelPrefix = this.get('model prefix');\n\n\tif (modelPrefix) {\n\t\tkey = modelPrefix + '_' + key;\n\t}\n\n\treturn require('mongoose/lib/utils').toCollectionName(key);\n};\n\n/* Attach core functionality to Keystone.prototype */\nKeystone.prototype.bindEmailTestRoutes = require('./lib/core/bindEmailTestRoutes');\nKeystone.prototype.connect = require('./lib/core/connect');\nKeystone.prototype.createItems = require('./lib/core/createItems');\nKeystone.prototype.getOrphanedLists = require('./lib/core/getOrphanedLists');\nKeystone.prototype.importer = require('./lib/core/importer');\nKeystone.prototype.init = require('./lib/core/init');\nKeystone.prototype.initNav = require('./lib/core/initNav');\nKeystone.prototype.list = require('./lib/core/list');\nKeystone.prototype.mount = require('./lib/core/mount');\nKeystone.prototype.populateRelated = require('./lib/core/populateRelated');\nKeystone.prototype.redirect = require('./lib/core/redirect');\nKeystone.prototype.render = require('./lib/core/render');\nKeystone.prototype.routes = require('./lib/core/routes');\nKeystone.prototype.start = require('./lib/core/start');\nKeystone.prototype.wrapHTMLError = require('./lib/core/wrapHTMLError');\n\n/* Expose Admin UI App */\nKeystone.prototype.adminApp = {\n\tstaticRouter: require('./admin/app/static')\n};\n\n/* Legacy Attach Mechanisms */\nKeystone.prototype.static = function(app) {\n\tif (!this.get('headless')) {\n\t\tapp.use('/keystone', Keystone.prototype.adminApp.staticRouter);\n\t}\n};\n\n/**\n * The exports object is an instance of Keystone.\n *\n * @api public\n */\nvar keystone = module.exports = exports = new Keystone();\n\n// Expose modules and Classes\nkeystone.Email = require('./lib/email');\nkeystone.Field = require('./fields/types/Type');\nkeystone.Field.Types = require('./lib/fieldTypes');\nkeystone.Keystone = Keystone;\nkeystone.List = require('./lib/list');\nkeystone.View = require('./lib/view');\n\nkeystone.content = require('./lib/content');\nkeystone.security = {\n\tcsrf: require('./lib/security/csrf')\n};\nkeystone.utils = utils;\n\n/**\n * returns all .js modules (recursively) in the path specified, relative\n * to the module root (where the keystone project is being consumed from).\n *\n * ####Example:\n *\n *     var models = keystone.import('models');\n *\n * @param {String} dirname\n * @api public\n */\n\nKeystone.prototype.import = function(dirname) {\n\n\tvar initialPath = path.join(this.get('module root'), dirname);\n\n\tvar doImport = function(fromPath) {\n\n\t\tvar imported = {};\n\n\t\tfs.readdirSync(fromPath).forEach(function(name) {\n\n\t\t\tvar fsPath = path.join(fromPath, name),\n\t\t\tinfo = fs.statSync(fsPath);\n\n\t\t\t// recur\n\t\t\tif (info.isDirectory()) {\n\t\t\t\timported[name] = doImport(fsPath);\n\t\t\t} else {\n\t\t\t\t// only import files that we can `require`\n\t\t\t\tvar ext = path.extname(name);\n\t\t\t\tvar base = path.basename(name, ext);\n\t\t\t\tif (require.extensions[ext]) {\n\t\t\t\t\timported[base] = require(fsPath);\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\n\t\treturn imported;\n\t};\n\n\treturn doImport(initialPath);\n};\n\n\n/**\n * Applies Application updates\n */\n\nKeystone.prototype.applyUpdates = function(callback) {\n\tvar self = this;\n\tself.callHook('pre:updates', function(err){\n\t\tif(err){\n\t\t\tcallback(err);\n\t\t}\n\t\trequire('./lib/updates').apply(function(err){\n\t\t\tif(err){\n\t\t\t\tcallback(err);\n\t\t\t}\n\t\t\tself.callHook('post:updates', callback);\n\t\t});\n\t});\n};\n\n\n/**\n * Logs a configuration error to the console\n *\n * @api public\n */\n\nKeystone.prototype.console = {};\nKeystone.prototype.console.err = function(type, msg) {\n\tif (keystone.get('logger')) {\n\t\tvar dashes = '\\n------------------------------------------------\\n';\n\t\tconsole.log(dashes + 'KeystoneJS: ' + type + ':\\n\\n' + msg + dashes);\n\t}\n};\n\n/**\n * Keystone version\n *\n * @api public\n */\n\nkeystone.version = require('./package.json').version;\n\n\n// Expose Modules\nkeystone.session = require('./lib/session');\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/options.js":"var _ = require('underscore');\nvar callerId = require('caller-id');\nvar cloudinary = require('cloudinary');\nvar debug = require('debug')('keystone:core:options');\nvar mandrillapi = require('mandrill-api');\nvar path = require('path');\nvar url = require('url');\nvar utils = require('keystone-utils');\n\nfunction options() {\n\t\n\tvar exports = {};\n\n\t/**\n\t * This file contains methods specific to dealing with Keystone's options.\n\t * All exports are added to the Keystone.prototype\n\t */\n\n\t// Deprecated options that have been mapped to new keys\n\tvar remappedOptions = {\n\t\t'signin success': 'signin redirect',\n\t\t'signout': 'signout url'\n\t};\n\n\t// Determines if path is absolute or relative\n\tfunction isAbsolutePath(value) {\n\t\treturn path.resolve(value) === path.normalize(value).replace(new RegExp(path.sep + '$'), '');\n\t}\n\n\t/**\n\t * Sets keystone options\n\t *\n\t * ####Example:\n\t *\n\t *     keystone.set('user model', 'User') // sets the 'user model' option to `User`\n\t *\n\t * @param {String} key\n\t * @param {String} value\n\t * @api public\n\t */\n\texports.set = function(key, value) {\n\n\t\tif (arguments.length === 1) {\n\t\t\treturn this._options[key];\n\t\t}\n\t\t\n\t\tif (remappedOptions[key]) {\n\t\t\tif (this.get('logger')) {\n\t\t\t\tconsole.log('\\nWarning: the `' + key + '` option has been deprecated. Please use `' + remappedOptions[key] + '` instead.\\n\\n' +\n\t\t\t\t\t'Support for `' + key + '` will be removed in a future version.');\n\t\t\t}\n\t\t\tkey = remappedOptions[key];\n\t\t}\n\n\t\tswitch (key) {\n\t\t\t// warn on deprecated/old/invalid settings\n\t\t\tcase 'less middleware options':\n\t\t\tcase 'less parser options':\n\t\t\tcase 'less compiler options':\n\t\t\t\tif (this.get('logger')) {\n\t\t\t\t\tconsole.log('\\nWarning: less-middleware has changed the way it handles options, and ' +\n\t\t\t\t\t\t'\\n`' + key + '` is no longer supported. You should simply use `less options` now;' +\n\t\t\t\t\t\t'\\nsee https://github.com/emberfeather/less.js-middleware for details.');\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t\t// handle special settings\n\t\t\tcase 'cloudinary config':\n\t\t\t\tif (_.isString(value)) {\n\t\t\t\t\tvar parts = url.parse(value, true);\n\t\t\t\t\tvar auth = parts.auth ? parts.auth.split(':') : [];\n\t\t\t\t\tvalue = {\n\t\t\t\t\t\tcloud_name: parts.host,\n\t\t\t\t\t\tapi_key: auth[0],\n\t\t\t\t\t\tapi_secret: auth[1],\n\t\t\t\t\t\tprivate_cdn: parts.pathname != null,\n\t\t\t\t\t\tsecure_distribution: parts.pathname && parts.pathname.substring(1)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (_.isObject(value)) {\n\t\t\t\t\tcloudinary.config(value);\n\t\t\t\t}\n\t\t\t\tvalue = cloudinary.config();\n\t\t\tbreak;\n\t\t\tcase 'mandrill api key':\n\t\t\t\tif (value) {\n\t\t\t\t\tdebug('found mandril key');\n\t\t\t\t\tthis.mandrillAPI = new mandrillapi.Mandrill(value);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'auth':\n\t\t\t\tif (value === true && !this.get('session')) {\n\t\t\t\t\tdebug('setting session for auth');\n\t\t\t\t\tthis.set('session', true);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'nav':\n\t\t\t\tdebug('setting nav');\n\t\t\t\tthis.nav = this.initNav(value);\n\t\t\tbreak;\n\t\t\tcase 'mongo':\n\t\t\t\tif ('string' !== typeof value) {\n\t\t\t\t\tif (Array.isArray(value) && (value.length === 2 || value.length === 3)) {\n\t\t\t\t\t\tconsole.log('\\nWarning: using an array for the `mongo` option has been deprecated.\\nPlease use a mongodb connection string, e.g. mongodb://localhost/db_name instead.\\n\\n' +\n\t\t\t\t\t\t\t'Support for arrays as the `mongo` setting will be removed in a future version.');\n\t\t\t\t\t\tvalue = (value.length === 2) ? 'mongodb://' + value[0] + '/' + value[1] : 'mongodb://' + value[0] + ':' + value[2] + '/' + value[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('\\nInvalid Configuration:\\nThe `mongo` option must be a mongodb connection string, e.g. mongodb://localhost/db_name\\n');\n\t\t\t\t\t\tprocess.exit(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'module root':\n\t\t\t\t// if relative path is used, resolve it based on the caller's path\n\t\t\t\tif (!isAbsolutePath(value)) {\n\t\t\t\t\tvar caller = callerId.getData();\n\t\t\t\t\tvalue = path.resolve(path.dirname(caller.filePath), value);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'app':\n\t\t\t\tthis.app = value;\n\t\t\tbreak;\n\t\t\tcase 'mongoose':\n\t\t\t\tthis.mongoose = value;\n\t\t\tbreak;\n\t\t\tcase 'frame guard':\n\t\t\t\tvar validFrameGuardOptions = ['deny', 'sameorigin'];\n\n\t\t\t\tif (value === true) {\n\t\t\t\t\tvalue = 'deny';\n\t\t\t\t}\n\t\t\t\tif (utils.isString(value)) {\n\t\t\t\t\tvalue = value.toLowerCase();\n\t\t\t\t\tif (validFrameGuardOptions.indexOf(value) < 0) {\n\t\t\t\t\t\tvalue = false;\n\t\t\t\t\t}\n\t\t\t\t} else if ('boolean' !== typeof value) {\n\t\t\t\t\tvalue = false;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tthis._options[key] = value;\n\t\treturn this;\n\t};\n\n\n\t/**\n\t * Sets multiple keystone options.\n\t *\n\t * ####Example:\n\t *\n\t *     keystone.options({test: value}) // sets the 'test' option to `value`\n\t *\n\t * @param {Object} options\n\t * @api public\n\t */\n\n\texports.options = function(options) {\n\t\tif (!arguments.length) {\n\t\t\treturn this._options;\n\t\t}\n\t\tif (utils.isObject(options)) {\n\t\t\tdebug('settings options');\n\t\t\tvar keys = Object.keys(options),\n\t\t\t\ti = keys.length,\n\t\t\t\tk;\n\t\t\twhile (i--) {\n\t\t\t\tk = keys[i];\n\t\t\t\tthis.set(k, options[k]);\n\t\t\t}\n\t\t}\n\t\treturn this._options;\n\t};\n\n\n\t/**\n\t * Gets keystone options\n\t *\n\t * ####Example:\n\t *\n\t *     keystone.get('test') // returns the 'test' value\n\t *\n\t * @param {String} key\n\t * @api public\n\t */\n\n\texports.get = exports.set;\n\n\t/**\n\t * Gets an expanded path option, expanded to include moduleRoot if it is relative\n\t *\n\t * ####Example:\n\t *\n\t *     keystone.get('pathOption', 'defaultValue')\n\t *\n\t * @param {String} key\n\t * @param {String} defaultValue\n\t * @api public\n\t */\n\n\texports.getPath = function(key, defaultValue) {\n\t\treturn this.expandPath(this.get(key) || defaultValue);\n\t};\n\n\t/**\n\t * Expands a path to include moduleRoot if it is relative\n\t *\n\t * @param {String} pathValue\n\t * @api public\n\t */\n\n\texports.expandPath = function(pathValue) {\n\t\tpathValue = ('string' === typeof pathValue && pathValue.substr(0, 1) !== path.sep && pathValue.substr(1, 2) !== ':\\\\')\n\t\t\t? path.join(this.get('module root'), pathValue)\n\t\t\t: pathValue;\n\t\treturn pathValue;\n\t};\n\t\n\treturn exports;\n\t\n}\n\nmodule.exports = options;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/bindEmailTestRoutes.js":"var _ = require('underscore');\n\nfunction bindEmailTestRoutes(app, emails) {\n\t\n\tvar keystone = this;\n\t\n\tvar handleError = function(req, res, err) {\n\t\tif (res.err) {\n\t\t\tres.err(err);\n\t\t} else {\n\t\t\t// TODO: Nicer default error handler\n\t\t\tres.status(500).send(JSON.stringify(err));\n\t\t}\n\t};\n\t\n\t// TODO: Index of email tests, and custom email test 404's (currently bounces to list 404)\n\t\n\t_.each(emails, function(vars, key) {\n\t\t\n\t\tvar render = function(err, req, res, locals) {// eslint-disable-line no-unused-vars, handle-callback-err\n\t\t\tnew keystone.Email(key).render(locals, function(err, email) {\n\t\t\t\tif (err) {\n\t\t\t\t\thandleError(req, res, err);\n\t\t\t\t} else {\n\t\t\t\t\tres.send(email.html);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\t\n\t\tapp.get('/keystone/test-email/' + key, function(req, res) {\n\t\t\tif ('function' === typeof vars) {\n\t\t\t\tvars(req, res, function(err, locals) {\n\t\t\t\t\trender(err, req, res, locals);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\trender(null, req, res, vars);\n\t\t\t}\n\t\t});\n\t\t\n\t});\n\t\n\treturn this;\n\t\n}\n\nmodule.exports = bindEmailTestRoutes;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/connect.js":"/**\n * Connects keystone to the application's mongoose instance.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *\n *     keystone.connect(mongoose);\n *\n * @param {Object} connections\n * @api public\n */\n\nvar debug = require('debug')('keystone:core:connect');\n\nfunction connect() {\n\tvar warningMsg = 'keystone.connect() is now deprecated and will not be available in future versions of KeystoneJS\\n' +\n\t\t'It has been replaced with the Keystone \"app\" and \"mongoose\" options.\\n' +\n\t\t'Due to changes in Express 4, \"keystone.connect()\" no longer works as expected.\\n\\n' +\n\t\t'See http://localhost:8080/docs/configuration#options-project for more information.';\n\n\tthis.console.err('Deprecation Warning', warningMsg);\n\n\t// detect type of each argument\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tif (arguments[i].constructor.name === 'Mongoose') {\n\t\t\tdebug('detected mongoose');\n\t\t\tthis.mongoose = arguments[i];\n\t\t} else if (arguments[i].name === 'app') {\n\t\t\tdebug('detected express app');\n\t\t\tthis.app = arguments[i];\n\t\t}\n\t}\n\treturn this;\n}\n\nmodule.exports = connect;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/createItems.js":"/**\n* Creates multiple items in one or more Lists\n*/\n\nvar _ = require('underscore');\nvar async = require('async');\nvar debug = require('debug')('keystone:core:createItems');\nvar utils = require('keystone-utils');\n\nfunction createItems(data, ops, callback) {\n\t\n\tvar keystone = this;\n\t\n\tvar options = {\n\t\tverbose: false,\n\t\tstrict: true,\n\t\trefs: null\n\t};\n\t\n\tvar dashes = '------------------------------------------------';\n\t\n\tif (!_.isObject(data)) {\n\t\tthrow new Error('keystone.createItems() requires a data object as the first argument.');\n\t}\n\t\n\tif (_.isObject(ops)) {\n\t\t_.extend(options, ops);\n\t}\n\t\n\tif (_.isFunction(ops)) {\n\t\tcallback = ops;\n\t}\n\t\n\tvar lists = _.keys(data),\n\t\trefs = options.refs || {},\n\t\tstats = {};\n\n\t// logger function\n\tfunction writeLog(data) {\n\t\tconsole.log(keystone.get('name') + ': ' + data);\n\t}\n\n\tasync.waterfall([\n\t\t\n\t\t// create items\n\t\tfunction(next) {\n\t\t\tdebug('create items');\n\t\t\tasync.eachSeries(lists, function(key, doneList) {\n\t\t\t\t\n\t\t\t\tvar list = keystone.list(key),\n\t\t\t\t\trelationshipPaths = _.where(list.fields, { type: 'relationship' }).map(function(i) { return i.path; });\n\t\t\t\t\n\t\t\t\tif (!list) {\n\t\t\t\t\tif (options.strict) {\n\t\t\t\t\t\treturn doneList({\n\t\t\t\t\t\t\ttype: 'invalid list',\n\t\t\t\t\t\t\tmessage: 'List key ' + key + ' is invalid.'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (options.verbose) {\n\t\t\t\t\t\twriteLog('Skipping invalid list: ' + key);\n\t\t\t\t\t}\n\t\t\t\t\treturn doneList();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!refs[list.key]) {\n\t\t\t\t\trefs[list.key] = {};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstats[list.key] = {\n\t\t\t\t\tsingular: list.singular,\n\t\t\t\t\tplural: list.plural,\n\t\t\t\t\tcreated: 0,\n\t\t\t\t\twarnings: 0\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tvar itemsProcessed = 0,\n\t\t\t\t\ttotalItems = data[key].length;\n\t\t\t\t\n\t\t\t\tif (options.verbose) {\n\t\t\t\t\twriteLog(dashes);\n\t\t\t\t\twriteLog('Processing list: ' + key);\n\t\t\t\t\twriteLog('Items to create: ' + totalItems);\n\t\t\t\t\twriteLog(dashes);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tasync.eachSeries(data[key], function(data, doneItem) {\n\t\t\t\t\t\n\t\t\t\t\titemsProcessed++;\n\t\t\t\t\t\n\t\t\t\t\t// Evaluate function properties to allow generated values (excluding relationships)\n\t\t\t\t\t_.keys(data).forEach(function(i) {\n\t\t\t\t\t\tif (_.isFunction(data[i]) && relationshipPaths.indexOf(i) === -1) {\n\t\t\t\t\t\t\tdata[i] = data[i]();\n\t\t\t\t\t\t\tif (options.verbose) {\n\t\t\t\t\t\t\t\twriteLog('Generated dynamic value for [' + i + ']: ' + data[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tvar doc = data.__doc = new list.model();\n\t\t\t\t\t\n\t\t\t\t\tif (data.__ref) {\n\t\t\t\t\t\trefs[list.key][data.__ref] = doc;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_.each(list.fields, function(field) {\n\t\t\t\t\t\t// skip relationship fields on the first pass.\n\t\t\t\t\t\tif (field.type !== 'relationship') {\n\t\t\t\t\t\t\tfield.updateItem(doc, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tif (options.verbose) {\n\t\t\t\t\t\tvar documentName = list.getDocumentName(doc);\n\t\t\t\t\t\twriteLog('Creating item [' + itemsProcessed + ' of ' + totalItems + '] - ' + documentName);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdoc.save(function(err) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\terr.model = key;\n\t\t\t\t\t\t\terr.data = data;\n\t\t\t\t\t\t\tdebug('error saving ', key);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstats[list.key].created++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdoneItem(err);\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t}, doneList);\n\t\t\t\t\n\t\t\t}, next);\n\t\t},\n\t\t\n\t\t// link items\n\t\tfunction(next) {\n\t\t\t\n\t\t\tasync.each(lists, function(key, doneList) {\n\t\t\t\t\n\t\t\t\tvar list = keystone.list(key),\n\t\t\t\t\trelationships = _.where(list.fields, { type: 'relationship' });\n\t\t\t\t\n\t\t\t\tif (!list || !relationships.length) {\n\t\t\t\t\treturn doneList();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar itemsProcessed = 0,\n\t\t\t\t\ttotalItems = data[key].length;\n\t\t\t\t\n\t\t\t\tif (options.verbose) {\n\t\t\t\t\twriteLog(dashes);\n\t\t\t\t\twriteLog('Processing relationships for: ' + key);\n\t\t\t\t\twriteLog('Items to process: ' + totalItems);\n\t\t\t\t\twriteLog(dashes);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tasync.each(data[key], function(srcData, doneItem) {\n\t\t\t\t\t\n\t\t\t\t\tvar doc = srcData.__doc,\n\t\t\t\t\t\trelationshipsUpdated = 0;\n\t\t\t\t\t\n\t\t\t\t\titemsProcessed++;\n\t\t\t\t\t\n\t\t\t\t\tif (options.verbose) {\n\t\t\t\t\t\tvar documentName = list.getDocumentName(doc);\n\t\t\t\t\t\twriteLog('Processing item [' + itemsProcessed + ' of ' + totalItems + '] - ' + documentName);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tasync.each(relationships, function(field, doneField) {\n\t\t\t\t\t\n\t\t\t\t\t\tvar fieldValue = null,\n\t\t\t\t\t\t\trefsLookup = null;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!field.path) {\n\t\t\t\t\t\t\twriteLog('WARNING:  Invalid relationship (undefined list path) [List: ' + key + ']');\n\t\t\t\t\t\t\tstats[list.key].warnings++;\n\t\t\t\t\t\t\treturn doneField();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfieldValue = srcData[field.path];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!field.refList) {\n\t\t\t\t\t\t\tif (fieldValue) {\n\t\t\t\t\t\t\t\twriteLog('WARNING:  Invalid relationship (undefined reference list) [list: ' + key + '] [path: ' + fieldValue + ']');\n\t\t\t\t\t\t\t\tstats[list.key].warnings++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn doneField();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!field.refList.key) {\n\t\t\t\t\t\t\twriteLog('WARNING:  Invalid relationship (undefined ref list key) [list: ' + key + '] [field.refList: ' + field.refList + '] [fieldValue: ' + fieldValue + ']');\n\t\t\t\t\t\t\tstats[list.key].warnings++;\n\t\t\t\t\t\t\treturn doneField();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trefsLookup = refs[field.refList.key];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!fieldValue) {\n\t\t\t\t\t\t\treturn doneField();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// populate relationships from saved refs\n\t\t\t\t\t\tif (_.isFunction(fieldValue)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\trelationshipsUpdated++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar fn = fieldValue,\n\t\t\t\t\t\t\t\targsRegExp = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m,\n\t\t\t\t\t\t\t\tlists = fn.toString().match(argsRegExp)[1].split(',').map(function(i) { return i.trim(); }),\n\t\t\t\t\t\t\t\targs = lists.map(function(i) {\n\t\t\t\t\t\t\t\t\treturn keystone.list(i);\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\tquery = fn.apply(keystone, args);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tquery.exec(function(err, results) {\n\t\t\t\t\t\t\t\tif (err) { debug('error ', err); }\n\t\t\t\t\t\t\t\tif (field.many) {\n\t\t\t\t\t\t\t\t\tdoc.set(field.path, results || []);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdoc.set(field.path, (results && results.length) ? results[0] : undefined);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdoneField(err);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (_.isArray(fieldValue)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (field.many) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tvar refsArr = _.compact(fieldValue.map(function(ref) {\n\t\t\t\t\t\t\t\t\treturn refsLookup && refsLookup[ref] ? refsLookup[ref].id : undefined;\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (options.strict && refsArr.length !== fieldValue.length) {\n\t\t\t\t\t\t\t\t\treturn doneField({\n\t\t\t\t\t\t\t\t\t\ttype: 'invalid ref',\n\t\t\t\t\t\t\t\t\t\tsrcData: srcData,\n\t\t\t\t\t\t\t\t\t\tmessage: 'Relationship ' + list.key + '.' + field.path + ' contains an invalid reference.'\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\trelationshipsUpdated++;\n\t\t\t\t\t\t\t\tdoc.set(field.path, refsArr);\n\t\t\t\t\t\t\t\tdoneField();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn doneField({\n\t\t\t\t\t\t\t\t\ttype: 'invalid data',\n\t\t\t\t\t\t\t\t\tsrcData: srcData,\n\t\t\t\t\t\t\t\t\tmessage: 'Single-value relationship ' + list.key + '.' + field.path + ' provided as an array.'\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (_.isString(fieldValue)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar refItem = refsLookup && refsLookup[fieldValue];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (!refItem) {\n\t\t\t\t\t\t\t\treturn options.strict ? doneField({\n\t\t\t\t\t\t\t\t\ttype: 'invalid ref',\n\t\t\t\t\t\t\t\t\tsrcData: srcData,\n\t\t\t\t\t\t\t\t\tmessage: 'Relationship ' + list.key + '.' + field.path + ' contains an invalid reference: \"' + fieldValue + '\".'\n\t\t\t\t\t\t\t\t}) : doneField();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\trelationshipsUpdated++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdoc.set(field.path, field.many ? [refItem.id] : refItem.id);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdoneField();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (fieldValue && fieldValue.id) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\trelationshipsUpdated++;\n\t\t\t\t\t\t\tdoc.set(field.path, field.many ? [fieldValue.id] : fieldValue.id);\n\t\t\t\t\t\t\tdoneField();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn doneField({\n\t\t\t\t\t\t\t\ttype: 'invalid data',\n\t\t\t\t\t\t\t\tsrcData: srcData,\n\t\t\t\t\t\t\t\tmessage: 'Relationship ' + list.key + '.' + field.path + ' contains an invalid data type.'\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}, function(err) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tdebug('error ', err);\n\t\t\t\t\t\t\treturn doneItem(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (options.verbose) {\n\t\t\t\t\t\t\twriteLog('Populated ' + utils.plural(relationshipsUpdated, '* relationship', '* relationships') + '.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (relationshipsUpdated) {\n\t\t\t\t\t\t\tdoc.save(doneItem);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdoneItem();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t}, doneList);\n\t\t\t\t\n\t\t\t}, next);\n\t\t}\n\t\t\n\t], function(err) {\n\n\t\tif (err) {\n\t\t\tconsole.error(err);\n\t\t\tif ('stack' in err) {\n\t\t\t\tconsole.trace(err.stack);\n\t\t\t}\n\t\t\treturn callback && callback(err);\n\t\t}\n\n\t\tvar msg = '\\nSuccessfully created:\\n';\n\t\t_.each(stats, function(list) {\n\t\t\tmsg += '\\n*   ' + utils.plural(list.created, '* ' + list.singular, '* ' + list.plural);\n\t\t\tif (list.warnings) {\n\t\t\t\tmsg += '\\n    ' + utils.plural(list.warnings, '* warning', '* warnings');\n\t\t\t}\n\t\t});\n\t\tstats.message = msg + '\\n';\n\t\t\n\t\tcallback(null, stats);\n\t\t\n\t});\n\t\n}\n\nmodule.exports = createItems;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/getOrphanedLists.js":"var _ = require('underscore');\n\n/**\n * Retrieves orphaned lists (those not in a nav section)\n */\n\nfunction getOrphanedLists() {\n\tif (!this.nav) {\n\t\treturn [];\n\t}\n\treturn _.filter(this.lists, function(list, key) {\n\t\tif (list.get('hidden')) return false;\n\t\treturn (!this.nav.by.list[key]) ? list : false;\n\t}.bind(this));\n}\n\nmodule.exports = getOrphanedLists;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/importer.js":"var fs = require('fs');\nvar debug = require('debug')('keystone:core:importer');\nvar path = require('path');\n\n/**\n * Returns a function that looks in a specified path relative to the current\n * directory, and returns all .js modules it (recursively).\n *\n * ####Example:\n *\n *     var importRoutes = keystone.importer(__dirname);\n *\n *     var routes = {\n *         site: importRoutes('./site'),\n *         api: importRoutes('./api')\n *     };\n *\n * @param {String} rel__dirname\n * @api public\n */\n\nfunction dispatchImporter(rel__dirname) {\n\t\n\tfunction importer(from) {\n\t\tdebug('importing ', from);\n\t\tvar imported = {};\n\t\tvar joinPath = function() {\n\t\t\treturn '.' + path.sep + path.join.apply(path, arguments);\n\t\t};\n\t\t\n\t\tvar fsPath = joinPath(path.relative(process.cwd(), rel__dirname), from);\n\t\tfs.readdirSync(fsPath).forEach(function(name) {\n\t\t\tvar info = fs.statSync(path.join(fsPath, name));\n\t\t\tdebug('recur');\n\t\t\tif (info.isDirectory()) {\n\t\t\t\timported[name] = importer(joinPath(from, name));\n\t\t\t} else {\n\t\t\t\t// only import files that we can `require`\n\t\t\t\tvar ext = path.extname(name);\n\t\t\t\tvar base = path.basename(name, ext);\n\t\t\t\tif (require.extensions[ext]) {\n\t\t\t\t\timported[base] = require(path.join(rel__dirname, from, name));\n\t\t\t\t} else {\n\t\t\t\t\tdebug('cannot require ', ext);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn imported;\n\t}\n\t\n\treturn importer;\n\t\n}\n\nmodule.exports = dispatchImporter;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/init.js":"/**\n * Initialises Keystone in encapsulated mode.\n *\n * Creates an Express app and configures it if none has been connected.\n *\n * Also connects to the default mongoose instance if none has been connected.\n *\n * Accepts an options argument.\n *\n * Returns `this` to allow chaining.\n *\n * @param {Object} options\n * @api public\n */\n\nvar debug = require('debug')('keystone:core:init');\n\nfunction init(options) {\n\tdebug('initializing app');\n\tthis.options(options);\n\t\n\tif (!this.app) {\n\t\tthis.set('app', require('express')());\n\t}\n\t\n\tif (!this.mongoose) {\n\t\tthis.set('mongoose', require('mongoose'));\n\t}\n\t\n\treturn this;\n\t\n}\n\nmodule.exports = init;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/initNav.js":"/**\n * Initialises Keystone's internal nav config\n *\n * @param {Object} nav\n * @api private\n */\n\nvar _ = require('underscore');\nvar debug = require('debug')('keystone:core:initNav');\nvar utils = require('keystone-utils');\n\nfunction initNav(sections) {\n\tdebug('init nav');\n\tvar keystone = this;\n\t\n\tvar nav = {\n\t\tsections: [],\n\t\tby: {\n\t\t\tlist: {},\n\t\t\tsection: {}\n\t\t}\n\t};\n\t\n\tif (!sections) {\n\t\tsections = {};\n\t\tnav.flat = true;\n\t\t_.each(this.lists, function(list) {\n\t\t\tif (list.get('hidden')) return;\n\t\t\tsections[list.path] = [list.path];\n\t\t});\n\t}\n\t\n\t_.each(sections, function(section, key) {\n\t\tif ('string' === typeof section) {\n\t\t\tsection = [section];\n\t\t}\n\t\tsection = {\n\t\t\tlists: section,\n\t\t\tlabel: nav.flat ? keystone.list(section[0]).label : utils.keyToLabel(key)\n\t\t};\n\t\tsection.key = key;\n\t\tsection.lists = _.map(section.lists, function(i) {\n\t\t\tif (_.isString(i)) {\n\t\t\t\tvar list = keystone.list(i);\n\t\t\t\tif (!list) {\n\t\t\t\t\tthrow new Error('Invalid Keystone Option (nav): list ' + i + ' has not been defined.\\n');\n\t\t\t\t}\n\t\t\t\tif (list.get('hidden')) {\n\t\t\t\t\tthrow new Error('Invalid Keystone Option (nav): list ' + i + ' is hidden.\\n');\n\t\t\t\t}\n\t\t\t\tnav.by.list[list.key] = section;\n\t\t\t\treturn {\n\t\t\t\t\tkey: list.key,\n\t\t\t\t\tlabel: list.label,\n\t\t\t\t\tpath: list.path\n\t\t\t\t};\n\t\t\t} else if (_.isObject(i)) {\n\t\t\t\tif (!_.has(i, 'key')) {\n\t\t\t\t\tthrow new Error('Invalid Keystone Option (nav): object ' + i + ' requires a \"key\" property.\\n');\n\t\t\t\t}\n\t\t\t\ti.label = i.label || utils.keyToLabel(key);\n\t\t\t\ti.path = i.path || utils.keyToPath(key);\n\t\t\t\ti.external = true;\n\t\t\t\tnav.by.list[i.key] = section;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tthrow new Error('Invalid Keystone Option (nav): ' + i + ' is in an unrecognized format.\\n');\n\t\t});\n\t\tif (section.lists.length) {\n\t\t\tnav.sections.push(section);\n\t\t\tnav.by.section[section.key] = section;\n\t\t}\n\t});\n\t\n\treturn nav;\n}\n\nmodule.exports = initNav;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/list.js":"/**\n * Registers or retrieves a list\n */\n\nfunction list(arg) {\n\tif (arg && arg.constructor === this.List) {\n\t\tthis.lists[arg.key] = arg;\n\t\tthis.paths[arg.path] = arg.key;\n\t\treturn arg;\n\t}\n\tvar ret = this.lists[arg] || this.lists[this.paths[arg]];\n\tif (!ret) throw new ReferenceError('Unknown keystone list ' + JSON.stringify(arg));\n\treturn ret;\n}\n\nmodule.exports = list;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/mount.js":"/**\n * Configures a Keystone app in encapsulated mode, but does not start it.\n *\n * Connects to the database and runs updates and then calls back.\n *\n * This is the code-path to use if you'd like to mount the keystone app as a sub-app in another express application.\n *\n *   var app = express();\n *\n *   //...do your normal express setup stuff, add middleware and routes (but not static content or error handling middleware yet)\n *\n *   keystone.mount('/content', app, function() {\n *\t //put your app's static content and error handling middleware here and start your server\n *   });\n *\n * Events are fired during initialisation to allow customisation, including:\n *\n *   - onMount\n *\n * If the events argument is a function, it is assumed to be the mounted event.\n *\n *\n * ####Options:\n *\n * Keystone supports the following options specifically for running in encapsulated mode (with no embedded server):\n *\n *   - name\n *   - port\n *   - views\n *   - view engine\n *   - compress\n *   - favico\n *   - less\n *   - static\n *   - headless\n *   - logger\n *   - cookie secret\n *   - session\n *   - 404\n *   - 500\n *   - routes\n *   - locals\n *   - auto update\n *\n *\n * @api public\n */\n\nvar _ = require('underscore');\nvar debug = require('debug')('keystone:core:mount');\nvar P = require('bluebird');\nvar express = require('express');\nvar path = require('path');\nvar utils = require('keystone-utils');\nvar favicon = require('serve-favicon');\nvar morgan = require('morgan');\nvar methodOverride = require('method-override');\nvar session = require('express-session');\nvar multer = require('multer');\nvar bodyParser = require('body-parser');\nvar cookieParser = require('cookie-parser');\nvar compression = require('compression');\n\nvar dashes = '\\n------------------------------------------------\\n';\n\nfunction mount(mountPath, parentApp, events) {\n  debug('mounting');\n\t// Validate the express app instance\n\n\tif (!this.app) {\n\t\tconsole.error('\\nKeystoneJS Initialisaton Error:\\n\\napp must be initialised. Call keystone.init() or keystone.connect(new Express()) first.\\n');\n\t\tprocess.exit(1);\n\t}\n\n\t// Localise references to this for closures\n\n\tvar keystone = this;\n\tvar app = this.app;\n\n\t// this.nativeApp indicates keystone has been mounted natively\n\t// (not as part of a custom middleware stack)\n\t//\n\tthis.nativeApp = true;\n\n\t// Initialise the mongo connection url\n\n\tif (!this.get('mongo')) {\n\t\tvar dbName = this.get('db name') || utils.slug(this.get('name'));\n\t\tvar dbUrl = process.env.MONGO_URI || process.env.MONGO_URL || process.env.MONGODB_URL || process.env.MONGOLAB_URI || process.env.MONGOLAB_URL || (process.env.OPENSHIFT_MONGODB_DB_URL || 'mongodb://localhost/') + dbName;\n\t\tdebug('setting DB URI to : ' + dbUrl);\n\t\tthis.set('mongo', dbUrl);\n\t}\n\n\t// Initialise and validate session options\n\n\tif (!this.get('cookie secret')) {\n\t\tconsole.error('\\nKeystoneJS Configuration Error:\\n\\nPlease provide a `cookie secret` value for session encryption.\\n');\n\t\tprocess.exit(1);\n\t}\n\n\tvar sessionOptions = this.get('session options');\n\n\tif (!_.isObject(sessionOptions)) {\n\t\tsessionOptions = {};\n\t}\n\n\tif (!sessionOptions.key) {\n\t\tsessionOptions.key = 'keystone.sid';\n\t}\n\n\t_.defaults(sessionOptions, {\n\t\tresave: false,\n\t\tsecret: this.get('cookie secret'),\n\t\tsaveUninitialized: false\n\t});\n\n\tsessionOptions.cookieParser = cookieParser(this.get('cookie secret'));\n\n\tvar sessionStore = this.get('session store');\n\n\tvar sessionStorePromise;\n\n\tif (typeof sessionStore === 'function') {\n\t\tsessionOptions.store = sessionStore(session);\n\t} else if (sessionStore) {\n\n\t\tvar sessionStoreOptions = this.get('session store options') || {};\n\n\t\t// Perform any session store specific configuration or exit on an unsupported session store\n\n\t\tif (sessionStore === 'mongo') {\n\t\t\tsessionStore = 'connect-mongo';\n\t\t} else if (sessionStore === 'redis') {\n\t\t\tsessionStore = 'connect-redis';\n\t\t}\n\n\t\tswitch (sessionStore) {\n\t\t\tcase 'connect-mongo':\n\t\t\t\tdebug('using mongo for session store');\n\t\t\t\tif (process.version.substr(0, 4) === 'v0.1') {\n\t\t\t\t\tsessionStore = 'connect-mongo/es5';\n\t\t\t\t}\n\t\t\t\t_.defaults(sessionStoreOptions, {\n\t\t\t\t\tcollection: 'app_sessions',\n\t\t\t\t\turl: this.get('mongo')\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'connect-mongostore':\n\t\t\t\tdebug('using connect-mongostore for session store');\n\t\t\t\t_.defaults(sessionStoreOptions, {\n\t\t\t\t\tcollection: 'app_sessions'\n\t\t\t\t});\n\t\t\t\tif (!sessionStoreOptions.db) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'\\nERROR: connect-mongostore requires `session store options` to be set.' +\n\t\t\t\t\t\t'\\n' +\n\t\t\t\t\t\t'\\nSee http://keystonejs.com/docs/configuration#options-database for details.' +\n\t\t\t\t\t'\\n');\n\t\t\t\t\tprocess.exit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'connect-redis':\n\t\t\t\tdebug('using redis for session store');\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error(\n\t\t\t\t\t'\\nERROR: unsupported session store ' + sessionStore + '.' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\\nSee http://keystonejs.com/docs/configuration#options-database for details.' +\n\t\t\t\t'\\n');\n\t\t\t\tprocess.exit(1);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Initialize the session store\n\t\ttry {\n\t\t\tvar SessionStore = require(sessionStore)(session);\n\t\t\tsessionStorePromise = new P(function(resolve) {\n\t\t\t\tsessionOptions.store = new SessionStore(sessionStoreOptions, resolve);\n\t\t\t\tsessionOptions.store.on('connect', resolve);\n\t\t\t\tsessionOptions.store.on('connected', resolve);\n\t\t\t\tsessionOptions.store.on('disconnect', function() {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'\\nThere was an error connecting to the ' + sessionStore + ' session store.' +\n\t\t\t\t\t'\\n');\n\t\t\t\t\tprocess.exit(1);\n\t\t\t\t});\n\t\t\t});\n\t\t} catch(e) {\n\t\t\tif (e.code === 'MODULE_NOT_FOUND') {\n\t\t\t\tconsole.error(\n\t\t\t\t\t'\\n' + e.toString() +\n\t\t\t\t\t'\\nTo use ' + this.get('session store') + ' as a `session store` option, run:' +\n\t\t\t\t\t'\\nnpm install ' + sessionStore + ' --save' +\n\t\t\t\t'\\n');\n\t\t\t\tprocess.exit(1);\n\t\t\t} else {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}\n\n\t// expose initialised session and options\n\tthis.set('session options', sessionOptions);\n\tthis.set('express session', session(sessionOptions));\n\n\n\t// wrangle arguments\n\tif (arguments.length === 1) {\n\t\tevents = arguments[0];\n\t\tmountPath = null;\n\t}\n\n\tif ('function' === typeof events) {\n\t\tevents = { onMount: events };\n\t}\n\n\tif (!events) events = {};\n\n\t/* Express sub-app mounting to external app at a mount point (if specified) */\n\n\tif (mountPath) {\n\t\t//fix root-relative keystone urls for assets (gets around having to re-write all the keystone templates)\n\t\tparentApp.all(/^\\/keystone($|\\/.*)/, function(req, res, next) {\n\t\t\treq.url = (mountPath + req.url).replace(new RegExp(/\\/\\//, 'g'), '/');\n\t\t\tnext();\n\t\t});\n\n\t\tparentApp.use(mountPath, app);\n\t}\n\n\t/* Keystone's encapsulated Express App Setup */\n\n\t// Allow usage of custom view engines\n\tif (this.get('custom engine')) {\n\t\tapp.engine(this.get('view engine'), this.get('custom engine'));\n\t}\n\n\t// Set location of view templates and view engine\n\tapp.set('views', this.getPath('views') || path.sep + 'views');\n\tapp.set('view engine', this.get('view engine'));\n\n\t// Apply locals\n\tif (utils.isObject(this.get('locals'))) {\n\t\t_.extend(app.locals, this.get('locals'));\n\t}\n\n\t// Indent HTML everywhere, except production\n\tif (this.get('env') !== 'production' && app.locals.pretty === undefined) {\n\t\tapp.locals.pretty = true;\n\t}\n\n\t// Default view caching logic\n\tapp.set('view cache', this.get('env') === 'production' ? true : false);\n\n\t// Setup view caching from app settings\n\tif (this.get('view cache') !== undefined) {\n\t\tapp.set('view cache', this.get('view cache'));\n\t}\n\n\t// Compress response bodies\n\tif (this.get('compress')) {\n\t\tapp.use(compression());\n\t}\n\n\t// Pre static config\n\tif ('function' === typeof this.get('pre:static')) {\n\t\tdebug('configuring pre:static middleware');\n\t\tthis.get('pre:static')(app);\n\t}\n\tapp.use(function(req, res, next) {\n\t\tkeystone.callHook('pre:static', req, res, next);\n\t});\n\n\t// Serve static assets\n\n\tif (this.get('favico')) {\n\t\tapp.use(favicon(this.getPath('favico')));\n\t}\n\n\t// unless the headless option is set (which disables the Admin UI),\n\t// add the Admin UI's Static Router for public resources\n\tif (!this.get('headless')) {\n\t\tapp.use('/keystone', require('../../admin/app/static'));\n\t}\n\n\t// the less option can be a single path, or array of paths\n\t// when set, we configure the less middleware\n\n\tvar lessPaths = this.get('less');\n\tvar lessOptions = this.get('less options') || {};\n\n\tif (_.isString(lessPaths)) {\n\t\tlessPaths = [lessPaths];\n\t}\n\n\tif (_.isArray(lessPaths)) {\n\t\t_.each(lessPaths, function(value) {\n\t\t\tapp.use(require('less-middleware')(this.expandPath(value), lessOptions));\n\t\t}, this);\n\t}\n\n\t// the sass option can be a single path, or array of paths\n\t// when set, we configure the node-sass middleware\n\n\tvar sassPaths = this.get('sass'),\n\t\tsassOptions = this.get('sass options') || {};\n\n\tif (_.isString(sassPaths)) {\n\t\tsassPaths = [sassPaths];\n\t}\n\n\tif (_.isArray(sassPaths)) {\n\t\tvar sassMiddleware;\n\t\ttry {\n\t\t\tdebug('adding sass');\n\t\t\tsassMiddleware = require('node-sass-middleware');\n\t\t} catch(e) {\n\t\t\tif (e.code === 'MODULE_NOT_FOUND') {\n\t\t\t\tconsole.error(\n\t\t\t\t\t'\\nERROR: node-sass not found.\\n' +\n\t\t\t\t\t'\\nPlease install the node-sass-middleware from npm to use the `sass` option.' +\n\t\t\t\t\t'\\nYou can do this by running \"npm install node-sass-middleware --save\".\\n'\n\t\t\t\t);\n\t\t\t\tprocess.exit(1);\n\t\t\t} else {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\t_.each(sassPaths, function(value) {\n\t\t\tapp.use(sassMiddleware(_.extend({\n\t\t\t\tsrc: this.expandPath(value),\n\t\t\t\tdest: this.expandPath(value),\n\t\t\t\toutputStyle: this.get('env') === 'production' ? 'compressed' : 'nested'\n\t\t\t}, sassOptions)));\n\t\t}, this);\n\t}\n\n\t// the static option can be a single path, or array of paths\n\t// when set, we configure the express static middleware\n\n\tvar staticPaths = this.get('static');\n\tvar staticOptions = this.get('static options');\n\n\tif (_.isString(staticPaths)) {\n\t\tstaticPaths = [staticPaths];\n\t}\n\n\tif (_.isArray(staticPaths)) {\n\t\t_.each(staticPaths, function(value) {\n\t\t\tapp.use(express.static(this.expandPath(value), staticOptions));\n\t\t}, this);\n\t}\n\n\t// Log dynamic requests\n\tif (this.get('logger')) {\n\t\tdebug('adding request logger');\n\t\tapp.use(morgan(this.get('logger'), this.get('logger options')));\n\t}\n\n\t// If the user wants to define their own middleware for logging,\n\t// they should be able to\n\tif (keystone.get('logging middleware')) {\n\t\tapp.use(keystone.get('logging middleware'));\n\t}\n\n\t// We should also allow custom logging middleware to exist in the normal middleware flow\n\tapp.use(function(req, res, next) {\n\t\tkeystone.callHook('pre:logger', req, res, next);\n\t});\n\n\t// Pre bodyparser middleware\n\tif ('function' === typeof this.get('pre:bodyparser')) {\n\t\tdebug('configuring pre:bodyparser middleware');\n\t\tthis.get('pre:bodyparser')(app);\n\t}\n\tapp.use(function(req, res, next) {\n\t\tkeystone.callHook('pre:bodyparser', req, res, next);\n\t});\n\n\t// Set up body options and cookie parser\n\tvar bodyParserParams = {};\n\n\tif (this.get('file limit')) {\n\t\tdebug('adding file limit');\n\t\tbodyParserParams.limit = this.get('file limit');\n\t}\n\n\tapp.use(bodyParser.json(bodyParserParams));\n\tbodyParserParams.extended = true;\n\tapp.use(bodyParser.urlencoded(bodyParserParams));\n\tapp.use(methodOverride());\n\tapp.use(sessionOptions.cookieParser);\n\n\t// Pre session config\n\tif ('function' === typeof this.get('pre:session')) {\n\t\tdebug('configuring pre:session middleware');\n\t\tthis.get('pre:session')(app);\n\t}\n\tapp.use(function(req, res, next) {\n\t\tkeystone.callHook('pre:session', req, res, next);\n\t});\n\n\tapp.use(this.get('express session'));\n\tapp.use(multer({\n\t\tincludeEmptyFields: true\n\t}));\n\tapp.use(require('connect-flash')());\n\n\tif (this.get('session') === true) {\n\t\tapp.use(this.session.persist);\n\t} else if ('function' === typeof this.get('session')) {\n\t\tapp.use(this.get('session'));\n\t}\n\n\t// Add 'X-Frame-Options' to response header for ClickJacking protection\n\tif (this.get('frame guard')) {\n\t\tdebug('enabling frame guard');\n\t\tapp.use(require('../security/frameGuard')(this));\n\t}\n\n\t// Process 'X-Forwarded-For' request header\n\tif (this.get('trust proxy') === true) {\n\t\tdebug('enabling trusted proxy');\n\t\tapp.enable('trust proxy');\n\t} else {\n\t\tapp.disable('trust proxy');\n\t}\n\n\t// Check for IP range restrictions\n\tif (this.get('allowed ip ranges')) {\n\t\tif (!app.get('trust proxy')) {\n\t\t\tconsole.log(\n\t\t\t\t'KeystoneJS Initialisaton Error:\\n\\n' +\n\t\t\t\t'to set IP range restrictions the \"trust proxy\" setting must be enabled.\\n\\n'\n\t\t\t);\n\t\t\tprocess.exit(1);\n\t\t}\n\t\tdebug('adding IP ranges', this.get('allowed ip ranges'));\n\t\tvar ipRangeMiddleware = require('../security/ipRangeRestrict')(\n\t\t\tthis.get('allowed ip ranges'),\n\t\t\tthis.wrapHTMLError\n\t\t);\n\t\tthis.pre('routes', ipRangeMiddleware);\n\t}\n\n\t// Pre route config\n\n\t// Pre session config\n\tif ('function' === typeof this.get('pre:routes')) {\n\t\tdebug('configuring pre:routes middleware');\n\t\tthis.get('pre:routes')(app);\n\t}\n\tapp.use(function(req, res, next) {\n\t\tkeystone.callHook('pre:routes', req, res, next);\n\t});\n\n\t// unless the headless option is set (which disables the Admin UI),\n\t// include the Admin UI route handlers\n\tif (!this.get('headless')) {\n\t\tdebug('adding keystone routes to express app');\n\t\tthis.routes(app);\n\t}\n\n\n\t// Configure application routes\n\tif ('function' === typeof this.get('routes')) {\n\t\tdebug('configuring app routes');\n\t\tthis.get('routes')(app);\n\t}\n\n\t//prepare the error handlers; they should be called last\n\tvar setHandlers = function () {\n\n\t\t// Handle redirects before 404s\n\t\tif (Object.keys(keystone._redirects).length) {\n\t\t\tapp.use(function(req, res, next) {\n\t\t\t\tif (keystone._redirects[req.path]) {\n\t\t\t\t\tres.redirect(keystone._redirects[req.path]);\n\t\t\t\t} else {\n\t\t\t\t\tnext();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Handle 404 (no route matched) errors\n\t\tvar default404Handler = function(req, res, next) {// eslint-disable-line no-unused-vars\n\t\t\tres.status(404).send(keystone.wrapHTMLError('Sorry, no page could be found at this address (404)'));\n\t\t};\n\n\t\tapp.use(function(req, res, next) {\n\t\t\tvar err404 = keystone.get('404');\n\t\t\tif (err404) {\n\t\t\t\ttry {\n\t\t\t\t\tif ('function' === typeof err404) {\n\t\t\t\t\t\terr404(req, res, next);\n\t\t\t\t\t} else if ('string' === typeof err404) {\n\t\t\t\t\t\tres.status(404).render(err404);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (keystone.get('logger')) {\n\t\t\t\t\t\t\tconsole.log(dashes + 'Error handling 404 (not found): Invalid type (' + (typeof err404) + ') for 404 setting.' + dashes);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault404Handler(req, res, next);\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t\tif (keystone.get('logger')) {\n\t\t\t\t\t\tconsole.log(dashes + 'Error handling 404 (not found):');\n\t\t\t\t\t\tconsole.log(e);\n\t\t\t\t\t\tconsole.log(dashes);\n\t\t\t\t\t}\n\t\t\t\t\tdefault404Handler(req, res, next);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdefault404Handler(req, res, next);\n\t\t\t}\n\t\t});\n\n\t\t// Handle other errors\n\n\t\tvar default500Handler = function(err, req, res, next) {// eslint-disable-line no-unused-vars\n\n\t\t\tif (keystone.get('logger')) {\n\t\t\t\tif (err instanceof Error) {\n\t\t\t\t\tconsole.log((err.type ? err.type + ' ' : '') + 'Error thrown for request: ' + req.url);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log('Error thrown for request: ' + req.url);\n\t\t\t\t}\n\t\t\t\tconsole.log(err.stack || err);\n\t\t\t}\n\n\t\t\tvar msg = '';\n\n\t\t\tif (keystone.get('env') === 'development') {\n\n\t\t\t\tif (err instanceof Error) {\n\t\t\t\t\tif (err.type) {\n\t\t\t\t\t\tmsg += '<h2>' + err.type + '</h2>';\n\t\t\t\t\t}\n\t\t\t\t\tmsg += utils.textToHTML(err.message);\n\t\t\t\t} else if ('object' === typeof err) {\n\t\t\t\t\tmsg += '<code>' + JSON.stringify(err) + '</code>';\n\t\t\t\t} else if (err) {\n\t\t\t\t\tmsg += err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tres.status(500).send(keystone.wrapHTMLError('Sorry, an error occurred loading the page (500)', msg));\n\t\t};\n\n\t\tapp.use(function(err, req, res, next) {\n\n\t\t\tvar err500 = keystone.get('500');\n\n\t\t\tif (err500) {\n\t\t\t\ttry {\n\t\t\t\t\tif ('function' === typeof err500) {\n\t\t\t\t\t\terr500(err, req, res, next);\n\t\t\t\t\t} else if ('string' === typeof err500) {\n\t\t\t\t\t\tres.locals.err = err;\n\t\t\t\t\t\tres.status(500).render(err500);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (keystone.get('logger')) {\n\t\t\t\t\t\t\tconsole.log(dashes + 'Error handling 500 (error): Invalid type (' + (typeof err500) + ') for 500 setting.' + dashes);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault500Handler(err, req, res, next);\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t\tif (keystone.get('logger')) {\n\t\t\t\t\t\tconsole.log(dashes + 'Error handling 500 (error):');\n\t\t\t\t\t\tconsole.log(e);\n\t\t\t\t\t\tconsole.log(dashes);\n\t\t\t\t\t}\n\t\t\t\t\tdefault500Handler(err, req, res, next);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdefault500Handler(err, req, res, next);\n\t\t\t}\n\n\t\t});\n\t};\n\n\t// Connect to database\n\n\tvar mongoConnectionOpen = false;\n\n\t// support replica sets for mongoose\n\tif (this.get('mongo replica set')){\n\t\tdebug('setting up mongo replica set');\n\t\tvar replicaData = this.get('mongo replica set');\n\t\tvar replica = '';\n\n\t\tvar credentials = (replicaData.username && replicaData.password) ? replicaData.username + ':' + replicaData.password + '@' : '';\n\n\t\treplicaData.db.servers.forEach(function (server) {\n\t\t\treplica += 'mongodb://' + credentials + server.host + ':' + server.port + '/' + replicaData.db.name + ',';\n\t\t});\n\n\t\tvar options = {\n\t\t\tauth: { authSource: replicaData.authSource },\n\t\t\treplset: {\n\t\t\t\trs_name: replicaData.db.replicaSetOptions.rs_name,\n\t\t\t\treadPreference: replicaData.db.replicaSetOptions.readPreference\n\t\t\t}\n\t\t};\n\n\t\tdebug('connecting to replicate set');\n\t\tthis.mongoose.connect(replica, options);\n\n\t} else {\n\t\tdebug('connecting to mongo');\n\t\tthis.mongoose.connect(this.get('mongo'));\n\n\t}\n\n\tthis.mongoose.connection.on('error', function(err) {\n\n\t\tif (keystone.get('logger')) {\n\t\t\tconsole.log('------------------------------------------------');\n\t\t\tconsole.log('Mongo Error:\\n');\n\t\t\tconsole.log(err);\n\t\t}\n\n\t\tif (mongoConnectionOpen) {\n\t\t\tif (err.name === 'ValidationError') return;\n\t\t\tthrow err;\n\t\t} else {\n\t\t\tthrow new Error('KeystoneJS (' + keystone.get('name') + ') failed to start');\n\t\t}\n\n\t}).on('open', function() {\n\n\t\tdebug('mongo connection open');\n\t\tmongoConnectionOpen = true;\n\n\t\tvar mounted = function() {\n\t\t\tevents.onMount && events.onMount();// eslint-disable-line no-unused-expressions\n\t\t\tsetHandlers();\n\t\t};\n\n\t\tvar connected = function() {\n\t\t\tif (keystone.get('auto update')) {\n\t\t\t\tdebug('applying auto update');\n\t\t\t\tkeystone.applyUpdates(mounted);\n\t\t\t} else {\n\t\t\t\tmounted();\n\t\t\t}\n\t\t};\n\n\t\tif (sessionStorePromise) {\n\t\t\tsessionStorePromise.then(connected);\n\t\t} else {\n\t\t\tconnected();\n\t\t}\n\n\t});\n}\n\nmodule.exports = mount;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/populateRelated.js":"var async = require('async');\n\n/**\n * Populates relationships on a document or array of documents\n *\n * WARNING: This is currently highly inefficient and should only be used in development, or for\n * small data sets. There are lots of things that can be done to improve performance... later.\n *\n * @api public\n */\n\nfunction populateRelated(docs, relationships, callback) {\n\t\n\tif (Array.isArray(docs)) {\n\t\tasync.each(docs, function(doc, done) {\n\t\t\tdoc.populateRelated(relationships, done);\n\t\t}, callback);\n\t} else if (docs && docs.populateRelated) {\n\t\tdocs.populateRelated(relationships, callback);\n\t} else {\n\t\tcallback();\n\t}\n\n}\n\nmodule.exports = populateRelated;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/redirect.js":"var _ = require('underscore');\nvar debug = require('debug')('keystone:core:redirect');\nvar utils = require('keystone-utils');\n\n/**\n * Adds one or more redirections (urls that are redirected when no matching\n * routes are found, before treating the request as a 404)\n *\n * #### Example:\n * \t\tkeystone.redirect('/old-route', 'new-route');\n *\n * \t\t// or\n *\n * \t\tkeystone.redirect({\n * \t\t\t'old-route': 'new-route'\n * \t\t});\n */\n\nfunction redirect() {\n\tdebug('handling redirect');\n\tif (arguments.length === 1 && utils.isObject(arguments[0])) {\n\t\t_.extend(this._redirects, arguments[0]);\n\t} else if (arguments.length === 2 && 'string' === typeof arguments[0] && 'string' === typeof arguments[1]) {\n\t\tthis._redirects[arguments[0]] = arguments[1];\n\t}\n\t\n\treturn this;\n\t\n}\n\nmodule.exports = redirect;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/render.js":"var _ = require('underscore');\nvar cloudinary = require('cloudinary');\nvar debug = require('debug')('keystone:core:render');\nvar fs = require('fs');\nvar jade = require('jade');\nvar moment = require('moment');\nvar numeral = require('numeral');\nvar utils = require('keystone-utils');\n\n/**\n * Renders a Keystone View\n *\n * @api private\n */\n\nvar templateCache = {};\n\nfunction render(req, res, view, ext) {\n\n\tvar keystone = this;\n\n\tvar templatePath = __dirname + '/../../templates/views/' + view + '.jade';\n\n\tdebug('rendering ' + templatePath);\n\n\tvar jadeOptions = {\n\t\tfilename: templatePath,\n\t\tpretty: keystone.get('env') !== 'production'\n\t};\n\n\t// TODO: Allow custom basePath for extensions... like this or similar\n\t// if (keystone.get('extensions')) {\n\t// \tjadeOptions.basedir = keystone.getPath('extensions') + '/templates';\n\t// }\n\n\tvar compileTemplate = function() {\n\t\tdebug('compiling');\n\t\treturn jade.compile(fs.readFileSync(templatePath, 'utf8'), jadeOptions);\n\t};\n\n\tvar template = keystone.get('viewCache')\n\t\t? templateCache[view] || (templateCache[view] = compileTemplate())\n\t\t: compileTemplate();\n\n\tif (!res.req.flash) {\n\t\tconsole.error('\\nKeystoneJS Runtime Error:\\n\\napp must have flash middleware installed. Try adding \"connect-flash\" to your express instance.\\n');\n\t\tprocess.exit(1);\n\t}\n\tvar flashMessages = {\n\t\tinfo: res.req.flash('info'),\n\t\tsuccess: res.req.flash('success'),\n\t\twarning: res.req.flash('warning'),\n\t\terror: res.req.flash('error'),\n\t\thilight: res.req.flash('hilight')\n\t};\n\n\tvar locals = {\n\t\t_: _,\n\t\tmoment: moment,\n\t\tnumeral: numeral,\n\t\tenv: keystone.get('env'),\n\t\tbrand: keystone.get('brand'),\n\t\tappversion : keystone.get('appversion'),\n\t\tnav: keystone.nav,\n\t\tmessages: _.any(flashMessages, function(msgs) { return msgs.length; }) ? flashMessages : false,\n\t\tlists: keystone.lists,\n\t\tjs: 'javascript:;',// eslint-disable-line no-script-url\n\t\tutils: utils,\n\t\tUser: keystone.lists[keystone.get('user model')],\n\t\tuser: req.user,\n\t\ttitle: 'Keystone',\n\t\tsignout: keystone.get('signout url'),\n\t\tbackUrl: keystone.get('back url') || '/',\n\t\tsection: {},\n\t\tversion: keystone.version,\n\t\tcsrf_header_key: keystone.security.csrf.CSRF_HEADER_KEY,\n\t\tcsrf_token_key: keystone.security.csrf.TOKEN_KEY,\n\t\tcsrf_token_value: keystone.security.csrf.getToken(req, res),\n\t\tcsrf_query: '&' + keystone.security.csrf.TOKEN_KEY + '=' + keystone.security.csrf.getToken(req, res),\n\t\tga: {\n\t\t\tproperty: keystone.get('ga property'),\n\t\t\tdomain: keystone.get('ga domain')\n\t\t},\n\t\twysiwygOptions: {\n\t\t\tenableImages: keystone.get('wysiwyg images') ? true : false,\n\t\t\tenableCloudinaryUploads: keystone.get('wysiwyg cloudinary images') ? true : false,\n\t\t\tadditionalButtons: keystone.get('wysiwyg additional buttons') || '',\n\t\t\tadditionalPlugins: keystone.get('wysiwyg additional plugins') || '',\n\t\t\tadditionalOptions: keystone.get('wysiwyg additional options') || {},\n\t\t\toverrideToolbar: keystone.get('wysiwyg override toolbar'),\n\t\t\tskin: keystone.get('wysiwyg skin') || 'keystone',\n\t\t\tmenubar: keystone.get('wysiwyg menubar'),\n\t\t\timportcss: keystone.get('wysiwyg importcss') || ''\n\t\t}\n\t};\n\n\t// optional extensions to the local scope\n\t_.extend(locals, ext);\n\n\t// add cloudinary locals if configured\n\tif (keystone.get('cloudinary config')) {\n\t\ttry {\n\t\t\tdebug('adding cloudinary locals');\n\t\t\tvar cloudinaryUpload = cloudinary.uploader.direct_upload();\n\t\t\tlocals.cloudinary = {\n\t\t\t\tcloud_name: keystone.get('cloudinary config').cloud_name,\n\t\t\t\tapi_key: keystone.get('cloudinary config').api_key,\n\t\t\t\ttimestamp: cloudinaryUpload.hidden_fields.timestamp,\n\t\t\t\tsignature: cloudinaryUpload.hidden_fields.signature,\n\t\t\t\tprefix: keystone.get('cloudinary prefix') || '',\n\t\t\t\tfolders: keystone.get('cloudinary folders'),\n\t\t\t\tuploader: cloudinary.uploader\n\t\t\t};\n\t\t\tlocals.cloudinary_js_config = cloudinary.cloudinary_js_config();\n\t\t} catch(e) {\n\t\t\tif (e === 'Must supply api_key') {\n\t\t\t\tthrow new Error('Invalid Cloudinary Config Provided\\n\\n' +\n\t\t\t\t\t'See http://keystonejs.com/docs/configuration/#services-cloudinary for more information.');\n\t\t\t} else {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}\n\n\t// fieldLocals defines locals that are provided to each field's `render` method\n\tlocals.fieldLocals = _.pick(locals, '_', 'moment', 'numeral', 'env', 'js', 'utils', 'user', 'cloudinary');\n\n\tvar html = template(_.extend(locals, ext));\n\n\tdebug('sending down html');\n\tres.send(html);\n}\n\nmodule.exports = render;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/routes.js":"var debug = require('debug')('keystone:core:routes');\n\n/**\n * Adds bindings for the keystone routes\n *\n * ####Example:\n *\n *     var app = express();\n *     app.use(...); // middleware, routes, etc. should come before keystone is initialised\n *     keystone.routes(app);\n *\n * @param {Express()} app\n * @api public\n */\nfunction routes(app) {\n\tthis.app = app;\n\tvar keystone = this;\n\n\t// ensure keystone nav has been initialised\n\tif (!this.nav) {\n\t\tdebug('setting up nav');\n\t\tthis.nav = this.initNav();\n\t}\n\n\t// Cache compiled view templates if we are in Production mode\n\tthis.set('view cache', this.get('env') === 'production');\n\n\t// Session API\n\t// TODO: this should respect keystone auth options\n\tapp.get('/keystone/api/session', require('../../admin/api/session/get'));\n\tapp.post('/keystone/api/session/signin', require('../../admin/api/session/signin'));\n\tapp.post('/keystone/api/session/signout', require('../../admin/api/session/signout'));\n\n\t// Bind auth middleware (generic or custom) to /keystone* routes, allowing\n\t// access to the generic signin page if generic auth is used\n\tif (this.get('auth') === true) {\n\t\tif (!this.get('signout url')) {\n\t\t\tthis.set('signout url', '/keystone/signout');\n\t\t}\n\t\tif (!this.get('signin url')) {\n\t\t\tthis.set('signin url', '/keystone/signin');\n\t\t}\n\t\tif (!this.nativeApp || !this.get('session')) {\n\t\t\tapp.all('/keystone*', this.session.persist);\n\t\t}\n\t\tapp.all('/keystone/signin', require('../../admin/routes/views/signin'));\n\t\tapp.all('/keystone/signout', require('../../admin/routes/views/signout'));\n\t\tapp.all('/keystone*', this.session.keystoneAuth);\n\t} else if ('function' === typeof this.get('auth')) {\n\t\tapp.all('/keystone*', this.get('auth'));\n\t}\n\n\tfunction initList(respectHiddenOption) {\n\t\treturn function(req, res, next) {\n\t\t\treq.list = keystone.list(req.params.list);\n\n\t\t\tif (!req.list || (respectHiddenOption && req.list.get('hidden'))) {\n\t\t\t\tdebug('could not find list ', req.params.list);\n\t\t\t\treq.flash('error', 'List ' + req.params.list + ' could not be found.');\n\t\t\t\treturn res.redirect('/keystone');\n\t\t\t}\n\n\t\t\tdebug('getting list ', req.params.list);\n\t\t\tnext();\n\t\t};\n\t}\n\n\tdebug('setting keystone Admin Route');\n\tapp.all('/keystone', require('../../admin/routes/views/home'));\n\n\t// Email test routes\n\tif (this.get('email tests')) {\n\t\tdebug('setting email test routes');\n\t\tthis.bindEmailTestRoutes(app, this.get('email tests'));\n\t}\n\n\t// Cloudinary API for selecting an existing image / upload a new image\n\tif (keystone.get('cloudinary config')) {\n\t\tdebug('setting cloudinary api');\n\t\tapp.get('/keystone/api/cloudinary/get', require('../../admin/api/cloudinary').get);\n\t\tapp.get('/keystone/api/cloudinary/autocomplete', require('../../admin/api/cloudinary').autocomplete);\n\t\tapp.post('/keystone/api/cloudinary/upload', require('../../admin/api/cloudinary').upload);\n\t}\n\n\t// Init API request helpers\n\tapp.use('/keystone/api', function(req, res, next) {\n\t\tres.apiError = function(key, err) {\n\t\t\tvar statusCode = 500;\n\t\t\tif (key === 404) {\n\t\t\t\tstatusCode = 404;\n\t\t\t\tkey = null;\n\t\t\t\tkey = 'not found';\n\t\t\t}\n\t\t\tif (!key) {\n\t\t\t\tkey = 'unknown error';\n\t\t\t}\n\t\t\tif (!err) {\n\t\t\t\terr = 'API Error';\n\t\t\t}\n\t\t\tif (typeof err === 'object' && err.message) {\n\t\t\t\terr = err.message;\n\t\t\t}\n\t\t\tres.status(statusCode);\n\t\t\tres.json({ err: err, key: key });\n\t\t};\n\t\tnext();\n\t});\n\n\t// Generic Lists API\n\tapp.all('/keystone/api/:list/:action(autocomplete|order|create|fetch)', initList(), require('../../admin/api/list'));\n\tapp.post('/keystone/api/:list/delete', initList(), require('../../admin/api/list/delete'));\n\tapp.get('/keystone/api/:list', initList(), require('../../admin/api/list/get'));\n\tapp.get('/keystone/api/:list/:id', initList(), require('../../admin/api/item/get'));\n\tapp.post('/keystone/api/:list/:id/delete', initList(), require('../../admin/api/item/delete'));\n\n\tapp.all('/keystone/download/:list', initList(), require('../../admin/api/download'));\n\n\t// Admin-UI API\n\tapp.all('/keystone/:list/:page([0-9]{1,5})?', initList(true), require('../../admin/routes/views/list'));\n\tapp.all('/keystone/:list/:item', initList(true), require('../../admin/routes/views/item'));\n\n\treturn this;\n}\n\nmodule.exports = routes;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/start.js":"/**\n * Configures and starts a Keystone app in encapsulated mode.\n *\n * Connects to the database, runs updates and listens for incoming requests.\n *\n * Events are fired during initialisation to allow customisation, including:\n *\n *   - onMount\n *   - onStart\n *   - onHttpServerCreated\n *   - onHttpsServerCreated\n *\n * If the events argument is a function, it is assumed to be the started event.\n *\n *\n * ####Options:\n *\n * Keystone supports the following options specifically for running in encapsulated mode:\n *\n *   - name\n *   - port\n *   - views\n *   - view engine\n *   - compress\n *   - favico\n *   - less\n *   - static\n *   - headless\n *   - logger\n *   - cookie secret\n *   - session\n *   - 404\n *   - 500\n *   - routes\n *   - locals\n *   - auto update\n *   - ssl\n *   - sslport\n *   - sslkey\n *   - sslcert\n *\n *\n * @api public\n */\n\nvar fs = require('fs');\nvar debug = require('debug')('keystone:core:start');\nvar https = require('https');\n\nvar dashes = '\\n------------------------------------------------\\n';\n\nfunction start(events) {\n\t\n\t// Validate arguments\n\t\n\tif ('function' === typeof events) {\n\t\tevents = { onStart: events };\n\t}\n\t\n\tif (!events) events = {};\n\t\n\t// Ensure Keystone has been initialised\n\t\n\tif (!this.app) {\n\t\tthrow new Error('KeystoneJS Initialisaton Error:\\n\\napp must be initialised. Call keystone.init() or keystone.connect(new Express()) first.\\n\\n');\n\t}\n\t\n\t// Localise references to this for closures\n\t\n\tvar keystone = this,\n\t\tapp = this.app;\n\n\t// Prebuild the Admin Resources\n\tthis.adminApp.staticRouter.prebuild();\n\n\t// Maintain passed in onMount binding but override to start http servers\n\t// (call user-defined onMount first if present)\n\t\n\tvar onMount = events.onMount;\n\t\n\tevents.onMount = function() {\n\t\t\n\t\tonMount && onMount();// eslint-disable-line no-unused-expressions\n\t\t\n\t\tvar startupMessages = ['KeystoneJS Started:'],\n\t\t\twaitForServers = 3;\n\t\t\t\n\t\t// Log the startup messages and calls the onStart method\n\t\t\n\t\tvar serverStarted = function() {\n\t\t\twaitForServers--;\n\t\t\tif (waitForServers) return;\n\t\t\tif (keystone.get('logger')) {\n\t\t\t\tconsole.log(dashes + startupMessages.join('\\n') + dashes);\n\t\t\t}\n\t\t\tdebug('server starting');\n\t\t\tevents.onStart && events.onStart();// eslint-disable-line no-unused-expressions\n\t\t};\n\t\t\n\t\t// Create the http server and listens to the specified port with default port specified\n\t\t\n\t\tvar host = keystone.get('host'),\n\t\t\tport = keystone.get('port'),\n\t\t\tssl = keystone.get('ssl'),\n\t\t\tunixSocket = keystone.get('unix socket'),\n\t\t\tletsencrypt = keystone.get('letsencrypt'),\n\t\t\thttpReadyMsg;\n\t\t\n\t\tif (letsencrypt && !unixSocket) {\n\t\t\twaitForServers++;\n\t\t\trequire('../../server/startLetsEncrypt')(keystone, app, function (err, msg) {\n\t\t\t\tif (err) { throw err; }\n\t\t\t\tstartupMessages.push(msg);\n\t\t\t\tserverStarted();\n\t\t\t});\n\t\t}\n\t\tif (ssl !== 'only' && !letsencrypt && !unixSocket) {\n\t\t\thttpReadyMsg = keystone.get('name') + ' is ready on ';\n\t\t\t\n\t\t\tif (host) {\n\t\t\t\thttpReadyMsg += 'http://' + host;\n\t\t\t\tif (port) {\n\t\t\t\t\thttpReadyMsg += ':' + port;\n\t\t\t\t} else {\n\t\t\t\t\thttpReadyMsg += ':3000';\n\t\t\t\t}\n\t\t\t} else if (port){\n\t\t\t\thttpReadyMsg += 'port ' + port;\n\t\t\t} else {\n\t\t\t\thttpReadyMsg += 'port 3000';\n\t\t\t}\n\t\t\t\n\t\t\tvar httpStarted = function(msg) {\n\t\t\t\treturn function() {\n\t\t\t\t\tstartupMessages.push(msg);\n\t\t\t\t\tserverStarted();\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tif (host) {\n\t\t\t\tkeystone.httpServer = app.listen(port || 3000, host, httpStarted(httpReadyMsg));\n\t\t\t} else {\n\t\t\t\tkeystone.httpServer = app.listen(port || 3000, httpStarted(httpReadyMsg));\n\t\t\t}\n\t\t\tevents.onHttpServerCreated && events.onHttpServerCreated();// eslint-disable-line no-unused-expressions\n\t\t} else {\n\t\t\twaitForServers--;\n\t\t}\n\t\t\n\t\tif (ssl && !letsencrypt && !unixSocket) {\n\t\t\t\n\t\t\tdebug('start the ssl server');\n\t\t\tvar sslOpts = keystone.get('https server options') || {};\n\t\t\t\n\t\t\tif (keystone.get('ssl cert') && fs.existsSync(keystone.getPath('ssl cert'))) {\n\t\t\t\tsslOpts.cert = fs.readFileSync(keystone.getPath('ssl cert'));\n\t\t\t}\n\t\t\tif (keystone.get('ssl key') && fs.existsSync(keystone.getPath('ssl key'))) {\n\t\t\t\tsslOpts.key = fs.readFileSync(keystone.getPath('ssl key'));\n\t\t\t}\n\t\t\tif (keystone.get('ssl ca') && fs.existsSync(keystone.getPath('ssl ca'))) {\n\t\t\t\tsslOpts.ca = fs.readFileSync(keystone.getPath('ssl ca'));\n\t\t\t}\n\t\t\t\n\t\t\tif (!sslOpts.key || !sslOpts.cert) {\n\t\t\t\t\n\t\t\t\tif (ssl === 'only') {\n\t\t\t\t\tconsole.log(keystone.get('name') + ' failed to start: invalid ssl configuration');\n\t\t\t\t\tprocess.exit();\n\t\t\t\t} else {\n\t\t\t\t\tstartupMessages.push('Warning: Invalid SSL Configuration');\n\t\t\t\t\tserverStarted();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tvar httpsStarted = function(msg) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tstartupMessages.push(msg);\n\t\t\t\t\t\tserverStarted();\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tkeystone.httpsServer = https.createServer(sslOpts, app);\n\t\t\t\tevents.onHttpsServerCreated && events.onHttpsServerCreated();// eslint-disable-line no-unused-expressions\n\t\t\t\t\n\t\t\t\tvar sslHost = keystone.get('ssl host') || host,\n\t\t\t\t\tsslPort = keystone.get('ssl port') || 3001;\n\t\t\t\t\n\t\t\t\tvar httpsReadyMsg = (ssl === 'only') ? keystone.get('name') + ' (SSL) is ready on ' : 'SSL Server is ready on ';\n\t\t\t\t\n\t\t\t\tif (sslHost) {\n\t\t\t\t\tkeystone.httpsServer.listen(sslPort, sslHost, httpsStarted(httpsReadyMsg + 'https://' + sslHost + ':' + sslPort));\n\t\t\t\t} else {\n\t\t\t\t\tvar httpsPortMsg = (keystone.get('ssl port')) ? 'port: ' + keystone.get('ssl port') : 'default port 3001';\n\t\t\t\t\tkeystone.httpsServer.listen(sslPort, httpsStarted(httpsReadyMsg + httpsPortMsg));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\twaitForServers--;\n\t\t}\n\t\t\n\t\tif(unixSocket) {\n\t\t\t\n\t\t\tvar unixSocketStarted = function(msg) {\n\t\t\t\treturn function() {\n\t\t\t\t\tstartupMessages.push(msg);\n\t\t\t\t\tserverStarted();\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\thttpReadyMsg = keystone.get('name') + ' is ready on ' + unixSocket;\n\t\t\t\n\t\t\tfs.unlink(unixSocket, function(err) {// eslint-disable-line no-unused-vars, handle-callback-err\n\t\t\t\tkeystone.httpServer = app.listen(unixSocket, unixSocketStarted(httpReadyMsg));\n\t\t\t\tevents.onSocketServerCreated && events.onSocketServerCreated();// eslint-disable-line no-unused-expressions\n\t\t\t\tfs.chmod(unixSocket, 0x777, function(){\n\t\t\t\t\t// set permissions\n\t\t\t\t});\n\t\t\t});\n\t\t\t\n\t\t} else {\n\t\t\twaitForServers--;\n\t\t}\n\t\t\n\t\tprocess.on('uncaughtException', function(e) {\n\t\t\tif (e.code === 'EADDRINUSE') {\n\t\t\t\tconsole.log(dashes +\n\t\t\t\t\tkeystone.get('name') + ' failed to start: address already in use\\n' +\n\t\t\t\t\t'Please check you are not already running a server on the specified port.\\n');\n\t\t\t\tprocess.exit();\n\t\t\t}/* else if (e.code === 'ECONNRESET') {\n\t\t\t\t// Connection reset by peer, ignore it instead of exiting server with a throw.\n\t\t\t\t// Disabled for release 0.2.16 while further research is being done.\n\t\t\t\tconsole.log('Connection reset by peer');\n\t\t\t\tconsole.log(e);\n\t\t\t} */else {\n\t\t\t\tconsole.log(e.stack || e);\n\t\t\t\tprocess.exit(1);\n\t\t\t}\n\t\t});\n\t\t\n\t};\n\t\n\tdebug('mount the express app');\n\tthis.mount(events);\n\t\n\treturn this;\n\t\n}\n\nmodule.exports = start;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/core/wrapHTMLError.js":"/**\n * Wraps an error in simple HTML to be sent as a response to the browser\n *\n * @api public\n */\n\nfunction wrapHTMLError(title, err) {\n\treturn '<html><head><meta charset=\\'utf-8\\'><title>Error</title>' +\n\t'<link rel=\\'stylesheet\\' href=\\'/keystone/styles/error.css\\'>' +\n\t'</head><body><div class=\\'error\\'><h1 class=\\'error-title\\'>' + title + '</h1>' +\n\t'<div class=\"error-message\">' + (err || '') + '</div></div></body></html>';\n}\n\nmodule.exports = wrapHTMLError;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/admin/app/static.js":"/**\n * Returns an Express Router with bindings for the Admin UI static resources,\n * i.e files, less and browserified scripts.\n *\n * Should be included before other middleware (e.g. session management,\n * logging, etc) for reduced overhead.\n */\n\nvar browserify = require('./browserify');\nvar express = require('express');\nvar less = require('less-middleware');\nvar path = require('path');\nvar router = express.Router();\n\n/* Prepare browserify bundles */\n\nvar bundles = {\n\tfields: browserify('fields.js', 'FieldTypes'),\n\thome: browserify('views/home.js'),\n\titem: browserify('views/item.js'),\n\tlist: browserify('views/list.js')\n};\n\nrouter.prebuild = function() {\n\tbundles.fields.build();\n\tbundles.home.build();\n\tbundles.item.build();\n\tbundles.list.build();\n};\n\n/* Prepare LESS options */\n\nvar reactSelectPath = path.join(path.dirname(require.resolve('react-select')), '..');\n\nvar lessOptions = {\n\trender: {\n\t\tmodifyVars: {\n\t\t\treactSelectPath: JSON.stringify(reactSelectPath)\n\t\t}\n\t}\n};\n\n/* Configure router */\n\nrouter.use('/styles', less(path.join(__dirname, '../public/styles'), lessOptions));\nrouter.use(express.static(path.join(__dirname, '../public')));\nrouter.get('/js/fields.js', bundles.fields.serve);\nrouter.get('/js/home.js', bundles.home.serve);\nrouter.get('/js/item.js', bundles.item.serve);\nrouter.get('/js/list.js', bundles.list.serve);\n\nmodule.exports = router;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/admin/app/browserify.js":"var babelify = require('babelify');\nvar browserify = require('browserify');\nvar chalk = require('chalk');\nvar crypto = require('crypto');\nvar moment = require('moment');\nvar packages = require('../packages');\nvar path = require('path');\nvar watchify = require('watchify');\n\nvar basedir = path.resolve(__dirname + '/../src/');\nvar devMode = process.env.KEYSTONE_DEV === 'true';\n\nfunction ts() {\n\treturn chalk.gray(moment().format('YYYY-MM-DD HH:MM:SS '));\n}\n\nfunction logInit(file) {\n\tconsole.log(chalk.grey('Watching ' + chalk.black.underline('keystone/admin/src/' + file) + ' for changes...'));\n}\n\nfunction logRebuild(file) {\n\tconsole.log(ts() + chalk.green('rebuilt ' + chalk.underline(file)));\n}\n\nfunction logError(file, err) {\n\tconsole.log(ts() + chalk.red('error building ' + chalk.underline(file) + ':') + '\\n' + err.message);\n}\n\nmodule.exports = function(file, name) {\n\tvar b;\n\tvar building = false;\n\tvar queue = [];\n\tvar ready;\n\tvar src;\n\tfunction build() {\n\t\tif (building) return;\n\t\tbuilding = true;\n\t\tvar opts = { basedir: basedir };\n\t\tif (devMode) {\n\t\t\tlogInit(file);\n\t\t\topts.cache = {};\n\t\t\topts.packageCache = {};\n\t\t}\n\t\tif (name) {\n\t\t\tb = browserify(opts);\n\t\t\tb.require('./' + file, { expose: name });\n\t\t} else {\n\t\t\tb = browserify('./' + file, opts);\n\t\t}\n\t\tb.transform(babelify.configure({\n\t\t\tignore: ['**/lib/**']\n\t\t}));\n\t\tb.exclude('FieldTypes');\n\t\tpackages.forEach(function(i) {\n\t\t\tb.exclude(i);\n\t\t});\n\t\tif (devMode) {\n\t\t\tb = watchify(b);\n\t\t}\n\t\tb.bundle(function(err, buff) {\n\t\t\tif (err) return logError(file, err);\n\t\t\tsrc = buff;\n\t\t\tready = true;\n\t\t\tqueue.forEach(function(reqres) {\n\t\t\t\tsend.apply(null, reqres);\n\t\t\t});\n\t\t});\n\t\tb.on('update', function() {\n\t\t\tb.bundle(function(err, buff) {\n\t\t\t\tif (err) return logError(file, err);\n\t\t\t\telse logRebuild(file);\n\t\t\t\tsrc = buff;\n\t\t\t});\n\t\t});\n\t}\n\tfunction serve(req, res) {\n\t\tif (!ready) {\n\t\t\tbuild();\n\t\t\tqueue.push([req, res]);\n\t\t\treturn;\n\t\t}\n\t\tsend(req, res);\n\t}\n\tfunction send(req, res) {\n\t\tres.setHeader('Content-Type', 'application/javascript');\n\t\tvar etag = crypto.createHash('md5').update(src).digest('hex').slice(0, 6);\n\t\tif (req.get && (etag === req.get('If-None-Match'))) {\n\t\t\tres.status(304);\n\t\t\tres.end();\n\t\t}\n\t\telse {\n\t\t\tres.setHeader('ETag', etag);\n\t\t\tres.setHeader('Vary', 'Accept-Encoding');\n\t\t\tres.send(src);\n\t\t}\n\t}\n\treturn {\n\t\tserve: serve,\n\t\tbuild: build\n\t};\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/admin/packages.js":"// This file exports the common packages required by the Admin UI.\n// \n// It is used to build /public/js/packages.js, and exclude these packages from\n// the Admin UI bundle generated by browserify.\nmodule.exports = [\n\t'bytes',\n\t'classnames',\n\t'marked',\n\t'moment',\n\t'numeral',\n\t'pikaday',\n\t'react',\n\t'react-select',\n\t'react-alt-text',\n\t'react/addons',\n\t'superagent'\n];\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/middleware/api.js":"/**\n * Adds shortcut methods for JSON API responses:\n * \n *   * `res.apiResponse(data)`\n *   * `res.apiError(key, err, msg, code)`\n *   * `res.apiNotFound(err, msg)`\n *   * `res.apiNotAllowed(err, msg)`\n *\n * ####Example:\n *\n *     app.all('/api*', keystone.middleware.api);\n *\n * @param {app.request} req\n * @param {app.response} res\n * @param {function} next\n * @api public\n */\n\n// The exported function returns a closure that retains\n// a reference to the keystone instance, so it can be\n// passed as middeware to the express app.\n\nexports = module.exports = function(keystone) {\n\treturn function initAPI(req, res, next) {\n\t\t\n\t\tres.apiResponse = function(data) {\n\t\t\tif (req.query.callback) {\n\t\t\t\tres.jsonp(data);\n\t\t\t} else {\n\t\t\t\tres.json(data);\n\t\t\t}\n\t\t};\n\n\t\tres.apiError = function(key, err, msg, code) {\n\t\t\tmsg = msg || 'Error';\n\t\t\tkey = key || 'unknown error';\n\t\t\tmsg += ' (' + key + ')';\n\t\t\tif (keystone.get('logger')) {\n\t\t\t\tconsole.log(msg + (err ? ':' : ''));\n\t\t\t\tif (err) {\n\t\t\t\t\tconsole.log(err);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.status(code || 500);\n\t\t\tres.apiResponse({ error: key || 'error', detail: err });\n\t\t};\n\t\t\n\t\tres.apiNotFound = function (err, msg) {\n\t\t\tres.apiError('data not found', err, msg || 'not found', 404);\n\t\t};\n\t\t\n\t\tres.apiNotAllowed = function (err, msg) {\n\t\t\tres.apiError('access not allowed', err, msg || 'not allowed', 403);\n\t\t};\n\n\t\tnext();\n\t};\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/middleware/cors.js":"/**\n * Adds CORS headers to the response\n *\n * ####Example:\n *\n *     app.all('/api*', keystone.middleware.cors);\n *\n * @param {app.request} req\n * @param {app.response} res\n * @param {function} next\n * @api public\n */\n\n// The exported function returns a closure that retains\n// a reference to the keystone instance, so it can be\n// passed as middeware to the express app.\n\nexports = module.exports = function(keystone) {\n\treturn function cors(req, res, next) {\n\t\t\n\t\tvar origin = keystone.get('cors allow origin');\n\t\tif (origin) {\n\t\t\tres.header('Access-Control-Allow-Origin', origin === true ? '*' : origin);\n\t\t}\n\t\t\n\t\tif (keystone.get('cors allow methods') !== false) {\n\t\t\tres.header('Access-Control-Allow-Methods', keystone.get('cors allow methods') || 'GET,PUT,POST,DELETE');\n\t\t}\n\t\tif (keystone.get('cors allow headers') !== false) {\n\t\t\tres.header('Access-Control-Allow-Headers', keystone.get('cors allow headers') || 'Content-Type, Authorization');\n\t\t}\n\n\t\tnext();\n\t};\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/email.js":"var _ = require('underscore');\nvar fs = require('fs');\nvar keystone = require('../');\nvar mandrillapi = require('mandrill-api');\nvar mailgunapi = require('mailgun-js');\nvar juice = require('juice');\nvar moment = require('moment');\nvar path = require('path');\nvar util = require('util');\nvar utils = require('keystone-utils');\n\nvar templateCache = {};\n\n// Get view engine\nvar emailsEngine, emailsEnginelib;\nif (keystone.get('custom engine')) {\n\temailsEngine = keystone.get('view engine');\n\temailsEnginelib = keystone.get('custom engine');\n} else {\n\temailsEngine = 'jade';\n\temailsEnginelib = require('jade');\n}\n\nvar defaultConfig = {\n\ttemplateExt: emailsEngine,\n\ttemplateEngine: emailsEnginelib,\n\ttemplateBasePath: path.normalize(path.join(__dirname, '..', 'templates', 'helpers', 'emails')),\n};\nif (!_.isEqual(keystone.get('email transport'), 'mailgun')) {\n\tdefaultConfig.mandrill = {\n\t\ttrack_opens: true,\n\t\ttrack_clicks: true,\n\t\tpreserve_recipients: false,\n\t\tinline_css: true,\n\t};\n\tdefaultConfig.templateMandrillName = null; // Mandrill template\n\tdefaultConfig.templateForceHtml = false; // Force html render\n}\n\n/** Custom Errors */\n\n// TOTO: Uses arguments.callee for the stack trace, which prevents optimisation.\n// I've marked these to be ignored by jshint but we should find a better way.\n\nvar ErrorNoEmailTemplateName = function() {\n\tError.apply(this, arguments);\n\tError.captureStackTrace(this, arguments.callee);\n\tthis.message = 'No email templateName specified.';\n\tthis.name = 'ErrorNoEmailTemplateName';\n};\nutil.inherits(ErrorNoEmailTemplateName, Error);\n\nvar ErrorEmailsPathNotSet = function() {\n\tError.apply(this, arguments);\n\tError.captureStackTrace(this, arguments.callee);\n\tthis.message = 'Keystone has not been configured for email support. Set the `emails` option in your configuration.';\n\tthis.name = 'ErrorEmailsPathNotSet';\n};\nutil.inherits(ErrorEmailsPathNotSet, Error);\n\nvar ErrorEmailOptionsRequired = function() {\n\tError.apply(this, arguments);\n\tError.captureStackTrace(this, arguments.callee);\n\tthis.message = 'The keystone.Email class requires a templateName or options argument to be provided.';\n\tthis.name = 'ErrorEmailOptionsRequired';\n};\nutil.inherits(ErrorEmailsPathNotSet, Error);\n\n/** Helper methods */\n\nvar getEmailsPath = function() {\n\tvar path = keystone.getPath('emails');\n\tif (path) {\n\t\treturn path;\n\t}\n\tthrow new ErrorEmailsPathNotSet();\n};\n\nfunction buildAddress (email, name) {\n\tif (Array.isArray(email)) {\n\t\treturn email.map(function (to) { return to.name + ' <' + to.email + '>'; }).join(',');\n\t} else {\n\t\treturn name ? name + ' <' + email + '>' : email;\n\t}\n}\n\n/**\n * Flatten an object\n * @param  {Object} obj   Source object\n * @param  {String} delim Delimeter\n * @return {Object}       Flat object\n */\nvar flattenObject = function(obj, delim) {\n\tdelim = delim || '_';\n\tvar _ret = {};\n\n\tfor (var key in obj) {\n\t\tif (!obj.hasOwnProperty(key)) continue;\n\n\t\tif ((typeof obj[key]) === 'object' && obj[key] !== null) {\n\t\t\tvar _flat = flattenObject(obj[key], delim);\n\t\t\tfor (var next in _flat) {\n\t\t\t\tif (!_flat.hasOwnProperty(next)) continue;\n\n\t\t\t\t_ret[key + delim + next] = _flat[next];\n\t\t\t}\n\t\t} else {\n\t\t\t_ret[key] = obj[key];\n\t\t}\n\t}\n\treturn _ret;\n};\n\n/**\n * Converts javascript Objects into\n * Mandrill's vars objects.\n *\n * @param  {Mixed}  _var Object to parse\n * @return {Array}       An array of vars\n */\nvar objToMandrillVars = function (_var) {\n\tvar _new = [];\n\tif ('object' === typeof _var) {\n\t\tvar _flat = flattenObject(_var, '_');\n\t\t_.each(_flat, function(value, key) {\n\t\t\t_new.push({ name: key, content: value });\n\t\t});\n\t\treturn _new;\n\t}\n\treturn _var;\n};\n\n/** CSS Helper methods */\n\nvar templateCSSMethods = {\n\tshadeColor: function(color, percent) {\n\t\t/* eslint-disable space-infix-ops */\n\t\tvar num = parseInt(color.slice(1), 16), amt = Math.round(2.55 * percent), R = (num >> 16) + amt, G = (num >> 8 & 0x00FF) + amt, B = (num & 0x0000FF) + amt;\n\t\treturn '#' + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);\n\t\t/* eslint-enable */\n\t}\n};\n\n\n\n/**\n * Email Class\n * ===========\n *\n * Helper class for sending emails with Mandrill.\n *\n * New instances take a `templatePath` string which must be a folder in the\n * emails path, and must contain either `templateName/email.templateExt` or `templateName.templateExt`\n * which is used as the template for the HTML part of the email.\n *\n * Once created, emails can be rendered or sent.\n *\n * Requires the `emails` path option and the `mandrill api key` option to be\n * set on Keystone.\n *\n * @api public\n */\n\nvar Email = function(options) {\n\t// Passing a string will use Email.defaults for everything but template name\n\tif ('string' === typeof options) {\n\t\toptions = {\n\t\t\ttemplateName: options\n\t\t};\n\t} else if (!utils.isObject(options)) {\n\t\tthrow new ErrorEmailOptionsRequired();\n\t}\n\n\tthis.templateMandrillName = options.templateMandrillName;\n\tthis.templateMandrillContent = _.isArray(options.templateMandrillContent) ? options.templateMandrillContent : [];\n\n\tthis.templateName = options.templateName || this.templateMandrillName;\n\tthis.templateExt = options.templateExt || Email.defaults.templateExt;\n\tthis.templateEngine = options.templateEngine || Email.defaults.templateEngine;\n\tthis.templateBasePath = options.templateBasePath || Email.defaults.templateBasePath;\n\tthis.templateCompile = options.templateCompile || Email.defaults.templateCompile;\n\tthis.templateRender = options.templateRender || Email.defaults.templateRender;\n\n\tif (!this.templateName) {\n\t\tthrow new ErrorNoEmailTemplateName();\n\t}\n\n\treturn this;\n\n};\n\n/**\n * Renders the email and passes it to the callback. Used by `email.send()` but\n * can also be called directly to generate a preview.\n *\n * @param {Object} locals - object of local variables provided to the template\n * @param {Function} callback(err, email)\n *\n * @api public\n */\n\nEmail.prototype.render = function(locals, callback) {\n\n\tif ('function' === typeof locals && !callback) {\n\t\tcallback = locals;\n\t\tlocals = {};\n\t}\n\n\tlocals = ('object' === typeof locals) ? locals : {};\n\tcallback = ('function' === typeof callback) ? callback : function() {};\n\n\tif (keystone.get('email locals')) {\n\t\t_.defaults(locals, keystone.get('email locals'));\n\t}\n\n\t_.defaults(locals, {\n\t\tpretty: true,\n\t\t_: _,\n\t\tmoment: moment,\n\t\tutils: utils,\n\t\tsubject: '(no subject)',\n\t\tbrand: keystone.get('brand'),\n\t\ttheme: {},\n\t\tcss: templateCSSMethods\n\t});\n\n\tif (!locals.theme.buttons) {\n\t\tlocals.theme.buttons = {};\n\t}\n\n\tthis.compileTemplate(function(err) {\n\t\tif (err) {\n\t\t\treturn callback(err);\n\t\t}\n\n\t\tvar html = null;\n\t\tvar template = templateCache[this.templateName];\n\t\tif (this.templateRender) {\n\t\t\thtml = this.templateRender(template, locals);\n\t\t} else if (typeof template === 'function') {\n\t\t\thtml = template(locals);\n\t\t} else if (typeof template.render === 'function') {\n\t\t\thtml = template.render(locals);\n\t\t} else {\n\t\t\treturn callback({\n\t\t\t\tfrom: 'Email.compileTemplate',\n\t\t\t\tkey: 'invalid rendering function',\n\t\t\t\tmessage: 'no template rendering function could be found.',\n\t\t\t});\n\t\t}\n\n\t\t// ensure extended characters are replaced\n\t\thtml = html.replace(/[\\u007f-\\uffff]/g, function(c) {\n\t\t\treturn '&#x' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4) + ';';\n\t\t});\n\n\t\t// process email rules\n\t\tvar rules = keystone.get('email rules');\n\n\t\tif (rules) {\n\n\t\t\tif (!Array.isArray(rules)) {\n\t\t\t\trules = [rules];\n\t\t\t}\n\n\t\t\t_.each(rules, function(rule) {\n\t\t\t\tif (rule.find && rule.replace) {\n\n\t\t\t\t\tvar find = rule.find,\n\t\t\t\t\t\treplace = rule.replace;\n\n\t\t\t\t\tif ('string' === typeof find) {\n\t\t\t\t\t\tfind = new RegExp(find, 'gi');\n\t\t\t\t\t}\n\n\t\t\t\t\thtml = html.replace(find, replace);\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\n\t\tcallback(null, {\n\t\t\tsubject: locals.subject,\n\t\t\thtml: html\n\t\t});\n\n\t}.bind(this));\n\n};\n\n/**\n * Loads the template. Looks for `templateName.templateExt`, followed by `templateName/email.templateExt`\n *\n * @param {Function} callback(err)\n *\n * @api private\n */\n\nEmail.prototype.loadTemplate = function(callback) {\n\n\tcallback = ('function' === typeof callback) ? callback : function() {};\n\n\tvar fsTemplatePath = path.join(Email.getEmailsPath(), this.templateName + '.' + this.templateExt);\n\n\tfs.readFile(fsTemplatePath, function(err, contents) {\n\t\tif (err) {\n\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\tfsTemplatePath = path.join(Email.getEmailsPath(), this.templateName, 'email.' + this.templateExt);\n\n\t\t\t\tfs.readFile(fsTemplatePath, function(err, contents) {\n\t\t\t\t\tcallback(err, fsTemplatePath, contents);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\treturn callback(err);\n\t\t\t}\n\t\t} else {\n\t\t\treturn callback(err, fsTemplatePath, contents);\n\t\t}\n\n\t}.bind(this));\n\n};\n\n/**\n * Ensures the template for the email has been compiled\n *\n * @param {Function} callback(err)\n *\n * @api private\n */\n\nEmail.prototype.compileTemplate = function(callback) {\n\tcallback = ('function' === typeof callback) ? callback : function() {};\n\n\tif (keystone.get('env') === 'production' && templateCache[this.templateName]) {\n\t\treturn process.nextTick(callback);\n\t}\n\n\tthis.loadTemplate(function(err, filename, contents) {\n\t\tif (err) return callback(err);\n\n\t\tvar template = null;\n\t\tif (this.templateCompile) {\n\t\t\ttemplate = this.templateCompile(this.templateEngine, contents.toString(), Email.defaults.compilerOptions, fs.realpathSync(filename));\n\t\t} else {\n\t\t\ttemplate = this.templateEngine.compile(contents.toString(), Email.defaults.compilerOptions || { filename: fs.realpathSync(filename), basedir: this.templateBasePath }, fs.realpathSync(filename));\n\t\t}\n\n\t\ttemplateCache[this.templateName] = template;\n\n\t\tcallback();\n\n\t}.bind(this));\n\n};\n\n/**\n * Prepares the email, with or without render\n *\n * @param  {Object}   options  options to render the email\n * @param  {Function} callback(err, message)\n *\n * @api private\n */\nEmail.prototype.prepare = function(options, callback) {\n\tvar locals = options;\n\n\tif (arguments.length === 3 || !utils.isFunction(callback)) {\n\t\tcallback = arguments[2];\n\t\toptions = arguments[1] || arguments[0];\n\t}\n\n\tcallback = ('function' === typeof callback) ? callback : function() {};\n\n\t// Renders an email via Keystone (default behavior)\n\tif (!this.templateMandrillName || this.templateForceHtml) {\n\n\t\tthis.render(locals, function(err, email){\n\n\t\t\t_.extend(options, email);\n\t\t\tthis.buildOptions.call(this, err, options, callback);\n\t\t}.bind(this));\n\t}\n\t// Uses a Mandrill template directly\n\telse {\n\t\tthis.buildOptions.call(this, null, options, callback);\n\t}\n};\n\n/**\n * Build an options object\n *\n * @param  {Object}   options  Input options\n * @param  {Function} callback(err, callback)\n *\n * @api private\n */\nEmail.prototype.buildOptions = function(err, options, callback) {\n\tcallback = ('function' === typeof callback) ? callback : function() {};\n\n\tif (err) {\n\t\treturn callback(err);\n\t}\n\n\tif (!utils.isObject(options)) {\n\t\treturn callback({\n\t\t\tfrom: 'Email.send',\n\t\t\tkey: 'invalid options',\n\t\t\tmessage: 'options object is required'\n\t\t});\n\t}\n\n\tif ('string' === typeof options.from) {\n\t\toptions.fromName = options.from;\n\t\toptions.fromEmail = options.from;\n\t} else if (utils.isObject(options.from)) {\n\t\toptions.fromName = utils.isObject(options.from.name) ? options.from.name.full : options.from.name;\n\t\toptions.fromEmail = options.from.email;\n\t}\n\n\tif (!options.fromName || !options.fromEmail) {\n\t\treturn callback({\n\t\t\tfrom: 'Email.send',\n\t\t\tkey: 'invalid options',\n\t\t\tmessage: 'options.fromName and options.fromEmail are required'\n\t\t});\n\t}\n\tif (_.isEqual(keystone.get('email transport'), 'mailgun')) {\n\t\tif (!options.mailgun) {\n\t\t\tif (!keystone.get('mailgun api key')) {\n\t\t\t\treturn callback({\n\t\t\t\t\tfrom: 'Email.send',\n\t\t\t\t\tkey: 'missing api key',\n\t\t\t\t\tmessage: 'You must either provide a Mailgun API Instance or set the mandrill api key before sending email.',\n\t\t\t\t});\n\t\t\t}\n\t\t\tvar api_key = keystone.get('mailgun api key');\n\t\t\tvar domain = keystone.get('mailgun domain');\n\t\t\toptions.mailgun = new mailgunapi({ apiKey: api_key, domain: domain });\n\t\t}\n\t} else {\n\t\tif (!options.mandrill) {\n\t\t\tif (!keystone.get('mandrill api key')) {\n\t\t\t\treturn callback({\n\t\t\t\t\tfrom: 'Email.send',\n\t\t\t\t\tkey: 'missing api key',\n\t\t\t\t\tmessage: 'You must either provide a Mandrill API Instance or set the mandrill api key before sending email.',\n\t\t\t\t});\n\t\t\t}\n\t\t\toptions.mandrill = new mandrillapi.Mandrill(keystone.get('mandrill api key'));\n\t\t}\n\t}\n\n\toptions.tags = utils.isArray(options.tags) ? options.tags : [];\n\toptions.tags.push('sent:' + moment().format('YYYY-MM-DD'));\n\toptions.tags.push(this.templateName);\n\n\tif (keystone.get('env') === 'development') {\n\t\toptions.tags.push('development');\n\t}\n\n\t/**\n\t * Convert and concat globalMergeVars\n\t */\n\tif (options.globalMergeVars) {\n\t\toptions.global_merge_vars = (options.global_merge_vars || []).concat(objToMandrillVars(options.globalMergeVars));\n\t}\n\n\tvar recipients = [];\n\tvar mergeVars = [];\n\n\toptions.to = Array.isArray(options.to) ? options.to : [options.to];\n\n\tfor (var i = 0; i < options.to.length; i++) {\n\t\tif (typeof options.to[i] === 'string') {\n\t\t\toptions.to[i] = { email: options.to[i] };\n\t\t} else if (typeof options.to[i] === 'object' && options.to[i] !== null) {\n\t\t\tif (!options.to[i].email) {\n\t\t\t\treturn callback({\n\t\t\t\t\tfrom: 'Email.send',\n\t\t\t\t\tkey: 'invalid recipient',\n\t\t\t\t\tmessage: 'Recipient ' + (i + 1) + ' does not have a valid email address.',\n\t\t\t\t});\n\t\t\t}\n\n\t\t} else {\n\t\t\treturn callback({\n\t\t\t\tfrom: 'Email.send',\n\t\t\t\tkey: 'invalid recipient',\n\t\t\t\tmessage: 'Recipient ' + (i + 1) + ' is not a string or an object.',\n\t\t\t});\n\n\t\t}\n\n\t\tvar recipient = { email: options.to[i].email };\n\t\tvar vars = [{ name: 'email', content: recipient.email }];\n\n\t\tif (typeof options.to[i].name === 'string') {\n\t\t\trecipient.name = options.to[i].name;\n\t\t\tvars.push({ name: 'name', content: options.to[i].name });\n\t\t} else if (typeof options.to[i].name === 'object') {\n\t\t\trecipient.name = options.to[i].name.full || '';\n\t\t\tvars.push({ name: 'name', content: options.to[i].name.full || '' });\n\t\t\tvars.push({ name: 'first_name', content: options.to[i].name.first || '' });\n\t\t\tvars.push({ name: 'last_name', content: options.to[i].name.last || '' });\n\t\t}\n\n\t\t// Mandrill template\n\t\tif (recipient.vars) {\n\t\t\tvars.concat(objToMandrillVars(recipient.vars));\n\t\t}\n\n\t\trecipients.push(recipient);\n\n\t\tmergeVars.push({\n\t\t\trcpt: recipient.email,\n\t\t\tvars: vars,\n\t\t});\n\t}\n\n\tvar message = {\n\t\theaders: options.headers,\n\t\tfrom_name: options.fromName,\n\t\tfrom_email: options.fromEmail,\n\t\ttags: options.tags,\n\t\tattachments: options.attachments,\n\t\tto: recipients,\n\t\tglobal_merge_vars: options.global_merge_vars,\n\t\tmerge_vars: mergeVars,\n\t\tasync: true,\n\t};\n\n\tif (options.subject) {\n\t\tmessage.subject = options.subject;\n\t}\n\n\tif (options.html) {\n\t\tmessage.html = options.html;\n\t}\n\n\t_.defaults(message, options.mandrillOptions);\n\t_.defaults(message, Email.defaults.mandrill);\n\n\tvar toSend = {\n\t\tmessage: message,\n\t};\n\n\tif (this.templateMandrillName) {\n\t\ttoSend.template_name = this.templateMandrillName;\n\t\ttoSend.template_content = this.templateMandrillContent;\n\t\tif (_.isArray(options.templateMandrillContent)) {\n\t\t\ttoSend.template_content = toSend.template_content.concat(options.templateMandrillContent);\n\t\t}\n\t}\n\n\tcallback(null, toSend);\n};\n\n/**\n * Sends the email\n *\n * Options:\n *\n * - mandrill\n *   Initialised Mandrill API instance\n *\n * - tags\n *   Array of tags to send to Mandrill\n *\n * - to\n *   Object / String or Array of Objects / Strings to send to, e.g.\n *   ['jed@team9.com.au', { email: 'jed.watson@gmail.com' }]\n *   { email: 'jed@team9.com.au' }\n *   'jed@team9.com.au'\n *\n * - fromName\n *   Name to send from\n *\n * - fromEmail\n *   Email address to send from\n *\n * - headers\n *   Headers to send through with the email\n *\n * For compatibility with older implementations, send supports providing\n * locals and options objects as the first and second arguments, and the\n * callback as the third.\n *\n * @param {Object} options (passed to `email.render()`)\n * @param {Function} callback(err, info)\n *\n * @api private\n */\n\nEmail.prototype.send = function (options, callback) {\n\tvar locals = options;\n\tvar prepareOptions = [locals];\n\n\tif (arguments.length === 3) {\n\t\t// we expect locals, options, callback\n\t\tif (_.isObject(arguments[1])) {\n\t\t\tprepareOptions.push(arguments[1]);\n\t\t}\n\t\tcallback = arguments[2];\n\n\t} else if (arguments.length === 2 && !utils.isFunction(callback)) {\n\t\t// no callback so we expect locals, options\n\t\tif (_.isObject(arguments[1])) {\n\t\t\tprepareOptions.push(arguments[1]);\n\t\t}\n\t\tcallback = function(err, info) {// eslint-disable-line no-unused-vars\n\t\t\tif (err) console.log(err);\n\t\t};\n\n\t} else if (arguments.length === 1) {\n\t\t// we expect options here and it is pushed already\n\t\tcallback = function (err, info) { // eslint-disable-line no-unused-vars\n\t\t\tif (err) console.log(err);\n\t\t};\n\t}\n\n\tprepareOptions.push(function (err, toSend) {\n\t\tif (err) {\n\t\t\treturn callback(err, null);\n\t\t}\n\n\t\tvar onSuccess = function (info) {\n\t\t\tcallback(null, info);\n\t\t};\n\n\t\tvar onFail = function (info) {\n\t\t\tcallback({\n\t\t\t\tfrom: 'Email.send',\n\t\t\t\tkey: 'send error',\n\t\t\t\tmessage: 'Email transport encountered an error and did not send the emails.',\n\t\t\t\tinfo: info,\n\t\t\t});\n\t\t};\n\t\tif (_.isEqual(keystone.get('email transport'), 'mailgun')) {\n\t\t\tvar msg = toSend.message;\n\t\t\tvar data = {\n\t\t\t\tfrom: buildAddress(msg.from_email, msg.from_name),\n\t\t\t\tto: buildAddress(msg.to),\n\t\t\t\tsubject: msg.subject,\n\t\t\t\thtml: juice(msg.html),\n\t\t\t\tattachment: msg.attachments,\n\t\t\t};\n\t\t\treturn process.nextTick(function () {\n\t\t\t\toptions.mailgun.messages().send(data, function (err, body) {\n\t\t\t\t\tif (err) return onFail(err);\n\t\t\t\t\tonSuccess(body);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tif (this.templateMandrillName) {\n\t\t\t\treturn process.nextTick(function () {\n\t\t\t\t\toptions.mandrill.messages.sendTemplate(toSend, onSuccess, onFail);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn process.nextTick(function () {\n\t\t\t\t\toptions.mandrill.messages.send(toSend, onSuccess, onFail);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}.bind(this));\n\n\tthis.prepare.apply(this, prepareOptions);\n};\n\n/**\n * Renders a Mandrill template\n * @param  {Object}   options  Same options that sendTemplate\n * @param  {Function} callback(err, info)\n */\nEmail.prototype.renderMandrill = function (options, callback) {\n\tvar locals = options;\n\tvar prepareOptions = [locals];\n\n\tif (arguments.length === 3 || !utils.isFunction(callback)) {\n\t\tcallback = arguments[2];\n\t\toptions = arguments[1] || arguments[0];\n\t\tprepareOptions.push(options);\n\t}\n\n\tcallback = ('function' === typeof callback) ? callback : function() {};\n\n\tprepareOptions.push(function (err, toSend) {\n\t\tif (err) {\n\t\t\treturn callback(err, null);\n\t\t}\n\n\t\t/**\n\t\t * The object sent to render is not the same as for the sendTemplate\n\t\t * method, so it needs to be changed accordingly.\n\t\t *\n\t\t * https://mandrillapp.com/api/docs/templates.JSON.html#method=render\n\t\t * https://mandrillapp.com/api/docs/messages.JSON.html#method=send-template\n\t\t */\n\n\t\tif (toSend.message.merge_vars && toSend.message.merge_vars.length) {\n\t\t\ttoSend.merge_vars = toSend.message.merge_vars[0].vars;\n\t\t}\n\n\t\tif (toSend.message.global_merge_vars) {\n\t\t\ttoSend.global_merge_vars = toSend.message.global_merge_vars;\n\t\t}\n\n\t\tvar onSuccess = function (info) {\n\t\t\tcallback(null, info);\n\t\t};\n\n\t\tvar onFail = function (info) {\n\t\t\tcallback({\n\t\t\t\tfrom: 'Email.renderMandrill',\n\t\t\t\tkey: 'render error',\n\t\t\t\tmessage: 'Mandrill encountered an error rendering the email.',\n\t\t\t\tinfo: info,\n\t\t\t});\n\t\t};\n\n\t\toptions.mandrill.templates.render(toSend, onSuccess, onFail);\n\t});\n\n\tthis.prepare.apply(this, prepareOptions);\n};\n\nEmail.getEmailsPath = getEmailsPath;\nEmail.templateCache = templateCache;\nEmail.templateCSSMethods = templateCSSMethods;\nEmail.defaults = defaultConfig;\n\nexports = module.exports = Email;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/fields/types/Type.js":"/*!\n * Module dependencies.\n */\nvar _ = require('underscore');\nvar di = require('asyncdi');\nvar marked = require('marked');\nvar Path = require('../../lib/path');\nvar utils = require('keystone-utils');\n\nvar DEFAULT_OPTION_KEYS = [\n\t'path',\n\t'paths',\n\t'type',\n\t'label',\n\t'note',\n\t'size',\n\t'initial',\n\t'required',\n\t'col',\n\t'noedit',\n\t'nocol',\n\t'nosort',\n\t'nofilter',\n\t'indent',\n\t'hidden',\n\t'collapse',\n\t'dependsOn'\n];\n\n/**\n * Field Constructor\n * =================\n *\n * Extended by fieldType Classes, should not be used directly.\n *\n * @api public\n */\nfunction Field(list, path, options) {\n\n\t// Set field properties and options\n\tthis.list = list;\n\tthis._path = new Path(path);\n\tthis.path = path;\n\n\tthis.type = this.constructor.name;\n\tthis.options = utils.options(this.defaults, options);\n\tthis.label = options.label || utils.keyToLabel(this.path);\n\tthis.typeDescription = options.typeDescription || this.typeDescription || this.type;\n\n\t// Add the field to the schema\n\tthis.list.automap(this);\n\tthis.addToSchema();\n\n\t// Warn on required fields that aren't initial\n\tif (this.options.required &&\n        this.options.initial === undefined &&\n        this.options.default === undefined &&\n        !this.options.value &&\n        !this.list.get('nocreate') &&\n        this.path !== this.list.mappings.name\n\t) {\n\t\tconsole.error('\\nError: Invalid Configuration\\n\\n' +\n\t\t\t'Field (' + list.key + '.' + path + ') is required but not initial, and has no default or generated value.\\n' +\n\t\t\t'Please provide a default, remove the required setting, or set initial: false to override this error.\\n');\n\t\tprocess.exit(1);\n\t}\n\n\t// Add pre-save handler to the list if this field watches others\n\tif (this.options.watch) {\n\t\tthis.list.schema.pre('save', this.getPreSaveWatcher());\n\t}\n\n\t// Convert notes from markdown to html\n\tvar note = null;\n\tObject.defineProperty(this, 'note', {\n\t\tget: function() {\n\t\t\treturn (note === null) ? (note = (this.options.note) ? marked(this.options.note) : '') : note;\n\t\t}\n\t});\n\n}\n\n/**\n * Gets the options for the Field, as used by the React components\n */\nField.prototype.getOptions = function() {\n\tif (!this.__options) {\n\t\tthis.__options = {};\n\t\tvar optionKeys = DEFAULT_OPTION_KEYS;\n\t\tif (_.isArray(this._properties)) {\n\t\t\toptionKeys = optionKeys.concat(this._properties);\n\t\t}\n\t\toptionKeys.forEach(function(key) {\n\t\t\tif (this[key]) {\n\t\t\t\tthis.__options[key] = this[key];\n\t\t\t} else if (this.options[key]){\n\t\t\t\tthis.__options[key] = this.options[key];\n\t\t\t}\n\t\t}, this);\n\t\tif (this.getProperties) {\n\t\t\t_.extend(this.__options, this.getProperties());\n\t\t}\n\t\tthis.__options.hasFilterMethod = this.addFilterToQuery ? true : false;\n\t\tthis.__options.defaultValue = this.getDefaultValue();\n\t}\n\treturn this.__options;\n};\n\n/**\n * Validates and returns the size of the field.\n * Defaults to deprecated 'width' option.\n */\nField.prototype.getSize = function() {\n\tif (!this.__size) {\n\t\tvar size = this._fixedSize || this.options.size || this.options.width;\n\t\tif (size !== 'small' && size !== 'medium' && size !== 'large' && size !== 'full') {\n\t\t\tsize = this._defaultSize || 'large';\n\t\t}\n\t\tthis.__size = size;\n\t}\n\treturn this.__size;\n};\n\n/**\n * Gets default value for the field, based on the option or default for the type\n */\nField.prototype.getDefaultValue = function() {\n\treturn this.options.default || '';\n};\n\n/**\n * Gets the field's data from an Item, as used by the React components\n */\nField.prototype.getData = function(item) {\n\treturn item.get(this.path);\n};\n\n/**\n * Field watching implementation\n */\nField.prototype.getPreSaveWatcher = function() {\n\tvar field = this;\n\tvar applyValue;\n\n\tif (this.options.watch === true) {\n\t\t// watch == true means always apply the value method\n\t\tapplyValue = function() { return true; };\n\t} else {\n\t\t// if watch is a string, convert it to a list of paths to watch\n\t\tif (_.isString(this.options.watch)) {\n\t\t\tthis.options.watch = this.options.watch.split(' ');\n\t\t}\n\t\tif (_.isFunction(this.options.watch)) {\n\t\t\tapplyValue = this.options.watch;\n\t\t} else if (_.isArray(this.options.watch)) {\n\t\t\tapplyValue = function(item) {\n\t\t\t\tvar pass = false;\n\t\t\t\tfield.options.watch.forEach(function(path) {\n\t\t\t\t\tif (item.isModified(path)) pass = true;\n\t\t\t\t});\n\t\t\t\treturn pass;\n\t\t\t};\n\t\t} else if (_.isObject(this.options.watch)) {\n\t\t\tapplyValue = function(item) {\n\t\t\t\tvar pass = false;\n\t\t\t\t_.each(field.options.watch, function(value, path) {\n\t\t\t\t\tif (item.isModified(path) && item.get(path) === value) pass = true;\n\t\t\t\t});\n\t\t\t\treturn pass;\n\t\t\t};\n\t\t}\n\t}\n\n\tif (!applyValue) {\n\t\tconsole.error('\\nError: Invalid Configuration\\n\\n' +\n\t\t\t'Invalid watch value (' + this.options.watch + ') provided for ' + this.list.key + '.' + this.path + ' (' + this.type + ')');\n\t\tprocess.exit(1);\n\t}\n\n\tif (!_.isFunction(this.options.value)) {\n\t\tconsole.error('\\nError: Invalid Configuration\\n\\n' +\n\t\t\t'Watch set with no value method provided for ' + this.list.key + '.' + this.path + ' (' + this.type + ')');\n\t\tprocess.exit(1);\n\t}\n\n\treturn function(next) {\n\t\tif (!applyValue(this)) {\n\t\t\treturn next();\n\t\t}\n\t\tdi(field.options.value).call(this, function(err, val){\n\t\t\tif(err){\n\t\t\t\tconsole.error('\\nError: ' +\n\t\t\t\t'Watch set with value method for ' + field.list.key + '.' + field.path + ' (' + field.type + ') throws error:' + err);\n\t\t\t}else{\n\t\t\t\tthis.set(field.path, val);\n\t\t\t}\n\t\t\tnext();\n\t\t}.bind(this));\n\t};\n\n};\nexports = module.exports = Field;\n\n/** Getter properties for the Field prototype */\nObject.defineProperty(Field.prototype, 'size', { get: function() { return this.getSize(); } });\nObject.defineProperty(Field.prototype, 'initial', { get: function() { return this.options.initial || false; } });\nObject.defineProperty(Field.prototype, 'required', { get: function() { return this.options.required || false; } });\nObject.defineProperty(Field.prototype, 'note', { get: function() { return this.options.note || ''; } });\nObject.defineProperty(Field.prototype, 'col', { get: function() { return this.options.col || false; } });\nObject.defineProperty(Field.prototype, 'noedit', { get: function() { return this.options.noedit || false; } });\nObject.defineProperty(Field.prototype, 'nocol', { get: function() { return this.options.nocol || false; } });\nObject.defineProperty(Field.prototype, 'nosort', { get: function() { return this.options.nosort || false; } });\nObject.defineProperty(Field.prototype, 'nofilter', { get: function() { return this.options.nofilter || false; } });\nObject.defineProperty(Field.prototype, 'collapse', { get: function() { return this.options.collapse || false; } });\nObject.defineProperty(Field.prototype, 'hidden', { get: function() { return this.options.hidden || false; } });\nObject.defineProperty(Field.prototype, 'dependsOn', { get: function() { return this.options.dependsOn || false; } });\n\n/**\n * Default method to register the field on the List's Mongoose Schema.\n * Overridden by some fieldType Classes\n *\n * @api public\n */\nField.prototype.addToSchema = function() {\n\tvar ops = (this._nativeType) ? _.defaults({ type: this._nativeType }, this.options) : this.options;\n\tthis.list.schema.path(this.path, ops);\n\tthis.bindUnderscoreMethods();\n};\n\nField.prototype.bindUnderscoreMethods = function(methods) {\n\tvar field = this;\n\t// automatically bind underscore methods specified by the _underscoreMethods property\n\t// always include the 'update' method\n\t(this._underscoreMethods || []).concat({ fn: 'updateItem', as: 'update' }, (methods || [])).forEach(function(method) {\n\t\tif ('string' === typeof method) {\n\t\t\tmethod = { fn: method, as: method };\n\t\t}\n\t\tif ('function' !== typeof field[method.fn]) {\n\t\t\tthrow new Error('Invalid underscore method (' + method.fn + ') applied to ' + field.list.key + '.' + field.path + ' (' + field.type + ')');\n\t\t}\n\t\tfield.underscoreMethod(method.as, function() {\n\t\t\tvar args = [this].concat(Array.prototype.slice.call(arguments));\n\t\t\treturn field[method.fn].apply(field, args);\n\t\t});\n\t});\n};\n\n/**\n * Adds a method to the underscoreMethods collection on the field's list,\n * with a path prefix to match this field's path and bound to the document\n *\n * @api public\n */\nField.prototype.underscoreMethod = function(path, fn) {\n\tthis.list.underscoreMethod(this.path + '.' + path, function() {\n\t\treturn fn.apply(this, arguments);\n\t});\n};\n\n/**\n * Default method to format the field value for display\n * Overridden by some fieldType Classes\n *\n * @api public\n */\nField.prototype.format = function(item) {\n\treturn item.get(this.path);\n};\n\n/**\n * Default method to detect whether the field has been modified in an item\n * Overridden by some fieldType Classes\n *\n * @api public\n */\nField.prototype.isModified = function(item) {\n\treturn item.isModified(this.path);\n};\n\n/**\n * Validates that a value for this field has been provided in a data object\n * Overridden by some fieldType Classes\n *\n * @api public\n */\nField.prototype.validateInput = function(data, required, item) {\n\tif (!required) return true;\n\tvar value = this.getValueFromData(data);\n\tif (value === undefined && item && item.get(this.path)) return true;\n\tif ('string' === typeof data[this.path]) {\n\t\treturn (data[this.path].trim()) ? true : false;\n\t} else {\n\t\treturn (data[this.path]) ? true : false;\n\t}\n};\n\n/**\n * Updates the value for this field in the item from a data object\n * Overridden by some fieldType Classes\n *\n * @api public\n */\nField.prototype.updateItem = function(item, data) {\n\tvar value = this.getValueFromData(data);\n\t// This is a deliberate type coercion so that numbers from forms play nice\n\tif (value !== undefined && value != item.get(this.path)) { // eslint-disable-line eqeqeq\n\t\titem.set(this.path, value);\n\t}\n};\n\n/**\n * Retrieves the value from an object, whether the path is nested or flattened\n *\n * @api public\n */\nField.prototype.getValueFromData = function(data) {\n\treturn this.path in data ? data[this.path] : this._path.get(data);\n};","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/path.js":"var utils = require('keystone-utils');\n\n/**\n * Path Class\n *\n * @api public\n */\n\nexports = module.exports = function Path(str) {\n\n\tif (!(this instanceof Path)) {\n\t\treturn new Path(str);\n\t}\n\n\tthis.original = str;\n\n\tvar parts = this.parts = str.split('.');\n\tvar last = this.last = this.parts[this.parts.length - 1];\n\tvar exceptLast = [];\n\n\tfor (var i = 0; i < parts.length - 1; i++) {\n\t\texceptLast.push(parts[i]);\n\t}\n\n\tthis.exceptLast = exceptLast.join('.');\n\n\tthis.addTo = function(obj, val) {\n\t\tvar o = obj;\n\t\tfor (var i = 0; i < parts.length - 1; i++) {\n\t\t\tif (!utils.isObject(o[parts[i]])) {\n\t\t\t\to[parts[i]] = {};\n\t\t\t}\n\t\t\to = o[parts[i]];\n\t\t}\n\t\to[last] = val;\n\t\treturn obj;\n\t};\n\n\tthis.get = function(obj) {\n\t\tvar o = obj;\n\t\tfor (var i = 0; i < parts.length; i++) {\n\t\t\tif (typeof o !== 'object') return undefined;\n\t\t\to = o[parts[i]];\n\t\t}\n\t\treturn o;\n\t};\n\n\tthis.prependToLast = function(prepend, titlecase) {\n\t\tvar rtn = '';\n\t\tfor (var i = 0; i < parts.length - 1; i++) {\n\t\t\trtn += parts[i] + '.';\n\t\t}\n\t\treturn rtn + (prepend || '') + (titlecase ? utils.upcase(last) : last);\n\t};\n\n\tthis.append = function(append) {\n\t\treturn str + append;\n\t};\n\n\tthis.flatten = function(titlecase) {\n\t\treturn utils.camelcase(parts.join('_'), titlecase ? true : false);\n\t};\n\n\tthis.flattenplural = function(titlecase) {\n\t\treturn utils.camelcase([].concat(exceptLast).concat(utils.plural(last)).join('_'), titlecase ? true : false);\n\t};\n\n\tthis.flattensingular = function(titlecase) {\n\t\treturn utils.camelcase([].concat(exceptLast).concat(utils.singular(last)).join('_'), titlecase ? true : false);\n\t};\n\n\treturn this;\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/fieldTypes.js":"var fields = {\n\tget AzureFile () { return require('../fields/types/azurefile/AzureFileType'); },\n\tget Boolean () { return require('../fields/types/boolean/BooleanType'); },\n\tget CloudinaryImage () { return require('../fields/types/cloudinaryimage/CloudinaryImageType'); },\n\tget CloudinaryImages () { return require('../fields/types/cloudinaryimages/CloudinaryImagesType'); },\n\tget Code () { return require('../fields/types/code/CodeType'); },\n\tget Color () { return require('../fields/types/color/ColorType'); },\n\tget Date () { return require('../fields/types/date/DateType'); },\n\tget DateArray () { return require('../fields/types/datearray/DateArrayType'); },\n\tget Datetime () { return require('../fields/types/datetime/DatetimeType'); },\n\tget Email () { return require('../fields/types/email/EmailType'); },\n\tget Embedly () { return require('../fields/types/embedly/EmbedlyType'); },\n\tget GeoPoint () { return require('../fields/types/geopoint/GeoPointType'); },\n\tget Html () { return require('../fields/types/html/HtmlType'); },\n\tget Key () { return require('../fields/types/key/KeyType'); },\n\tget LocalFile () { return require('../fields/types/localfile/LocalFileType'); },\n\tget LocalFiles () { return require('../fields/types/localfiles/LocalFilesType'); },\n\tget Location () { return require('../fields/types/location/LocationType'); },\n\tget Markdown () { return require('../fields/types/markdown/MarkdownType'); },\n\tget Money () { return require('../fields/types/money/MoneyType'); },\n\tget Name () { return require('../fields/types/name/NameType'); },\n\tget Number () { return require('../fields/types/number/NumberType'); },\n\tget NumberArray () { return require('../fields/types/numberarray/NumberArrayType'); },\n\tget Password () { return require('../fields/types/password/PasswordType'); },\n\tget Relationship () { return require('../fields/types/relationship/RelationshipType'); },\n\tget S3File () { return require('../fields/types/s3file/S3FileType'); },\n\tget Select () { return require('../fields/types/select/SelectType'); },\n\tget Text () { return require('../fields/types/text/TextType'); },\n\tget TextArray () { return require('../fields/types/textarray/TextArrayType'); },\n\tget Textarea () { return require('../fields/types/textarea/TextareaType'); },\n\tget Url () { return require('../fields/types/url/UrlType'); }\n};\n\nmodule.exports = fields;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list.js":"var _ = require('underscore');\nvar keystone = require('../');\nvar schemaPlugins = require('./schemaPlugins');\nvar utils = require('keystone-utils');\n\n/**\n * List Class\n *\n * @param {String} key\n * @param {Object} options\n */\n\nfunction List(key, options) {\n\tif (!(this instanceof List)) return new List(key, options);\n\n\tvar defaultOptions = {\n\t\tschema: {\n\t\t\tcollection: keystone.prefixModel(key)\n\t\t},\n\t\tnoedit: false,\n\t\tnocreate: false,\n\t\tnodelete: false,\n\t\tautocreate: false,\n\t\tsortable: false,\n\t\thidden: false,\n\t\ttrack: false,\n\t\tinherits: false,\n\t\tsearchFields: '__name__',\n\t\tdefaultSort: '__default__',\n\t\tdefaultColumns: '__name__'\n\t};\n\n\t// initialFields values are initialised on demand by the getter\n\tvar initialFields;\n\n\t// Inherit default options from parent list if it exists\n\tif (options && options.inherits) {\n\t\tif (options.inherits.options && options.inherits.options.inherits) {\n\t\t\tthrow new Error('Inherited Lists may not contain any inheritance');\n\t\t}\n\t\tdefaultOptions = utils.options(defaultOptions, options.inherits.options);\n\t}\n\n\tthis.options = utils.options(defaultOptions, options);\n\n\t// init properties\n\tthis.key = key;\n\tthis.path = this.get('path') || utils.keyToPath(key, true);\n\tthis.schema = new keystone.mongoose.Schema({}, this.options.schema);\n\tthis.schemaFields = [];\n\tthis.uiElements = [];\n\tthis.underscoreMethods = {};\n\tthis.fields = {};\n\tthis.fieldTypes = {};\n\tthis.relationships = {};\n\tthis.mappings = {\n\t\tname: null,\n\t\tcreatedBy: null,\n\t\tcreatedOn: null,\n\t\tmodifiedBy: null,\n\t\tmodifiedOn: null\n\t};\n\n\t// init mappings\n\t_.each(this.options.map, function(val, key) { this.map(key, val); }, this);\n\n\t// define property getters\n\tObject.defineProperty(this, 'label', { get: function() {\n\t\treturn this.get('label') || this.set('label', utils.plural(utils.keyToLabel(key)));\n\t} });\n\tObject.defineProperty(this, 'singular', { get: function() {\n\t\treturn this.get('singular') || this.set('singular', utils.singular(this.label));\n\t} });\n\tObject.defineProperty(this, 'plural', { get: function() {\n\t\treturn this.get('plural') || this.set('plural', utils.plural(this.singular));\n\t} });\n\tObject.defineProperty(this, 'namePath', { get: function() {\n\t\treturn this.mappings.name || '_id';\n\t} });\n\tObject.defineProperty(this, 'nameField', { get: function() {\n\t\treturn this.fields[this.mappings.name];\n\t} });\n\tObject.defineProperty(this, 'nameIsVirtual', { get: function() {\n\t\treturn this.model.schema.virtuals[this.mappings.name] ? true : false;\n\t} });\n\tObject.defineProperty(this, 'nameIsEditable', { get: function() {\n\t\treturn (this.fields[this.mappings.name] && this.fields[this.mappings.name].type === 'text') ? !this.fields[this.mappings.name].noedit : false;\n\t} });\n\tObject.defineProperty(this, 'nameIsInitial', { get: function() {\n\t\treturn (this.fields[this.mappings.name] && this.fields[this.mappings.name].options.initial === undefined);\n\t} });\n\tObject.defineProperty(this, 'initialFields', { get: function() {\n\t\treturn initialFields || (initialFields = _.filter(this.fields, function(i) { return i.initial; }));\n\t} });\n\tif (this.get('sortable')) {\n\t\tschemaPlugins.sortable.apply(this);\n\t}\n\tif (this.get('autokey')) {\n\t\tschemaPlugins.autokey.apply(this);\n\t}\n\tif (this.get('track')) {\n\t\tschemaPlugins.track.apply(this);\n\t}\n\tif (this.get('history')) {\n\t\tschemaPlugins.history.apply(this);\n\t}\n\tif (this.get('inherits')) {\n\t\tvar parentFields = this.get('inherits').schemaFields;\n\t\tthis.add.apply(this, parentFields);\n\t}\n}\n\n// Search Fields\nObject.defineProperty(List.prototype, 'searchFields', {\n\tget: function() {\n\t\tif (!this._searchFields) {\n\t\t\tthis._searchFields = this.expandPaths(this.get('searchFields'));\n\t\t}\n\t\treturn this._searchFields;\n\t}, set: function(value) {\n\t\tthis.set('searchFields', value);\n\t\tdelete this._searchFields;\n\t}\n});\n\n// Default Sort Field\nObject.defineProperty(List.prototype, 'defaultSort', {\n\tget: function() {\n\t\tvar ds = this.get('defaultSort');\n\t\treturn (ds === '__default__') ? (this.get('sortable') ? 'sortOrder' : this.namePath) : ds;\n\t}, set: function(value) {\n\t\tthis.set('defaultSort', value);\n\t}\n});\n\n// Default Column Fields\nObject.defineProperty(List.prototype, 'defaultColumns', {\n\tget: function() {\n\t\tif (!this._defaultColumns) {\n\t\t\tthis._defaultColumns = this.expandColumns(this.get('defaultColumns'));\n\t\t}\n\t\treturn this._defaultColumns;\n\t}, set: function(value) {\n\t\tthis.set('defaultColumns', value);\n\t\tdelete this._defaultColumns;\n\t}\n});\n\n// Add prototype methods\nList.prototype.set = require('./list/set');\nList.prototype.get = List.prototype.set;\nList.prototype.add = require('./list/add');\nList.prototype.map = require('./list/map');\nList.prototype.automap = require('./list/automap');\nList.prototype.field = require('./list/field');\nList.prototype.relationship = require('./list/relationship');\nList.prototype.underscoreMethod = require('./list/underscoreMethod');\nList.prototype.register = require('./list/register');\nList.prototype.getData = require('./list/getData');\nList.prototype.getOptions = require('./list/getOptions');\nList.prototype.getAdminURL = require('./list/getAdminURL');\nList.prototype.getDocumentName = require('./list/getDocumentName');\nList.prototype.addSearchToQuery = require('./list/addSearchToQuery');\nList.prototype.addFiltersToQuery = require('./list/addFiltersToQuery');\nList.prototype.isReserved = require('./list/isReserved');\nList.prototype.expandColumns = require('./list/expandColumns');\nList.prototype.expandPaths = require('./list/expandPaths');\nList.prototype.selectColumns = require('./list/selectColumns');\nList.prototype.processFilters = require('./list/processFilters');\nList.prototype.getSearchFilters = require('./list/getSearchFilters');\nList.prototype.updateAll = require('./list/updateAll');\nList.prototype.getUniqueValue = require('./list/getUniqueValue');\nList.prototype.getPages = require('./list/getPages');\nList.prototype.paginate = require('./list/paginate');\n\n/*!\n * Export class\n */\nexports = module.exports = List;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/schemaPlugins.js":"exports.sortable = require('./schemaPlugins/sortable');\nexports.autokey = require('./schemaPlugins/autokey');\nexports.track = require('./schemaPlugins/track');\nexports.history = require('./schemaPlugins/history');\n\nexports.methods = {\n\tgetRelated: require('./schemaPlugins/methods/getRelated'),\n\tpopulateRelated: require('./schemaPlugins/methods/populateRelated')\n};\n\nexports.options = {\n\ttransform: require('./schemaPlugins/options/transform')\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/schemaPlugins/sortable.js":"module.exports = function sortable() {\n\n\tvar list = this;\n\n\tthis.schema.add({\n\t\tsortOrder: { type: Number, index: true }\n\t});\n\n\tthis.schema.pre('save', function(next) {\n\n\t\tif (typeof this.sortOrder === 'number') {\n\t\t\treturn next();\n\t\t}\n\n\t\tvar item = this;\n\t\tlist.model.findOne().sort('-sortOrder').exec(function(err, max) {// eslint-disable-line no-unused-vars, handle-callback-err\n\t\t\titem.sortOrder = (max && max.sortOrder) ? max.sortOrder + 1 : 1;\n\t\t\tnext();\n\t\t});\n\n\t});\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/schemaPlugins/autokey.js":"var _ = require('underscore');\nvar utils = require('keystone-utils');\n\nmodule.exports = function autokey() {\n\n\tvar autokey = this.autokey = _.clone(this.get('autokey'));\n\tvar def = {};\n\tvar list = this;\n\n\tif (!autokey.from) {\n\t\tvar fromMsg = 'Invalid List Option (autokey) for ' + list.key + ' (from is required)\\n';\n\t\tthrow new Error(fromMsg);\n\t}\n\tif (!autokey.path) {\n\t\tvar pathMsg = 'Invalid List Option (autokey) for ' + list.key + ' (path is required)\\n';\n\t\tthrow new Error(pathMsg);\n\t}\n\n\tif ('string' === typeof autokey.from) {\n\t\tautokey.from = autokey.from.split(' ');\n\t}\n\n\tautokey.from = autokey.from.map(function(i) {\n\t\ti = i.split(':');\n\t\treturn { path: i[0], format: i[1] };\n\t});\n\n\tdef[autokey.path] = {\n\t\ttype: String,\n\t\tindex: true\n\t};\n\n\tif (autokey.unique) {\n\t\tdef[autokey.path].index = { unique: true };\n\t}\n\n\tthis.schema.add(def);\n\n\tvar getUniqueKey = function(doc, src, callback) {\n\n\t\tvar q = list.model.find().where(autokey.path, src);\n\n\t\tif (_.isObject(autokey.unique)) {\n\t\t\t_.each(autokey.unique, function(k, v) {\n\t\t\t\tif (_.isString(v) && v.charAt(0) === ':') {\n\t\t\t\t\tq.where(k, doc.get(v.substr(1)));\n\t\t\t\t} else {\n\t\t\t\t\tq.where(k, v);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tq.exec(function(err, results) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t// deliberate use of implicit type coercion with == because doc.id may need to become a String\n\t\t\t} else if (results.length && (results.length > 1 || results[0].id != doc.id)) { // eslint-disable-line eqeqeq\n\t\t\t\tvar inc = src.match(/^(.+)\\-(\\d+)$/);\n\t\t\t\tif (inc && inc.length === 3) {\n\t\t\t\t\tsrc = inc[1];\n\t\t\t\t\tinc = '-' + ((inc[2] * 1) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tinc = '-1';\n\t\t\t\t}\n\t\t\t\treturn getUniqueKey(doc, src + inc, callback);\n\t\t\t} else {\n\t\t\t\tdoc.set(autokey.path, src);\n\t\t\t\treturn callback();\n\t\t\t}\n\t\t});\n\t};\n\n\tthis.schema.pre('save', function(next) {\n\n\t\tvar modified = false;\n\t\tvar values = [];\n\n\t\tautokey.from.forEach(function(ops) {\n\t\t\tif (list.fields[ops.path]) {\n\t\t\t\tvalues.push(list.fields[ops.path].format(this, ops.format));\n\t\t\t\tif (list.fields[ops.path].isModified(this)) {\n\t\t\t\t\tmodified = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvalues.push(this.get(ops.path));\n\t\t\t\t// virtual paths are always assumed to have changed, except 'id'\n\t\t\t\tif (ops.path !== 'id' && list.schema.pathType(ops.path) === 'virtual' || this.isModified(ops.path)) {\n\t\t\t\t\tmodified = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}, this);\n\n\t\t// if has a value and is unmodified or fixed, don't update it\n\t\tif ((!modified || autokey.fixed) && this.get(autokey.path)) {\n\t\t\treturn next();\n\t\t}\n\t\tvar newKey = utils.slug(values.join(' '), null, { locale: autokey.locale }) || this.id;\n\t\tif (autokey.unique) {\n\t\t\treturn getUniqueKey(this, newKey, next);\n\t\t} else {\n\t\t\tthis.set(autokey.path, newKey);\n\t\t\treturn next();\n\t\t}\n\n\t});\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/schemaPlugins/track.js":"var _ = require('underscore');\nvar keystone = require('../../');\nvar Types = require('../fieldTypes');\n\n/**\n * List track option\n *\n * When enabled, it tracks when a document are created/updated, \n * as well as the user who created/updated it.\n */\n\nmodule.exports = function track() {\n\t\n\tvar list = this;\n\tvar options = list.get('track');\n\tvar userModel = keystone.get('user model');\n\tvar defaultOptions = { \n\t\t\tcreatedAt: false, \n\t\t\tcreatedBy: false,\n\t\t\tupdatedAt: false,\n\t\t\tupdatedBy: false\n\t\t};\n\tvar fields = {};\n\t\n\t// ensure track is a boolean or an object\n\tif (!_.isBoolean(options) && !_.isObject(options) ) {\n\t\tthrow new Error('Invalid List \"track\" option for ' + list.key + '\\n' +\n\t\t\t'\"track\" must be a boolean or an object.\\n\\n' +\n\t\t\t'See http://keystonejs.com/docs/database/#lists-options for more information.');\t\t\t\t\n\t}\n\n\tif (_.isBoolean(options)) {\n\t\t// shorthand: { track: true } sets all tracked fields to true\n\t\tif (options) {\n\t\t\toptions = { \n\t\t\t\tcreatedAt: true, \n\t\t\t\tcreatedBy: true,\n\t\t\t\tupdatedAt: true,\n\t\t\t\tupdatedBy: true\n\t\t\t};\n\t\t} else {\n\t\t\t// otherwise user doesn't want tracking\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// if all track fields are set to false, then user doesn't want to track anything\n\tif (!options.createdAt && !options.createdBy && !options.updatedAt && !options.updatedBy) {\n\t\treturn;\n\t}\n\n\t// merge user options with default options\n\toptions = _.extend({}, defaultOptions, options);\n\n\t// validate option fields\n\t_.each(options, function(value, key) {\n\t\t\n\t\tvar fieldName;\n\t\t\n\t\t// make sure the key isn't already defined as a field\n\t\tif (_.has(list.fields, key)) {\n\t\t\tthrow new Error('Invalid List \"track\" option for ' + list.key + '\\n' +\n\t\t\t\t'\"' + key + '\" is already defined in the Schema.');\n\t\t}\n\n\t\t// make sure it's a valid track option field\n\t\tif (_.has(defaultOptions, key)) {\n\t\t\t\n\t\t\t// make sure the option field value is either a boolean or a string\n\t\t\tif (!_.isBoolean(value) && !_.isString(value)) {\n\t\t\t\tthrow new Error('Invalid List \"track\" option for ' + list.key + '\\n' +\n\t\t\t\t\t'\"' + key + '\" must be a boolean or a string.\\n\\n' +\n\t\t\t\t\t'See http://keystonejs.com/docs/database/#lists-options for more information.');\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\t// determine \n\t\t\t\tfieldName = value === true ? key : value;\n\t\t\t\toptions[key] = fieldName;\n\t\t\t\tlist.map(key, fieldName);\n\n\t\t\t\tswitch(key) {\n\t\t\t\t\tcase 'createdAt':\n\t\t\t\t\tcase 'updatedAt':\n\t\t\t\t\t\tfields[fieldName] = { type: Date, hidden: true, index: true };\n\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'createdBy':\n\t\t\t\t\tcase 'updatedBy':\n\t\t\t\t\t\tfields[fieldName] = { type: Types.Relationship, ref: userModel, hidden: true, index: true };\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Invalid List \"track\" option for ' + list.key + '\\n' +\n\t\t\t\t'valid field options are \"createdAt\", \"createdBy\", \"updatedAt\", an \"updatedBy\".\\n\\n' +\n\t\t\t\t'See http://keystonejs.com/docs/database/#lists-options for more information.');\t\t\t\t\n\t\t}\n\n\t});\n\n\t// add track fields to schema\n\tlist.add(fields);\n\t\n\tlist.tracking = options;\n\n\t// add the pre-save schema plugin\n\tlist.schema.pre('save', function (next) {\n\t\t\n\t\tvar now = new Date();\n\n\t\t// set createdAt/createdBy on new docs\n\t\tif (this.isNew) {\n\t\t\tif (options.createdAt && !this.get(options.createdAt)) {\n\t\t\t\tthis.set(options.createdAt, now);\n\t\t\t}\n\t\t\tif (options.createdBy && this._req_user && !this.get(options.createdBy)) {\n\t\t\t\tthis.set(options.createdBy, this._req_user._id);\n\t\t\t}\n\t\t}\n\n\t\t// set updatedAt/updatedBy when doc is modified\n\t\tif (this.isNew || this.isModified()) {\n\t\t\tif (options.updatedAt) {\n\t\t\t\tthis.set(options.updatedAt, now);\n\t\t\t}\n\t\t\tif (options.updatedBy && this._req_user) {\n\t\t\t\tthis.set(options.updatedBy, this._req_user._id);\n\t\t\t}\n\t\t}\n\n\t\tnext();\n\t\t\n\t});\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/schemaPlugins/history.js":"var keystone = require('../../');\n\nvar historyModelSuffix = '_revisions'; \n\nfunction getHistoryModelName (list) {\n\treturn list.options.schema.collection + historyModelSuffix;\n}\n\nfunction getHistoryModel(list, userModel) {\n\t\n\tvar collection = getHistoryModelName(list);\n\t\n\tvar schema = new keystone.mongoose.Schema({\n\t\ti: { type: keystone.mongoose.Schema.Types.ObjectId, ref: collection },\n\t\tt: { type: Date, index: true, required: true },\n\t\to: { type: String, index: true, required: true },\n\t\tc: { type: [String], index: true },\n\t\td: { type: keystone.mongoose.Schema.Types.Mixed, required: true }\n\t}, {\n\t\tid: true,\n\t\tversionKey: false\n\t});\n\t\n\tif (userModel) {\n\t\tschema.add({\n\t\t\tu: { type: keystone.mongoose.Schema.Types.ObjectId, ref: userModel }\n\t\t});\n\t}\n\t\n\treturn keystone.mongoose.model(collection, schema, collection);\n\t\n}\n\n/**\n * List history option\n *\n * When enabled, it tracks changes to each document on save or remove.\n */\n\nmodule.exports = function history() {\n\n\tvar list = this;\n\t\n\t//If model already exists for a '_revisions' in an inherited model, log a warning but skip creating the new model (inherited _revisions model will be used).\n\tvar collectionName = getHistoryModelName(list);\n\tif (list.get('inherits') &&\n\t\tcollectionName.indexOf(historyModelSuffix, collectionName.length - historyModelSuffix.length) !== -1 &&\n\t\tkeystone.mongoose.models[collectionName]) {\n\t\tconsole.log('List/model already exists for ' + collectionName + '.\\nWon\\'t re-create, keystone continuing.');\n\t\treturn;\n\t}\n\n\tvar userModel = keystone.get('user model');\n\t\n\tvar HistoryModel = list.HistoryModel = getHistoryModel(this, userModel);\n\t\n\tlist.schema.add({\n\t\t__rev: Number\n\t});\n\t\n\tlist.schema.pre('save', function(next) {\n\t\tthis.__rev = (typeof this.__rev === 'number') ? this.__rev + 1 : 1;\n\t\t\n\t\tvar data = this.toObject();\n\t\tdelete data._id;\n\t\tdelete data.__v;\n\t\tdelete data.__rev;\n\t\t\n\t\tvar doc = {\n\t\t\ti: this.id,\n\t\t\tt: Date.now(),\n\t\t\to: this.isNew ? 'c' : 'u',\n\t\t\tc: [],\n\t\t\td: data\n\t\t};\n\t\t\n\t\tfor (var path in list.fields) {\n\t\t\tif (this.isModified(path)) {\n\t\t\t\tdoc.c.push(path);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (list.autokey) {\n\t\t\tif (this.isModified(list.autokey.path)) {\n\t\t\t\tdoc.c.push(list.autokey.path);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (userModel && this._req_user) {\n\t\t\tdoc.u = this._req_user;\n\t\t}\n\t\t\n\t\tnew HistoryModel(doc).save(next);\n\t});\n\t\n\tlist.schema.pre('remove', function(next) {\n\t\tvar data = this.toObject();\n\t\tdata.__v = undefined;\n\t\t\n\t\tvar doc = {\n\t\t\tt: Date.now(),\n\t\t\to: 'd',\n\t\t\td: data\n\t\t};\n\t\t\n\t\tif (userModel && this._req_user) {\n\t\t\tdoc.u = this._req_user;\n\t\t}\n\t\t\n\t\tnew HistoryModel(doc).save(next);\n\t});\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/schemaPlugins/methods/getRelated.js":"var keystone = require('../../../');\nvar _ = require('underscore');\nvar async = require('async');\n\nmodule.exports = function getRelated(paths, callback, nocollapse) {\n\n\tvar item = this;\n\tvar list = this.list;\n\tvar queue = {};\n\n\tif ('function' !== typeof callback) {\n\t\tthrow new Error('List.getRelated(paths, callback, nocollapse) requires a callback function.');\n\t}\n\n\tif ('string' === typeof paths) {\n\t\tvar pathsArr = paths.split(' ');\n\t\tvar lastPath = '';\n\t\tpaths = [];\n\t\tfor (var i = 0; i < pathsArr.length; i++) {\n\t\t\tlastPath += (lastPath.length ? ' ' : '') + pathsArr[i];\n\t\t\tif (lastPath.indexOf('[') < 0 || lastPath.charAt(lastPath.length - 1) === ']') {\n\t\t\t\tpaths.push(lastPath);\n\t\t\t\tlastPath = '';\n\t\t\t}\n\t\t}\n\t}\n\n\t_.each(paths, function(options) {\n\n\t\tvar populateString = '';\n\n\t\tif ('string' === typeof options) {\n\t\t\tif (options.indexOf('[') > 0) {\n\t\t\t\tpopulateString = options.substring(options.indexOf('[') + 1, options.indexOf(']'));\n\t\t\t\toptions = options.substr(0, options.indexOf('['));\n\t\t\t}\n\t\t\toptions = { path: options };\n\t\t}\n\t\toptions.populate = options.populate || [];\n\t\toptions.related = options.related || [];\n\n\t\tvar relationship = list.relationships[options.path];\n\t\tif (!relationship) throw new Error('List.getRelated: list ' + list.key + ' does not have a relationship ' + options.path + '.');\n\n\t\tvar refList = keystone.list(relationship.ref);\n\t\tif (!refList) throw new Error('List.getRelated: list ' + relationship.ref + ' does not exist.');\n\n\t\tvar relField = refList.fields[relationship.refPath];\n\t\tif (!relField || relField.type !== 'relationship') throw new Error('List.getRelated: relationship ' + relationship.ref + ' on list ' + list.key + ' refers to a path (' + relationship.refPath + ') which is not a relationship field.');\n\n\t\tif (populateString.length) {\n\n\t\t\t_.each(populateString.split(' '), function(key) {\n\t\t\t\tif (refList.relationships[key]) {\n\t\t\t\t\toptions.related.push(key);\n\t\t\t\t} else {\n\t\t\t\t\toptions.populate.push(key);\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\n\t\tqueue[relationship.path] = function(done) {\n\n\t\t\tvar query = refList.model.find().where(relField.path);\n\n\t\t\tif (options.populate) {\n\t\t\t\tquery.populate(options.populate);\n\t\t\t}\n\n\t\t\tif (relField.many) {\n\t\t\t\tquery.in([item.id]);\n\t\t\t} else {\n\t\t\t\tquery.equals(item.id);\n\t\t\t}\n\n\t\t\tquery.sort(options.sort || relationship.sort || refList.defaultSort);\n\n\t\t\tif (options.related.length) {\n\t\t\t\tquery.exec(function(err, results) {\n\t\t\t\t\tif (err || !results.length) {\n\t\t\t\t\t\treturn done(err, results);\n\t\t\t\t\t}\n\t\t\t\t\tasync.parallel(results.map(function(item) {\n\t\t\t\t\t\t\treturn function(done) {\n\t\t\t\t\t\t\t\titem.populateRelated(options.related, done);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tfunction(err) {\n\t\t\t\t\t\t\tdone(err, results);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tquery.exec(done);\n\t\t\t}\n\n\t\t};\n\n\t\tif (!item._populatedRelationships) item._populatedRelationships = {};\n\t\titem._populatedRelationships[relationship.path] = true;\n\n\t});\n\n\tasync.parallel(queue, function(err, results) {\n\t\tif (!nocollapse && results && paths.length === 1) {\n\t\t\tresults = results[paths[0]];\n\t\t}\n\t\tcallback(err, results);\n\t});\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/schemaPlugins/methods/populateRelated.js":"var _ = require('underscore');\n\nmodule.exports = function populateRelated(rel, callback) {\n\n\tvar item = this;\n\n\tif ('function' !== typeof callback) {\n\t\tthrow new Error('List.populateRelated(rel, callback) requires a callback function.');\n\t}\n\n\tthis.getRelated(rel, function(err, results) {\n\t\t_.each(results, function(data, key) {\n\t\t\titem[key] = data;\n\t\t});\n\t\tcallback(err, results);\n\t}, true);\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/schemaPlugins/options/transform.js":"var _ = require('underscore');\n\nmodule.exports = function transform(doc, ret) {\n\tif (doc._populatedRelationships) {\n\t\t_.each(doc._populatedRelationships, function(on, key) {\n\t\t\tif (!on) return;\n\t\t\tret[key] = doc[key];\n\t\t});\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/set.js":"/**\n * Gets and Sets list options. Aliased as .get()\n *\n * Example:\n *     list.set('test') // returns the 'test' value\n *     list.set('test', value) // sets the 'test' option to `value`\n */\nfunction set(key, value) {\n\tif (arguments.length === 1) {\n\t\treturn this.options[key];\n\t}\n\tthis.options[key] = value;\n\treturn value;\n}\n\nmodule.exports = set;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/add.js":"var _ = require('underscore');\nvar utils = require('keystone-utils');\n\n/**\n * Adds one or more fields to the List\n * Based on Mongoose's Schema.add\n */\nfunction add () {\n\tvar add = function(obj, prefix) {\n\t\tprefix = prefix || '';\n\t\tvar keys = Object.keys(obj);\n\t\tfor (var i = 0; i < keys.length; ++i) {\n\t\t\tvar key = keys[i];\n\t\t\tif (!obj[key]) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Invalid value for schema path `' + prefix + key + '` in `' + this.key + '`.\\n' +\n\t\t\t\t\t'Did you misspell the field type?\\n'\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (utils.isObject(obj[key]) && (!obj[key].constructor || 'Object' === obj[key].constructor.name) && (!obj[key].type || obj[key].type.type)) {\n\t\t\t\tif (Object.keys(obj[key]).length) {\n\t\t\t\t\t// nested object, e.g. { last: { name: String }}\n\t\t\t\t\t// matches logic in mongoose/Schema:add\n\t\t\t\t\tthis.schema.nested[this.path] = true;\n\t\t\t\t\tadd(obj[key], prefix + key + '.');\n\t\t\t\t} else {\n\t\t\t\t\taddField(prefix + key, obj[key]); // mixed type field\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddField(prefix + key, obj[key]);\n\t\t\t}\n\t\t}\n\t}.bind(this);\n\n\tvar addField = function(path, options) {\n\t\tif (this.isReserved(path)) {\n\t\t\tthrow new Error('Path ' + path + ' on list ' + this.key + ' is a reserved path');\n\t\t}\n\t\tthis.uiElements.push({\n\t\t\ttype: 'field',\n\t\t\tfield: this.field(path, options)\n\t\t});\n\t}.bind(this);\n\n\t_.each(arguments, function(def) {\n\t\tthis.schemaFields.push(def);\n\t\tif ('string' === typeof def) {\n\t\t\tif (def === '>>>') {\n\t\t\t\tthis.uiElements.push({\n\t\t\t\t\ttype: 'indent'\n\t\t\t\t});\n\t\t\t} else if (def === '<<<') {\n\t\t\t\tthis.uiElements.push({\n\t\t\t\t\ttype: 'outdent'\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.uiElements.push({\n\t\t\t\t\ttype: 'heading',\n\t\t\t\t\theading: def,\n\t\t\t\t\toptions: {}\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (def.heading && 'string' === typeof def.heading) {\n\t\t\t\tthis.uiElements.push({\n\t\t\t\t\ttype: 'heading',\n\t\t\t\t\theading: def.heading,\n\t\t\t\t\toptions: def\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tadd(def);\n\t\t\t}\n\t\t}\n\t}, this);\n\n\treturn this;\n}\n\nmodule.exports = add;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/map.js":"/**\n * Maps a built-in field (e.g. name) to a specific path\n */\nfunction map (field, path) {\n\tif (path) {\n\t\tthis.mappings[field] = path;\n\t}\n\treturn this.mappings[field];\n}\n\nmodule.exports = map;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/automap.js":"/**\n * Checks to see if a field path matches a currently unmapped path, and\n * if so, adds a mapping for it.\n */\nfunction automap (field) {\n\tif ((field.path in this.mappings) && !this.mappings[field.path]) {\n\t\tthis.map(field.path, field.path);\n\t}\n\treturn this;\n}\n\nmodule.exports = automap;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/field.js":"var Field = require('../../fields/types/Type');\n\n/**\n * Creates a new field at the specified path, with the provided options.\n * If no options are provides, returns the field at the specified path.\n */\nfunction field (path, options) {\n\tif (arguments.length === 1) {\n\t\treturn this.fields[path];\n\t}\n\tif ('function' === typeof options) {\n\t\toptions = { type: options };\n\t}\n\tif (this.get('noedit')) {\n\t\toptions.noedit = true;\n\t}\n\tif (!options.note && this.get('notes')) {\n\t\toptions.note = this.get('notes')[path];\n\t}\n\tif ('function' !== typeof options.type) {\n\t\tthrow new Error('Fields must be specified with a type function');\n\t}\n\tif (options.type.prototype.__proto__ !== Field.prototype) {\n\t\t// Convert native field types to their default Keystone counterpart\n\t\tif (options.type === String) {\n\t\t\toptions.type = Field.Types.Text;\n\t\t} else if (options.type === Number) {\n\t\t\toptions.type = Field.Types.Number;\n\t\t} else if (options.type === Boolean) {\n\t\t\toptions.type = Field.Types.Boolean;\n\t\t} else if (options.type === Date) {\n\t\t\toptions.type = Field.Types.Datetime;\n\t\t} else {\n\t\t\tthrow new Error('Unrecognised field constructor: ' + options.type);\n\t\t}\n\t}\n\n\t// Note the presence of this field type for client-side script optimisation\n\tthis.fieldTypes[options.type.name] = true;\n\n\t// Wysiwyg HTML fields are handled as a special case so we can include TinyMCE as required\n\tif (options.type.name === 'html' && options.wysiwyg) {\n\t\tthis.fieldTypes.wysiwyg = true;\n\t}\n\n\tvar field = new options.type(this, path, options);\n\tthis.fields[path] = field;\n\treturn field;\n}\n\nmodule.exports = field;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/relationship.js":"var keystone = require('../../');\nvar utils = require('keystone-utils');\n\n/**\n * Registers relationships to this list defined on others\n */\nfunction relationship (def) {\n\tif (arguments.length > 1) {\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tthis.relationship(arguments[i]);\n\t\t}\n\t\treturn this;\n\t}\n\tif ('string' === typeof def) {\n\t\tdef = { ref: def };\n\t}\n\tif (!def.ref) {\n\t\tthrow new Error('List Relationships must be specified with an object containing ref (' + this.key + ')');\n\t}\n\tif (!def.refPath) {\n\t\tdef.refPath = utils.downcase(this.key);\n\t}\n\tif (!def.path) {\n\t\tdef.path = utils.keyToProperty(def.ref, true);\n\t}\n\tObject.defineProperty(def, 'refList', {\n\t\tget: function() {\n\t\t\treturn keystone.list(def.ref);\n\t\t}\n\t});\n\tObject.defineProperty(def, 'isValid', {\n\t\tget: function() {\n\t\t\treturn keystone.list(def.ref) ? true : false;\n\t\t}\n\t});\n\tthis.relationships[def.path] = def;\n\treturn this;\n}\n\nmodule.exports = relationship;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/underscoreMethod.js":"/**\n * Adds a method to the underscoreMethods collection on the list, which is then\n * added to the schema before the list is registered with mongoose.\n */\nfunction underscoreMethod (path, fn) {\n\tvar target = this.underscoreMethods;\n\tpath = path.split('.');\n\tvar last = path.pop();\n\tpath.forEach(function(part) {\n\t\tif (!target[part]) target[part] = {};\n\t\ttarget = target[part];\n\t});\n\ttarget[last] = fn;\n\treturn this;\n}\n\nmodule.exports = underscoreMethod;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/register.js":"var keystone = require('../../');\nvar schemaPlugins = require('../schemaPlugins');\nvar UpdateHandler = require('../updateHandler');\nvar utils = require('keystone-utils');\n\n/**\n * Registers the Schema with Mongoose, and the List with Keystone\n *\n * Also adds default fields and virtuals to the schema for the list\n */\nfunction register() {\n\tvar list = this;\n\tthis.schema.virtual('list').get(function () {\n\t\treturn list;\n\t});\n\tif (Object.keys(this.relationships).length) {\n\t\tthis.schema.methods.getRelated = schemaPlugins.methods.getRelated;\n\t\tthis.schema.methods.populateRelated = schemaPlugins.methods.populateRelated;\n\t\tif (!this.schema.options.toObject) this.schema.options.toObject = {};\n\t\tthis.schema.options.toObject.transform = schemaPlugins.options.transform;\n\t}\n\tthis.schema.virtual('_').get(function() {\n\t\tif (!this.__methods) {\n\t\t\tthis.__methods = utils.bindMethods(list.underscoreMethods, this);\n\t\t}\n\t\treturn this.__methods;\n\t});\n\tthis.schema.method('getUpdateHandler', function(req, res, ops) {\n\t\treturn new UpdateHandler(list, this, req, res, ops);\n\t});\n\tif (this.get('inherits')) {\n\t\tthis.model = this.get('inherits').model.discriminator(this.key, this.schema);\n\t} else {\n\t\tthis.model = keystone.mongoose.model(this.key, this.schema);\n\t}\n\tkeystone.list(this);\n\treturn this;\n}\n\nmodule.exports = register;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/updateHandler.js":"var _ = require('underscore');\nvar keystone = require('../');\n\n/**\n * UpdateHandler Class\n *\n * @param {Object} item to update\n * @api public\n */\n\nfunction UpdateHandler(list, item, req, res, options) {\n\n\tif (!(this instanceof UpdateHandler)) {\n\t\treturn new UpdateHandler(list, item);\n\t}\n\n\tthis.list = list;\n\tthis.item = item;\n\tthis.req = req;\n\tthis.res = res;\n\tthis.user = req.user;\n\tthis.options = options || {};\n\n\tif (!this.options.errorMessage) {\n\t\tthis.options.errorMessage = 'There was a problem saving your changes:';\n\t}\n\n\tif (this.options.user) {\n\t\tthis.user = this.options.user;\n\t}\n\n\tthis.validationMethods = {};\n\tthis.validationErrors = {};\n\n}\n\n\n/**\n * Adds a custom validation method for a given path\n *\n * @param {string} path to call method for\n * @param {function} method to call\n * @api public\n */\n\nUpdateHandler.prototype.validate = function(path, fn) {\n\tthis.validationMethods[path] = fn;\n\treturn this;\n};\n\n\n/**\n * Adds a validationError to the updateHandler; can be used before\n * `.process()` is called to handle errors generated by custom pre-\n * processing.\n *\n * @param {string} path that failed validation\n * @param {string} message to display\n * @param {string} error type (defaults to 'required')\n * @api public\n */\nUpdateHandler.ValidationErrorName = 'ValidatorError';\nUpdateHandler.prototype.addValidationError = function(path, msg, type) {\n\tthis.validationErrors[path] = {\n\t\tname: UpdateHandler.ValidationErrorName,\n\t\tpath: path,\n\t\tmessage: msg,\n\t\ttype: type || 'required'\n\t};\n\treturn this;\n};\n\n\n/**\n * Processes data from req.body, req.query, or any data source.\n *\n * Options:\n * - fields (comma-delimited list or array of field paths)\n * - flashErrors (boolean, default false; whether to push validation errors to req.flash)\n * - ignoreNoedit (boolean, default false; whether to ignore noedit settings on fields)\n * - validationErrors (object; validation errors from previous form handling that should be included)\n *\n * @param {Object} data\n * @param {Object} options (can be comma-delimited list of fields) (optional)\n * @param {Function} callback (optional)\n * @api public\n */\n\nUpdateHandler.prototype.process = function(data, options, callback) {\n\t\n\tvar usingDefaultFields = false;\n\t\n\tif ('function' === typeof options) {\n\t\tcallback = options;\n\t\toptions = null;\n\t}\n\n\tif ('function' !== typeof callback) {\n\t\tcallback = function() {};\n\t}\n\t\n\t// Initialise options\n\t\n\tif (!options) {\n\t\toptions = {};\n\t} else if ('string' === typeof options) {\n\t\toptions = { fields: options };\n\t}\n\t\n\tif (!options.fields) {\n\t\toptions.fields = _.keys(this.list.fields);\n\t\tusingDefaultFields = true;\n\t} else if ('string' === typeof options.fields) {\n\t\toptions.fields = options.fields.split(',').map(function(i) { return i.trim(); });\n\t}\n\t\n\toptions.required = options.required || {};\n\toptions.errorMessage = options.errorMessage || this.options.errorMessage;\n\toptions.invalidMessages = options.invalidMessages || {};\n\toptions.requiredMessages = options.requiredMessages || {};\n\t\n\t// Parse a string of required fields into field paths\n\tif ('string' === typeof options.required) {\n\t\tvar requiredFields = options.required.split(',').map(function(i) { return i.trim(); });\n\t\toptions.required = {};\n\t\trequiredFields.forEach(function(path) {\n\t\t\toptions.required[path] = true;\n\t\t});\n\t}\n\t\n\t// Make sure fields with the required option set are included in the required paths\n\toptions.fields.forEach(function(path) {\n\t\tvar field = (path instanceof keystone.Field) ? path : this.list.field(path);\n\t\tif (field && field.required) {\n\t\t\toptions.required[field.path] = true;\n\t\t}\n\t}, this);\n\t\n\t// TODO: The whole progress queue management code could be a lot neater...\n\tvar actionQueue = [],\n\t\taddValidationError = this.addValidationError.bind(this),\n\t\tvalidationErrors = this.validationErrors;\n\n\tvar progress = function(err) {\n\t\tif (err) {\n\t\t\tif (options.logErrors) {\n\t\t\t\tconsole.log('Error saving changes to ' + this.item.list.singular + ' ' + this.item.id + ':');\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t\tcallback(err, this.item, this);\n\t\t} else if (_.size(validationErrors)) {\n\t\t\tif (options.flashErrors) {\n\t\t\t\tthis.req.flash('error', {\n\t\t\t\t\ttype: UpdateHandler.ValidationErrorName,\n\t\t\t\t\ttitle: options.errorMessage,\n\t\t\t\t\tlist: _.pluck(validationErrors, 'message')\n\t\t\t\t});\n\t\t\t}\n\t\t\tcallback({\n\t\t\t\tmessage: 'Validation failed',\n\t\t\t\tname: UpdateHandler.ValidationErrorName,\n\t\t\t\terrors: validationErrors\n\t\t\t}, this.item, this);\n\t\t} else if (actionQueue.length) {\n\t\t\t// TODO: parallel queue handling for cloudinary uploads?\n\t\t\tactionQueue.pop()();\n\t\t} else {\n\t\t\tsaveItem();\n\t\t}\n\t}.bind(this);\n\t\n\tvar saveItem = function() {\n\t\t\n\t\t// Make current user available to pre/post save events\n\t\tthis.item._req_user = this.user;\n\t\t\n\t\tthis.item.save(function(err) {\n\t\t\tif (err) {\n\t\t\t\tif (err.name === UpdateHandler.ValidationErrorName) {\n\t\t\t\t\t// don't log simple validation errors\n\t\t\t\t\tif (options.flashErrors) {\n\t\t\t\t\t\tthis.req.flash('error', {\n\t\t\t\t\t\t\ttype: UpdateHandler.ValidationErrorName,\n\t\t\t\t\t\t\ttitle: options.errorMessage,\n\t\t\t\t\t\t\tlist: _.pluck(err.errors, 'message')\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (options.logErrors) {\n\t\t\t\t\t\tconsole.log('Error saving changes to ' + this.item.list.singular + ' ' + this.item.id + ':');\n\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t}\n\t\t\t\t\tif (options.flashErrors) {\n\t\t\t\t\t\tthis.req.flash('error', 'There was an error saving your changes: ' + err.message + ' (' + err.name + (err.type ? ': ' + err.type : '') + ')');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddValidationError(err.path, err.message, err.type);\n\n\t\t\t\terr = {\n\t\t\t\t\tmessage: 'Validation failed',\n\t\t\t\t\tname: UpdateHandler.ValidationErrorName,\n\t\t\t\t\terrors: validationErrors\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn callback(err, this.item, this);\n\t\t}.bind(this));\n\t}.bind(this);\n\t\n\toptions.fields.forEach(function(path) {\n\t\t\n\t\t// console.log('Processing field ' + path);\n\t\tvar message;\n\t\t\n\t\tvar field = (path instanceof keystone.Field) ? path : this.list.field(path),\n\t\t\tinvalidated = false;\n\t\t\n\t\tif (!field) {\n\t\t\tthrow new Error('UpdateHandler.process called with invalid field path: ' + path);\n\t\t}\n\t\t\n\t\t// skip uneditable fields\n\t\tif (usingDefaultFields && field.noedit && !options.ignoreNoedit) {\n\t\t\t// console.log('Skipping field ' + path + ' (noedit: true)');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Some field types have custom behaviours for queueing or validation\n\t\tswitch (field.type) {\n\t\t\t\n\t\t\tcase 'localfile':\n\t\t\tcase 'localfiles':\n\t\t\tcase 'cloudinaryimage':\n\t\t\tcase 'cloudinaryimages':\n\t\t\tcase 'azurefile':\n\t\t\tcase 's3file':\n\t\t\t\tactionQueue.push(field.getRequestHandler(this.item, this.req, options.paths, function(err) {\n\t\t\t\t\tif (err && options.flashErrors) {\n\t\t\t\t\t\tthis.req.flash('error', field.label + ' upload failed - ' + err.message);\n\t\t\t\t\t}\n\t\t\t\t\tprogress(err);\n\t\t\t\t}.bind(this)));\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 'location':\n\t\t\t\tactionQueue.push(field.getRequestHandler(this.item, this.req, options.paths, function(err) {\n\t\t\t\t\tif (err && options.flashErrors) {\n\t\t\t\t\t\tthis.req.flash('error', field.label + ' improve failed - ' + (err.status_text || err.status));\n\t\t\t\t\t}\n\t\t\t\t\tprogress(err);\n\t\t\t\t}.bind(this)));\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 'password':\n\t\t\t\t// passwords should only be set if a value is provided.\n\t\t\t\t// if no value is provided, as long as the field isn't required or empty, bail.\n\t\t\t\tif (!data[field.path] && (!options.required[field.path] || this.item.get(field.path))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// validate the password fields match, with a custom error message.\n\t\t\t\tif (data[field.path] !== data[field.paths.confirm]) {\n\t\t\t\t\tmessage = options.invalidMessages[field.path + '_match'] || 'Passwords must match';\n\t\t\t\t\taddValidationError(field.path, message);\n\t\t\t\t\tinvalidated = true;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t}\n\t\t\n\t\t// validate field input, unless it's already been invalidated by field-specific behaviour\n\t\tif (!invalidated && !field.validateInput(data)) {\n\t\t\t// console.log('Field ' + field.path + ' is invalid');\n\t\t\tmessage = options.invalidMessages[field.path] || field.options.invalidMessage || 'Please enter a valid ' + field.typeDescription + ' in the ' + field.label + ' field';\n\t\t\taddValidationError(field.path, message);\n\t\t\tinvalidated = true;\n\t\t}\n\t\t\n\t\t// validate required fields, unless they've already been invalidated by field-specific behaviour\n\t\tif (!invalidated && options.required[field.path] && !field.validateInput(data, true, this.item) && !validationErrors[field.path]) {\n\t\t\t// console.log('Field ' + field.path + ' is required, but not provided.');\n\t\t\tmessage = options.requiredMessages[field.path] || field.options.requiredMessage || field.label + ' is required';\n\t\t\taddValidationError(field.path, message);\n\t\t\tinvalidated = true;\n\t\t}\n\t\t\n\t\t// check for a custom validation rule at the path, and run it (unless the field is already invalid)\n\t\tif (!invalidated && this.validationMethods[field.path]) {\n\t\t\tmessage = this.validationMethods[field.path](data);\n\t\t\tif (message) {\n\t\t\t\taddValidationError(field.path, message);\n\t\t\t}\n\t\t\tinvalidated = true;\n\t\t}\n\t\t\n\t\tfield.updateItem(this.item, data);\n\t\t\n\t}, this);\n\n\tprogress();\n\t\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = UpdateHandler;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/getData.js":"var listToArray = require('list-to-array');\n\n/**\n * Gets the data from an Item ready to be serialised for client-side use, as\n * used by the React components\n */\n\nfunction getData (item, fields) {\n\tvar data = {\n\t\tid: item.id,\n\t\tname: this.getDocumentName(item)\n\t};\n\tif (this.autokey) {\n\t\tdata[this.autokey.path] = item.get(this.autokey.path);\n\t}\n\tif (fields === undefined) {\n\t\tfields = Object.keys(this.fields);\n\t}\n\tif (fields) {\n\t\tif (typeof fields === 'string') {\n\t\t\tfields = listToArray(fields);\n\t\t}\n\t\tif (!Array.isArray(fields)) {\n\t\t\tthrow new Error('List.getData: fields must be undefined, a string, or an array.');\n\t\t}\n\t\tdata.fields = {};\n\t\tfields.forEach(function (path) {\n\t\t\tvar field = this.fields[path];\n\t\t\tif (field) {\n\t\t\t\tdata.fields[path] = field.getData(item);\n\t\t\t} else {\n\t\t\t\tdata.fields[path] = item.get(path);\n\t\t\t}\n\t\t}, this);\n\t}\n\treturn data;\n}\n\nmodule.exports = getData;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/getOptions.js":"var _ = require('underscore');\n\n/**\n * Gets the options for the List, as used by the React components\n */\nfunction getOptions () {\n\tvar ops = {\n\t\tautocreate: this.options.autocreate,\n\t\tautokey: this.autokey,\n\t\tdefaultColumns: this.options.defaultColumns,\n\t\tdefaultSort: this.options.defaultSort,\n\t\tfields: {},\n\t\thidden: this.options.hidden,\n\t\tinitialFields: _.pluck(this.initialFields, 'path'),\n\t\tkey: this.key,\n\t\tlabel: this.label,\n\t\tnameField: this.nameField ? this.nameField.getOptions() : null,\n\t\tnameIsEditable: this.nameIsEditable,\n\t\tnameIsInitial: this.nameIsInitial,\n\t\tnameIsVirtual: this.nameIsVirtual,\n\t\tnamePath: this.namePath,\n\t\tnocreate: this.options.nocreate,\n\t\tnodelete: this.options.nodelete,\n\t\tnoedit: this.options.noedit,\n\t\tpath: this.path,\n\t\tplural: this.plural,\n\t\tsearchFields: this.options.searchFields,\n\t\tsingular: this.singular,\n\t\tsortable: this.options.sortable,\n\t\tsortContext: this.options.sortContext,\n\t\ttrack: this.options.track,\n\t\ttracking: this.tracking,\n\t\tuiElements: []\n\t};\n\t_.each(this.uiElements, function (el) {\n\t\tswitch (el.type) {\n\t\t\t// TODO: handle indentation\n\t\t\tcase 'field':\n\t\t\t\t// add the field options by path\n\t\t\t\tops.fields[el.field.path] = el.field.getOptions();\n\t\t\t\t// don't output the name field as a ui element if it's editable as it'll\n\t\t\t\t// appear as an input in the header\n\t\t\t\tif (el.field === this.nameField && this.nameIsEditable) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// don't output hidden fields\n\t\t\t\tif (el.field.hidden && el.field.type !== 'boolean') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// add the field to the elements array\n\t\t\t\tops.uiElements.push({\n\t\t\t\t\ttype: 'field',\n\t\t\t\t\tfield: el.field.path\n\t\t\t\t});\n\t\t\tbreak;\n\t\t\tcase 'heading':\n\t\t\t\tops.uiElements.push({\n\t\t\t\t\ttype: 'heading',\n\t\t\t\t\tcontent: el.heading,\n\t\t\t\t\toptions: el.options\n\t\t\t\t});\n\t\t\tbreak;\n\t\t}\n\t}, this);\n\treturn ops;\n}\n\nmodule.exports = getOptions;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/getAdminURL.js":"/**\n * Gets the Admin URL to view the list (or an item if provided)\n *\n * Example:\n *     var listURL = list.getAdminURL()\n *     var itemURL = list.getAdminURL(item)\n *\n * @param {Object} item\n */\nfunction getAdminURL(item) {\n\treturn '/keystone/' + this.path + (item ? '/' + item.id : '');\n}\n\nmodule.exports = getAdminURL;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/getDocumentName.js":"var utils = require('keystone-utils');\n\n/**\n * Gets the name of the provided document from the correct path\n *\n * Example:\n *     var name = list.getDocumentName(item)\n *\n * @param {Object} item\n * @param {Boolean} escape - causes HTML entities to be encoded\n */\nfunction getDocumentName(doc, escape) {\n\tvar name = String(this.nameField ? this.nameField.format(doc) : doc.get(this.namePath));\n\treturn (escape) ? utils.encodeHTMLEntities(name) : name;\n}\n\nmodule.exports = getDocumentName;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/addSearchToQuery.js":"var assign = require('object-assign');\nvar utils = require('keystone-utils');\n\nfunction trim(i) { return i.trim(); }\nfunction truthy(i) { return i; }\n\nfunction getNameFilter(field, searchString) {\n\tvar searchWords = searchString.split(' ').map(trim).filter(truthy).map(utils.escapeRegExp);\n\tvar nameSearchRegExp = new RegExp(searchWords.join('|'), 'i');\n\tvar first = {};\n\tfirst[field.paths.first] = nameSearchRegExp;\n\tvar last = {};\n\tlast[field.paths.last] = nameSearchRegExp;\n\treturn {\n\t\t$or: [first, last]\n\t};\n}\n\nfunction getStringFilter(path, searchRegExp) {\n\tvar filter = {};\n\tfilter[path] = searchRegExp;\n\treturn filter;\n}\n\nfunction addSearchToQuery (searchString, query) {\n\tsearchString = String(searchString || '').trim();\n\tquery = query || {};\n\tif (!searchString) return query;\n\n\tvar searchRegExp = new RegExp(utils.escapeRegExp(searchString), 'i');\n\tvar searchFilters = this.searchFields.map(function (i) {\n\t\tif (i.field && i.field.type === 'name') {\n\t\t\treturn getNameFilter(i.field, searchString);\n\t\t} else {\n\t\t\treturn getStringFilter(i.path, searchRegExp);\n\t\t}\n\t}, this);\n\n\tif (this.autokey) {\n\t\tvar autokeyFilter = {};\n\t\tautokeyFilter[this.autokey.path] = searchRegExp;\n\t\tsearchFilters.push(autokeyFilter);\n\t}\n\n\tif (utils.isValidObjectId(searchString)) {\n\t\tvar idFilter = {};\n\t\tidFilter._id = searchString;\n\t\tsearchFilters.push(idFilter);\n\t}\n\n\tif (searchFilters.length > 1) {\n\t\tquery.$or = searchFilters;\n\t} else if (searchFilters.length) {\n\t\tassign(query, searchFilters[0]);\n\t}\n\n\treturn query;\n}\n\nmodule.exports = addSearchToQuery;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/addFiltersToQuery.js":"function addFiltersToQuery (filters, query) {\n\tvar fields = Object.keys(this.fields);\n\tquery = query || {};\n\tfields.forEach(function (path) {\n\t\tvar field = this.fields[path];\n\t\tif (!field.addFilterToQuery || !filters[field.path]) return;\n\t\tfield.addFilterToQuery(filters[field.path], query);\n\t}, this);\n\treturn query;\n}\n\nmodule.exports = addFiltersToQuery;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/isReserved.js":"/**\n * Check whether or not a `path` is a reserved path. This restricts the use\n * of `Object.prototype` method keys as well as internal mongo paths.\n */\n\nvar reservedPaths = [\n\t'id',\n\t'_id',\n\t'_',\n\t'prototype',\n\t'__proto__',\n\t'hasOwnProperty',\n\t'toString',\n\t'__defineGetter__',\n\t'__defineSetter__',\n\t'__lookupGetter__',\n\t'__lookupSetter__',\n\t'isPrototypeOf',\n\t'propertyIsEnumerable',\n\t'toLocaleString',\n\t'valueOf'\n];\n\nfunction isReserved (path) {\n\treturn reservedPaths.indexOf(path) >= 0;\n}\n\nmodule.exports = isReserved;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/expandColumns.js":"var utils = require('keystone-utils');\n\n/**\n * Expands a comma-separated string or array of columns into valid column objects.\n *\n * Columns can be:\n *    - A Field, in the format \"field|width\"\n *    - A Field in a single related List, in the format \"list:field|width\"\n *    - Any valid path in the Schema, in the format \"path|width\"\n *\n * The width part is optional, and can be in the format \"n%\" or \"npx\".\n *\n * The path __name__ is automatically mapped to the namePath of the List.\n *\n * The field or path for the name of the item (defaults to ID if not set or detected)\n * is automatically prepended if not explicitly included.\n */\nfunction expandColumns(cols) {\n\tif (typeof cols === 'string') {\n\t\tcols = cols.split(',');\n\t}\n\tif (!Array.isArray(cols)) {\n\t\tthrow new Error('List.expandColumns: cols must be an array.');\n\t}\n\tvar list = this;\n\tvar expanded = [];\n\tvar nameCol = false;\n\tvar getCol = function(def) {\n\t\tif (def.path === '__name__') {\n\t\t\tdef.path = list.namePath;\n\t\t}\n\t\tvar field = list.fields[def.path];\n\t\tvar col = null;\n\t\tif (field) {\n\t\t\tcol = {\n\t\t\t\tfield: field,\n\t\t\t\tpath: field.path,\n\t\t\t\ttype: field.type,\n\t\t\t\tlabel: def.label || field.label\n\t\t\t};\n\t\t\tif (col.type === 'relationship') {\n\t\t\t\tcol.refList = col.field.refList;\n\t\t\t\tif (col.refList) {\n\t\t\t\t\tcol.refPath = def.subpath || col.refList.namePath;\n\t\t\t\t\tcol.subField = col.refList.fields[col.refPath];\n\t\t\t\t\tcol.populate = { path: col.field.path, subpath: col.refPath };\n\t\t\t\t}\n\t\t\t\tif (!def.label && def.subpath) {\n\t\t\t\t\tcol.label = field.label + ': ' + (col.subField ? col.subField.label : utils.keyToLabel(def.subpath));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (list.model.schema.paths[def.path] || list.model.schema.virtuals[def.path]) {\n\t\t\t// column refers to a path in the schema\n\t\t\t// TODO: this needs to handle sophisticated types, including arrays, nested Schemas, and mixed types\n\t\t\tcol = {\n\t\t\t\tpath: def.path,\n\t\t\t\tlabel: def.label || utils.keyToLabel(def.path)\n\t\t\t};\n\t\t}\n\t\tif (col) {\n\t\t\tcol.width = def.width;\n\t\t\tif (col.path === list.namePath) {\n\t\t\t\tcol.isName = true;\n\t\t\t\tnameCol = col;\n\t\t\t}\n\t\t\tif (field && field.col) {\n\t\t\t\t_.extend(col, field.col);\n\t\t\t}\n\t\t}\n\t\treturn col;\n\t};\n\tfor (var i = 0; i < cols.length; i++) {\n\t\tvar def = {};\n\t\tif (typeof cols[i] === 'string') {\n\t\t\tvar parts = cols[i].trim().split('|');\n\t\t\tdef.width = parts[1] || false;\n\t\t\tparts = parts[0].split(':');\n\t\t\tdef.path = parts[0];\n\t\t\tdef.subpath = parts[1];\n\t\t}\n\t\tif (!utils.isObject(def) || !def.path) {\n\t\t\tthrow new Error('List.expandColumns: column definition must contain a path.');\n\t\t}\n\t\tvar col = getCol(def);\n\t\tif (col) {\n\t\t\texpanded.push(col);\n\t\t}\n\t}\n\tif (!nameCol) {\n\t\tnameCol = getCol({ path: list.namePath });\n\t\tif (nameCol) {\n\t\t\texpanded.unshift(nameCol);\n\t\t}\n\t}\n\treturn expanded;\n}\n\nmodule.exports = expandColumns;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/expandPaths.js":"var listToArray = require('list-to-array');\n\nfunction expandPaths (paths) {\n\treturn listToArray(paths).map(function (path) {\n\t\tif (path === '__name__') {\n\t\t\tpath = this.mappings.name;\n\t\t}\n\t\treturn {\n\t\t\tpath: path,\n\t\t\tfield: this.fields[path]\n\t\t};\n\t}, this);\n}\n\nmodule.exports = expandPaths;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/selectColumns.js":"/**\n * Specified select and populate options for a query based the provided columns.\n *\n * @param {Query} query\n * @param {Array} columns\n */\nfunction selectColumns (q, cols) {\n\t// Populate relationship columns\n\tvar select = [];\n\tvar populate = {};\n\tvar path;\n\tcols.forEach(function(col) {\n\t\tselect.push(col.path);\n\t\tif (col.populate) {\n\t\t\tif (!populate[col.populate.path]) {\n\t\t\t\tpopulate[col.populate.path] = [];\n\t\t\t}\n\t\t\tpopulate[col.populate.path].push(col.populate.subpath);\n\t\t}\n\t});\n\tq.select(select.join(' '));\n\tfor (path in populate) {\n\t\tif (populate.hasOwnProperty(path)) {\n\t\t\tq.populate(path, populate[path].join(' '));\n\t\t}\n\t}\n}\n\nmodule.exports = selectColumns;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/processFilters.js":"var queryfilterlib = require('queryfilter');\n\n/**\n * Processes a filter string into a filters object\n *\n * NOTE: This function is deprecated in favor of List.prototype.addFiltersToQuery\n * and will be removed in a later version.\n *\n * @param {String} filters\n */\nfunction processFilters (q) {\n\tvar list = this;\n\tvar filters = {};\n\tqueryfilterlib.QueryFilters.create(q).getFilters().forEach(function(filter){\n\t\tfilter.path = filter.key; // alias for b/c\n\t\tfilter.field = list.fields[filter.key];\n\t\tfilters[filter.path] = filter;\n\t});\n\treturn filters;\n}\n\nmodule.exports = processFilters;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/getSearchFilters.js":"var _ = require('underscore');\nvar moment = require('moment');\nvar utils = require('keystone-utils');\n\n/**\n * Gets filters for a Mongoose query that will search for the provided string,\n * based on the searchFields List option.\n *\n * Also accepts a filters object from `processFilters()`, any of which may\n * override the search string.\n *\n * NOTE: This function is deprecated in favor of List.prototype.addSearchToQuery\n * and will be removed in a later version.\n *\n * Example:\n *     list.getSearchFilters('jed') // returns { name: /jed/i }\n *\n * @param {String} query\n * @param {Object} additional filters\n */\nfunction getSearchFilters (search, add) {\n\tvar filters = {};\n\tvar list = this;\n\n\tsearch = String(search || '').trim();\n\n\tif (search.length) {\n\t\tvar searchFilter;\n\t\tvar searchParts = search.split(' ');\n\t\tvar searchRx = new RegExp(utils.escapeRegExp(search), 'i');\n\t\tvar splitSearchRx = new RegExp((searchParts.length > 1) ? _.map(searchParts, utils.escapeRegExp).join('|') : search, 'i');\n\t\tvar searchFields = this.get('searchFields');\n\t\tvar searchFilters = [];\n\t\tvar searchIdField = utils.isValidObjectId(search);\n\n\t\tif ('string' === typeof searchFields) {\n\t\t\tsearchFields = searchFields.split(',');\n\t\t}\n\n\t\tsearchFields.forEach(function (path) {\n\t\t\tpath = path.trim();\n\n\t\t\tif (path === '__name__') {\n\t\t\t\tpath = list.mappings.name;\n\t\t\t}\n\n\t\t\tvar field = list.fields[path];\n\n\t\t\tif (field && field.type === 'name') {\n\t\t\t\tvar first = {};\n\t\t\t\tfirst[field.paths.first] = splitSearchRx;\n\t\t\t\tvar last = {};\n\t\t\t\tlast[field.paths.last] = splitSearchRx;\n\t\t\t\tsearchFilter = {};\n\t\t\t\tsearchFilter.$or = [first, last];\n\t\t\t\tsearchFilters.push(searchFilter);\n\t\t\t} else {\n\t\t\t\tsearchFilter = {};\n\t\t\t\tsearchFilter[path] = searchRx;\n\t\t\t\tsearchFilters.push(searchFilter);\n\t\t\t}\n\t\t});\n\n\t\tif (list.autokey) {\n\t\t\tsearchFilter = {};\n\t\t\tsearchFilter[list.autokey.path] = searchRx;\n\t\t\tsearchFilters.push(searchFilter);\n\t\t}\n\n\t\tif (searchIdField) {\n\t\t\tsearchFilter = {};\n\t\t\tsearchFilter._id = search;\n\t\t\tsearchFilters.push(searchFilter);\n\t\t}\n\n\t\tif (searchFilters.length > 1) {\n\t\t\tfilters.$or = searchFilters;\n\t\t} else if (searchFilters.length) {\n\t\t\tfilters = searchFilters[0];\n\t\t}\n\n\t}\n\n\tif (add) {\n\t\t_.each(add, function(filter) {\n\t\t\tvar cond;\n\t\t\tvar path = filter.key;\n\t\t\tvar value = filter.value;\n\n\t\t\tswitch (filter.field.type) {\n\t\t\t\tcase 'boolean':\n\t\t\t\t\tif (!value || value === 'false') {\n\t\t\t\t\t\tfilters[path] = { $ne: true };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfilters[path] = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'localfile':\n\t\t\t\tcase 'cloudinaryimage':\n\t\t\t\tcase 'cloudinaryimages':\n\t\t\t\tcase 's3file':\n\t\t\t\tcase 'name':\n\t\t\t\tcase 'password':\n\t\t\t\t\t// TODO\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'location':\n\t\t\t\t\t_.each(['street1', 'suburb', 'state', 'postcode', 'country'], function(pathKey, i) {\n\t\t\t\t\t\tvar value = filter.value[i];\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\tfilters[filter.field.paths[pathKey]] = new RegExp(utils.escapeRegExp(value), 'i');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'relationship':\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (filter.field.many) {\n\t\t\t\t\t\t\tfilters[path] = (filter.inverse) ? { $nin: [value] } : { $in: [value] };\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfilters[path] = (filter.inverse) ? { $ne: value } : value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (filter.field.many) {\n\t\t\t\t\t\t\tfilters[path] = (filter.inverse) ? { $not: { $size: 0 } } : { $size: 0 };\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfilters[path] = (filter.inverse) ? { $ne: null } : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'select':\n\t\t\t\t\tif (filter.value) {\n\t\t\t\t\t\tfilters[path] = (filter.inverse) ? { $ne: value } : value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfilters[path] = (filter.inverse) ? { $nin: ['', null] } : { $in: ['', null] };\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'money':\n\t\t\t\t\tif (filter.operator === 'bt') {\n\t\t\t\t\t\tvalue = [\n\t\t\t\t\t\t\tutils.number(value[0]),\n\t\t\t\t\t\t\tutils.number(value[1])\n\t\t\t\t\t\t];\n\t\t\t\t\t\tif ( !isNaN(value[0]) && !isNaN(value[1]) ) {\n\t\t\t\t\t\t\tfilters[path] = {\n\t\t\t\t\t\t\t\t$gte: value[0],\n\t\t\t\t\t\t\t\t$lte: value[1]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfilters[path] = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = utils.number(value);\n\t\t\t\t\t\tif ( !isNaN(value) ) {\n\t\t\t\t\t\t\tif (filter.operator === 'gt') {\n\t\t\t\t\t\t\t\tfilters[path] = { $gt: value };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (filter.operator === 'lt') {\n\t\t\t\t\t\t\t\tfilters[path] = { $lt: value };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfilters[path] = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfilters[path] = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase 'date':\n\t\t\t\tcase 'datetime':\n\t\t\t\t\tif (filter.operator === 'bt') {\n\t\t\t\t\t\tvalue = [\n\t\t\t\t\t\t\tmoment(value[0]),\n\t\t\t\t\t\t\tmoment(value[1])\n\t\t\t\t\t\t];\n\t\t\t\t\t\tif ( (value[0] && value[0].isValid()) && (value[1] && value[0].isValid()) ) {\n\t\t\t\t\t\t\tfilters[path] = {\n\t\t\t\t\t\t\t\t$gte: moment(value[0]).startOf('day').toDate(),\n\t\t\t\t\t\t\t\t$lte: moment(value[1]).endOf('day').toDate()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = moment(value);\n\t\t\t\t\t\tif (value && value.isValid()) {\n\t\t\t\t\t\t\tvar start = moment(value).startOf('day').toDate();\n\t\t\t\t\t\t\tvar end = moment(value).endOf('day').toDate();\n\t\t\t\t\t\t\tif (filter.operator === 'gt') {\n\t\t\t\t\t\t\t\tfilters[path] = { $gt: end };\n\t\t\t\t\t\t\t} else if (filter.operator === 'lt') {\n\t\t\t\t\t\t\t\tfilters[path] = { $lt: start };\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfilters[path] = { $lte: end, $gte: start };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'text':\n\t\t\t\tcase 'textarea':\n\t\t\t\tcase 'html':\n\t\t\t\tcase 'email':\n\t\t\t\tcase 'url':\n\t\t\t\tcase 'key':\n\t\t\t\t\tif (filter.exact) {\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\t// Don't use regex when searching for an exact match on a string value\n\t\t\t\t\t\t\t// Regex makes the search case-insensitive but prevents indexes from being used\n\t\t\t\t\t\t\tfilters[path] = filter.inverse ? { $not: value } : value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (filter.inverse) {\n\t\t\t\t\t\t\t\tfilters[path] = { $nin: ['', null] };\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfilters[path] = { $in: ['', null] };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (value) {\n\t\t\t\t\t\tcond = new RegExp(utils.escapeRegExp(value), 'i');\n\t\t\t\t\t\tfilters[path] = filter.inverse ? { $not: cond } : cond;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t});\n\t}\n\treturn filters;\n}\n\nmodule.exports = getSearchFilters;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/updateAll.js":"var async = require('async');\n\n/**\n * Updates every document in a List,\n * setting the provided data on each.\n *\n * @param {Object} data\n * @param {Function} callback (optional)\n */\nfunction updateAll (data, callback) {\n\tif ('function' === typeof data) {\n\t\tcallback = data;\n\t\tdata = null;\n\t}\n\tcallback = callback || function () {};\n\tthis.model.find(function (err, results) {\n\t\tif (err) return callback(err);\n\t\tasync.eachSeries(results, function (doc, next) {\n\t\t\tif (data) {\n\t\t\t\tdoc.set(data);\n\t\t\t}\n\t\t\tdoc.save(next);\n\t\t}, function (err) {\n\t\t\tcallback(err);\n\t\t});\n\t});\n}\n\nmodule.exports = updateAll;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/getUniqueValue.js":"/**\n * Gets a unique value from a generator method by checking for documents with the same value.\n *\n * To avoid infinite loops when a unique value cannot be found, it will bail and pass back an\n * undefined value after 10 attemptes.\n *\n * WARNING: Because there will always be a small amount of time between checking for an\n * existing value and saving a document, race conditions can occur and it is possible that\n * another document has the 'unique' value assigned at the same time.\n *\n * Because of this, if true uniqueness is required, you should also create a unique index on\n * the database path, and handle duplicate errors thrown on save.\n *\n * @param {String} path to check for uniqueness\n * @param {Function} generator method to call to generate a new value\n * @param {Number} the maximum number of attempts (optional, defaults to 10)\n * @param {Function} callback(err, uniqueValue)\n */\nfunction getUniqueValue (path, generator, limit, callback) {\n\tvar model = this.model;\n\tvar count = 0;\n\tvar value;\n\tif (typeof limit === 'function') {\n\t\tcallback = limit;\n\t\tlimit = 10;\n\t}\n\tif (Array.isArray(generator)) {\n\t\tvar fn = generator[0];\n\t\tvar args = generator.slice(1);\n\t\tgenerator = function () {\n\t\t\treturn fn.apply(this, args);\n\t\t};\n\t}\n\tvar check = function () {\n\t\tif (count++ > 10) {\n\t\t\treturn callback(undefined, undefined);\n\t\t}\n\t\tvalue = generator();\n\t\tmodel.count().where(path, value).exec(function (err, matches) {\n\t\t\tif (err) return callback(err);\n\t\t\tif (matches) return check();\n\t\t\tcallback(undefined, value);\n\t\t});\n\t};\n\tcheck();\n}\n\nmodule.exports = getUniqueValue;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/getPages.js":"/**\n * Generate page array for pagination\n *\n * @param {Number} the maximum number pages to display in the pagination\n * @param {Object} page options\n */\nfunction getPages (options, maxPages) {\n\tvar surround = Math.floor(maxPages / 2);\n\tvar firstPage = maxPages ? Math.max(1, options.currentPage - surround) : 1;\n\tvar padRight = Math.max(((options.currentPage - surround) - 1) * -1, 0);\n\tvar lastPage = maxPages ? Math.min(options.totalPages, options.currentPage + surround + padRight) : options.totalPages;\n\tvar padLeft = Math.max(((options.currentPage + surround) - lastPage), 0);\n\toptions.pages = [];\n\tfirstPage = Math.max(Math.min(firstPage, firstPage - padLeft), 1);\n\tfor (var i = firstPage; i <= lastPage; i++) {\n\t\toptions.pages.push(i);\n\t}\n\tif (firstPage !== 1) {\n\t\toptions.pages.shift();\n\t\toptions.pages.unshift('...');\n\t}\n\tif (lastPage !== Number(options.totalPages)) {\n\t\toptions.pages.pop();\n\t\toptions.pages.push('...');\n\t}\n}\n\nmodule.exports = getPages;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/list/paginate.js":"/**\n * Gets a special Query object that will paginate documents in the list\n *\n * Example:\n *     list.paginate({\n *         page: 1,\n *         perPage: 100,\n *         maxPages: 10\n *     }).exec(function(err, results) {\n *         // do something\n *     });\n *\n * @param {Object} options\n * @param {Function} callback (optional)\n */\nfunction paginate (options, callback) {\n\tvar list = this;\n\tvar model = this.model;\n\n\toptions = options || {};\n\n\tvar query = model.find(options.filters);\n\n\tquery._original_exec = query.exec;\n\tquery._original_sort = query.sort;\n\tquery._original_select = query.select;\n\n\tvar currentPage = Number(options.page) || 1;\n\tvar resultsPerPage = Number(options.perPage) || 50;\n\tvar maxPages = Number(options.maxPages) || 10;\n\tvar skip = (currentPage - 1) * resultsPerPage;\n\n\tlist.pagination = { maxPages: maxPages };\n\n\t// as of mongoose 3.7.x, we need to defer sorting and field selection\n\t// until after the count has been executed\n\n\tquery.select = function () {\n\t\toptions.select = arguments[0];\n\t\treturn query;\n\t};\n\n\tquery.sort = function () {\n\t\toptions.sort = arguments[0];\n\t\treturn query;\n\t};\n\n\tquery.exec = function (callback) {\n\t\tquery.count(function (err, count) {\n\t\t\tif (err) return callback(err);\n\n\t\t\tquery.find().limit(resultsPerPage).skip(skip);\n\n\t\t\t// apply the select and sort options before calling exec\n\t\t\tif (options.select) {\n\t\t\t\tquery._original_select(options.select);\n\t\t\t}\n\n\t\t\tif (options.sort) {\n\t\t\t\tquery._original_sort(options.sort);\n\t\t\t}\n\n\t\t\tquery._original_exec(function (err, results) {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tvar totalPages = Math.ceil(count / resultsPerPage);\n\t\t\t\tvar rtn = {\n\t\t\t\t\ttotal: count,\n\t\t\t\t\tresults: results,\n\t\t\t\t\tcurrentPage: currentPage,\n\t\t\t\t\ttotalPages: totalPages,\n\t\t\t\t\tpages: [],\n\t\t\t\t\tprevious: (currentPage > 1) ? (currentPage - 1) : false,\n\t\t\t\t\tnext: (currentPage < totalPages) ? (currentPage + 1) : false,\n\t\t\t\t\tfirst: skip + 1,\n\t\t\t\t\tlast: skip + results.length\n\t\t\t\t};\n\t\t\t\tlist.getPages(rtn, maxPages);\n\t\t\t\tcallback(err, rtn);\n\t\t\t});\n\t\t});\n\n\t};\n\n\tif (callback) {\n\t\treturn query(callback);\n\t} else {\n\t\treturn query;\n\t}\n}\n\nmodule.exports = paginate;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/view.js":"/*!\n * Module dependencies.\n */\n\nvar _ = require('underscore');\nvar async = require('async');\nvar keystone = require('../');\nvar utils = require('keystone-utils');\n\n/**\n * View Constructor\n * =================\n *\n * Helper to simplify view logic in a Keystone application\n *\n * @api public\n */\n\nfunction View(req, res) {\n\n\tif (!req || req.constructor.name !== 'IncomingMessage') {\n\t\tthrow new Error('Keystone.View Error: Express request object is required.');\n\t}\n\n\tif (!res || res.constructor.name !== 'ServerResponse') {\n\t\tthrow new Error('Keystone.View Error: Express response object is required.');\n\t}\n\n\tthis.req = req;\n\tthis.res = res;\n\n\tthis.initQueue = [];\t// executed first in series\n\tthis.actionQueue = [];\t// executed second in parallel, if optional conditions are met\n\tthis.queryQueue = [];\t// executed third in parallel\n\tthis.renderQueue = [];\t// executed fourth in parallel\n\n}\n\nmodule.exports = exports = View;\n\n\n/**\n * Adds a method (or array of methods) to be executed in parallel\n * to the `init`, `action` or `render` queue.\n *\n * @api public\n */\n\nView.prototype.on = function(on) {\n\t\n\tvar req = this.req;\n\tvar callback = arguments[1];\n\tvar values;\n\t\n\tif ('function' === typeof on) {\n\t\t\n\t\t/* If the first argument is a function that returns truthy then add the second\n\t\t * argument to the action queue\n\t\t * \n\t\t * Example:\n\t\t * \n\t\t *     view.on(function() {\n\t\t *             var thing = true;\n\t\t *             return thing;\n\t\t *         },\n\t\t *         function(next) {\n\t\t *             console.log('thing is true!');\n\t\t *             next();\n\t\t *         }\n\t\t *     );\n\t\t */\n\t\t\n\t\tif (on()) {\n\t\t\tthis.actionQueue.push(callback);\n\t\t}\n\n\t} else if (utils.isObject(on)) {\n\t\t\n\t\t/* Do certain actions depending on information in the response object.\n\t\t * \n\t\t * Example:\n\t\t * \n\t\t *     view.on({ 'user.name.first': 'Admin' }, function(next) {\n\t\t *         console.log('Hello Admin!');\n\t\t *         next();\n\t\t *     });\n\t\t */\n\t\t\n\t\tvar check = function(value, path) {\n\n\t\t\tvar ctx = req;\n\t\t\tvar parts = path.split('.');\n\n\t\t\tfor (var i = 0; i < parts.length - 1; i++) {\n\t\t\t\tif (!ctx[parts[i]]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tctx = ctx[parts[i]];\n\t\t\t}\n\t\t\t\n\t\t\tpath = _.last(parts);\n\t\t\t\n\t\t\treturn (value === true && path in ctx) ? true : (ctx[path] === value);\n\n\t\t};\n\n\t\tif (_.every(on, check)) {\n\t\t\tthis.actionQueue.push(callback);\n\t\t}\n\t\t\n\t} else if (on === 'get' || on === 'post' || on === 'put' || on === 'delete') {\n\t\t\n\t\t/* Handle HTTP verbs\n\t\t * \n\t\t * Example:\n\t\t *     view.on('get', function(next) {\n\t\t *         console.log('GOT!');\n\t\t *         next();\n\t\t *     });\n\t\t */\n\t\t\n\t\tif (req.method !== on.toUpperCase()) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (arguments.length === 3) {\n\t\t\t\n\t\t\t/* on a POST and PUT requests search the req.body for a matching value\n\t\t\t * on every other request search the query.\n\t\t\t * \n\t\t\t * Example:\n\t\t\t *     view.on('post', { action: 'theAction' }, function(next) {\n\t\t\t *         // respond to the action\n\t\t\t *         next();\n\t\t\t *     });\n\t\t\t *     \n\t\t\t * Example:\n\t\t\t *     view.on('get', { page: 2 }, function(next) {\n\t\t\t *         // do something specifically on ?page=2\n\t\t\t *         next();\n\t\t\t *     });\n\t\t\t */\n\t\t\t\n\t\t\tif (utils.isString(arguments[1])) {\n\t\t\t\tvalues = {};\n\t\t\t\tvalues[arguments[1]] = true;\n\t\t\t} else {\n\t\t\t\tvalues = arguments[1];\n\t\t\t}\n\t\t\t\n\t\t\tcallback = arguments[2];\n\t\t\t\n\t\t\tvar ctx = (on === 'post' || on === 'put') ? req.body : req.query;\n\t\t\t\n\t\t\tif (_.every(values || {}, function(value, path) {\n\t\t\t\treturn (value === true && path in ctx) ? true : (ctx[path] === value);\n\t\t\t})) {\n\t\t\t\tthis.actionQueue.push(callback);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tthis.actionQueue.push(callback);\n\t\t}\n\n\t} else if (on === 'init') {\n\t\t\n\t\t/* Init events are always fired in series, before any other actions\n\t\t * \n\t\t * Example:\n\t\t *     view.on('init', function (next) {\n\t\t *         // do something before any actions or queries have run\n\t\t *     });\n\t\t */\n\t\t\n\t\tthis.initQueue.push(callback);\n\t\t\n\t} else if (on === 'render') {\n\t\t\n\t\t/* Render events are always fired last in parallel, after any other actions\n\t\t *  \n\t\t * Example:\n\t\t *     view.on('render', function (next) {\n\t\t *         // do something after init, action and query middleware has run\n\t\t *     });\n\t\t */\n\t\t\n\t\tthis.renderQueue.push(callback);\n\t\t\n\t}\n\n\treturn this;\n\t\n};\n\nvar QueryCallbacks = function(options) {\n\tif (utils.isString(options)) {\n\t\toptions = { then: options };\n\t} else {\n\t\toptions = options || {};\n\t}\n\tthis.callbacks = {};\n\tif (options.err) this.callbacks.err = options.err;\n\tif (options.none) this.callbacks.none = options.none;\n\tif (options.then) this.callbacks.then = options.then;\n\treturn this;\n};\n\nQueryCallbacks.prototype.has = function(fn) { return (fn in this.callbacks); };\nQueryCallbacks.prototype.err = function(fn) { this.callbacks.err = fn; return this; };\nQueryCallbacks.prototype.none = function(fn) { this.callbacks.none = fn; return this; };\nQueryCallbacks.prototype.then = function(fn) { this.callbacks.then = fn; return this; };\n\n\n/**\n * Queues a mongoose query for execution before the view is rendered.\n * The results of the query are set in `locals[key]`.\n *\n * Keys can be nested paths, containing objects will be created as required.\n *\n * The third argument `then` can be a method to call after the query is completed\n * like function(err, results, callback), or a `populatedRelated` definition\n * (string or array).\n * \n * Examples:\n * \n * view.query('books', keystone.list('Book').model.find());\n * \n *     an array of books from the database will be added to locals.books. You can\n *     also nest properties on the locals variable.\n * \n * view.query(\n *     'admin.books',\n *      keystone.list('Book').model.find().where('user', 'Admin')\n * );\n * \n *     locals.admin.books will be the result of the query\n *     views.query().then is always called if it is available\n * \n * view.query('books', keystone.list('Book').model.find())\n *     .then(function (err, results, next) {\n *         if (err) return next(err);\n *         console.log(results);\n *         next();\n *     });\n *\n * @api public\n */\n\nView.prototype.query = function(key, query, options) {\n\n\tvar locals = this.res.locals;\n\tvar parts = key.split('.');\n\tvar chain = new QueryCallbacks(options);\n\n    key = parts.pop();\n\n\tfor (var i = 0; i < parts.length; i++) {\n\t\tif (!locals[parts[i]]) {\n\t\t\tlocals[parts[i]] = {};\n\t\t}\n\t\tlocals = locals[parts[i]];\n\t}\n\n\tthis.queryQueue.push(function(next) {\n\t\tquery.exec(function(err, results) {\n\n\t\t\tlocals[key] = results;\n\t\t\tvar callbacks = chain.callbacks;\n\n\t\t\tif (err) {\n\t\t\t\tif ('err' in callbacks) {\n\t\t\t\t\t/* Will pass errors into the err callback\n\t\t\t\t\t * \n\t\t\t\t\t * Example:\n\t\t\t\t\t *     view.query('books', keystone.list('Book'))\n\t\t\t\t\t *         .err(function (err, next) {\n\t\t\t\t\t *             console.log('ERROR: ', err);\n\t\t\t\t\t *             next();\n\t\t\t\t\t *         });\n\t\t\t\t\t */\n\t\t\t\t\treturn callbacks.err(err, next);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((!results || (utils.isArray(results) && !results.length)) && 'none' in callbacks) {\n\t\t\t\t\t/* If there are no results view.query().none will be called\n\t\t\t\t\t * \n\t\t\t\t\t * Example:\n\t\t\t\t\t *     view.query('books', keystone.list('Book').model.find())\n\t\t\t\t\t *         .none(function (next) {\n\t\t\t\t\t *             console.log('no results');\n\t\t\t\t\t *             next();\n\t\t\t\t\t *         });\n\t\t\t\t\t */\n\t\t\t\t\treturn callbacks.none(next);\n\t\t\t\t} else if ('then' in callbacks) {\n\t\t\t\t\tif (utils.isFunction(callbacks.then)) {\n\t\t\t\t\t\treturn callbacks.then(err, results, next);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn keystone.populateRelated(results, callbacks.then, next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn next(err);\n\n\t\t});\n\t});\n\n\treturn chain;\n};\n\n\n/**\n * Executes the current queue of init and action methods in series, and\n * then executes the render function. If renderFn is a string, it is provided\n * to `res.render`.\n *\n * It is expected that *most* init stacks require processing in series,\n * but it is safe to execute actions in parallel.\n *\n * If there are several init methods that should be run in parallel, queue\n * them as an array, e.g. `view.on('init', [first, second])`.\n *\n * @api public\n */\nView.prototype.render = function(renderFn, locals, callback) {\n\n\tvar req = this.req;\n\tvar res = this.res;\n\n\tif ('string' === typeof renderFn) {\n\t\tvar viewPath = renderFn;\n\t\trenderFn = function() {\n\t\t\tif ('function' === typeof locals) {\n\t\t\t\tlocals = locals();\n\t\t\t}\n\t\t\tthis.res.render(viewPath, locals, callback);\n\t\t}.bind(this);\n\t}\n\n\tif ('function' !== typeof renderFn) {\n\t\tthrow new Error('Keystone.View.render() renderFn must be a templatePath (string) or a function.');\n\t}\n\n\t// Add actions, queries & renderQueue to the end of the initQueue\n\tthis.initQueue.push(this.actionQueue);\n\tthis.initQueue.push(this.queryQueue);\n\n\tvar preRenderQueue = [];\n\n\t// Add Keystone's global pre('render') queue\n\tkeystone.getMiddleware('pre:render').forEach( function(fn) {\n\t\tpreRenderQueue.push(function(next) {\n\t\t\tfn(req, res, next);\n\t\t});\n\t});\n\n\tthis.initQueue.push(preRenderQueue);\n\tthis.initQueue.push(this.renderQueue);\n\n\tasync.eachSeries(this.initQueue, function(i, next) {\n\t\tif (Array.isArray(i)) {\n\t\t\t// process nested arrays in parallel\n\t\t\tasync.parallel(i, next);\n\t\t} else if ('function' === typeof i) {\n\t\t\t// process single methods in series\n\t\t\ti(next);\n\t\t} else {\n\t\t\tthrow new Error('Keystone.View.render() events must be functions.');\n\t\t}\n\t}, function(err) {\n\t\trenderFn(err, req, res);\n\t});\n\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/content/index.js":"var _ = require('underscore'),\n\tkeystone = require('../../'),\n\tutils = keystone.utils;\n\n/**\n * Content Class\n *\n * Accessed via `Keystone.content`\n *\n * @api public\n */\n\nvar Content = function() {};\n\n/**\n * Loads page content by page key (optional).\n *\n * If page key is not provided, returns a hash of all page contents in the database.\n *\n * ####Example:\n *\n *     keystone.content.fetch('home', function(err, content) { ... });\n *\n * @param {String} key (optional)\n * @param {Function} callback\n * @api public\n */\n\nContent.prototype.fetch = function(page, callback) {\n\n\tif (utils.isFunction(page)) {\n\t\tcallback = page;\n\t\tpage = null;\n\t}\n\n\tvar content = this;\n\n\tif (!this.AppContent) {\n\t\treturn callback({ error: 'invalid page', message: 'No pages have been registered.' });\n\t}\n\n\tif (page) {\n\n\t\tif (!this.pages[page]) {\n\t\t\treturn callback({ error: 'invalid page', message: 'The page ' + page + ' does not exist.' });\n\t\t}\n\n\t\tthis.AppContent.findOne({ key: page }, function(err, result) {\n\n\t\t\tif (err) return callback(err);\n\n\t\t\treturn callback(null, content.pages[page].populate(result ? result.content.data : {}));\n\n\t\t});\n\n\t} else {\n\n\t\tthis.AppContent.find(function(err, results) {\n\n\t\t\tif (err) return callback(err);\n\n\t\t\tvar data = {};\n\n\t\t\tresults.forEach(function(i) {\n\t\t\t\tif (content.pages[i.key]) {\n\t\t\t\t\tdata[i.key] = content.pages[i.key].populate(i.content.data);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t_.each(content.pages, function(i) {\n\t\t\t\tif (!data[i.key]) {\n\t\t\t\t\tdata[i.key] = i.populate();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn data;\n\n\t\t});\n\n\t}\n\n};\n\n/**\n * Sets page content by page key.\n *\n * Merges content with existing content.\n *\n * ####Example:\n *\n *     keystone.content.store('home', { title: 'Welcome' }, function(err) { ... });\n *\n * @param {String} key\n * @param {Object} content\n * @param {Function} callback\n * @api public\n */\n\nContent.prototype.store = function(page, content, callback) {\n\n\tif (!this.pages[page]) {\n\t\treturn callback({ error: 'invalid page', message: 'The page ' + page + ' does not exist.' });\n\t}\n\n\tcontent = this.pages[page].validate(content);\n\n\t// TODO: Handle validation errors\n\n\tthis.AppContent.findOne({ key: page }, function(err, doc) {\n\n\t\tif (err) return callback(err);\n\n\t\tif (doc) {\n\t\t\tif (doc.content) {\n\t\t\t\tdoc.history.push(doc.content);\n\t\t\t}\n\t\t\t_.defaults(content, doc.content);\n\t\t} else {\n\t\t\tdoc = new content.AppContent({ key: page });\n\t\t}\n\n\t\tdoc.content = { data: this.pages[page].clean(content) };\n\t\tdoc.lastChangeDate = Date.now();\n\n\t\tdoc.save(callback);\n\n\t});\n\n};\n\n/**\n * Registers a page. Should not be called directly, use Page.register() instead.\n *\n * @param {Page} page\n * @api private\n */\n\nContent.prototype.page = function(key, page) {\n\n\tif (!this.pages) {\n\t\tthis.pages = {};\n\t}\n\n\tif (arguments.length === 1) {\n\n\t\tif (!this.pages[key]) {\n\t\t\tthrow new Error('keystone.content.page() Error: page ' + key + ' cannot be registered more than once.');\n\t\t}\n\n\t\treturn this.pages[key];\n\n\t}\n\n\tthis.initModel();\n\n\tif (this.pages[key]) {\n\t\tthrow new Error('keystone.content.page() Error: page ' + key + ' cannot be registered more than once.');\n\t}\n\n\tthis.pages[key] = page;\n\n\treturn page;\n\n};\n\n/**\n * Ensures the Mongoose model for storing content is initialised.\n *\n * Called automatically when pages are added.\n *\n * @api private\n */\n\nContent.prototype.initModel = function() {\n\n\tif (this.AppContent) return;\n\n\tvar contentSchemaDef = {\n\t\tcreatedAt: { type: Date, default: Date.now },\n\t\tdata: { type: keystone.mongoose.Schema.Types.Mixed }\n\t};\n\n\tvar ContentSchema = new keystone.mongoose.Schema(contentSchemaDef);\n\n\tvar PageSchema = new keystone.mongoose.Schema({\n\t\tpage: { type: String, index: true },\n\t\tlastChangeDate: { type: Date, index: true },\n\t\tcontent: contentSchemaDef,\n\t\thistory: [ContentSchema]\n\t}, { collection: 'app_content' });\n\n\tthis.AppContent = keystone.mongoose.model('App_Content', PageSchema);\n\n};\n\n/**\n * Outputs client-side editable data for content management\n *\n * Called automatically when pages are added.\n *\n * @api private\n */\n\nContent.prototype.editable = function(user, options) {\n\n\tif (!user || !user.canAccessKeystone) {\n\t\treturn undefined;\n\t}\n\n\tif (options.list) {\n\n\t\tvar list = keystone.list(options.list);\n\n\t\tif (!list) {\n\t\t\treturn JSON.stringify({ type: 'error', err: 'list not found' });\n\t\t}\n\n\t\tvar data = {\n\t\t\ttype: 'list',\n\t\t\tpath: list.path,\n\t\t\tsingular: list.singular,\n\t\t\tplural: list.plural\n\t\t};\n\n\t\tif (options.id) {\n\t\t\tdata.id = options.id;\n\t\t}\n\n\t\treturn JSON.stringify(data);\n\n\t}\n\n};\n\n\n/**\n * The exports object is an instance of Content.\n *\n * @api public\n */\n\nmodule.exports = exports = new Content();\n\n// Expose Classes\nexports.Page = require('./page');\nexports.Types = require('./types');\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/content/page.js":"var _ = require('underscore'),\n\tkeystone = require('../../'),\n\tutils = keystone.utils,\n\tType = require('./type');\n\n/**\n * Page Class\n *\n * @param {String} key\n * @param {Object} options\n * @api public\n */\n\nfunction Page(key, options) {\n\t\n\tif (!(this instanceof Page)) {\n\t\treturn new Page(key, options);\n\t}\n\t\n\tthis.options = utils.options({\n\t\t// ...\n\t}, options);\n\t\n\tthis.key = key;\n\tthis.fields = {};\n\t\n}\n\nObject.defineProperty(Page.prototype, 'name', {\n\tget: function() {\n\t\treturn this.get('name') || this.set('name', utils.keyToLabel(this.key));\n\t}\n});\n\n/**\n * Sets page options\n *\n * ####Example:\n *\n *     page.set('test', value) // sets the 'test' option to `value`\n *\n * @param {String} key\n * @param {String} value\n * @api public\n */\n\nPage.prototype.set = function(key, value) {\n\t\n\tif (arguments.length === 1) {\n\t\treturn this.options[key];\n\t}\n\t\n\tthis.options[key] = value;\n\treturn value;\n\t\n};\n\n\n/**\n * Gets page options\n *\n * ####Example:\n *\n *     page.get('test') // returns the 'test' value\n *\n * @param {String} key\n * @method get\n * @api public\n */\n\nPage.prototype.get = Page.prototype.set;\n\n/**\n * Adds one or more fields to the page\n * \n * @api public\n */\n\nPage.prototype.add = function(fields) {\n\t\n\t// TODO: nested paths\n\tif (!utils.isObject(fields)) {\n\t\tthrow new Error('keystone.content.Page.add() Error: fields must be an object.');\n\t}\n\t\n\t_.each(fields, function(options, path) {\n\t\t\n\t\tif ('function' === typeof options) {\n\t\t\toptions = { type: options };\n\t\t}\n\t\t\n\t\tif ('function' !== typeof options.type) {\n\t\t\tthrow new Error('Page fields must be specified with a type function');\n\t\t}\n\t\t\n\t\tif (options.type.prototype.__proto__ !== Type.prototype) {\n\t\t\t\n\t\t\t// Convert native field types to their default Keystone counterpart\n\t\t\t\n\t\t\tif (options.type === String) {\n\t\t\t\toptions.type = keystone.content.Types.Text;\n\t\t\t}\n\t\t\t\n\t\t\t// TODO: More types\n\t\t\t// else if (options.type == Number)\n\t\t\t// \toptions.type = Field.Types.Number;\n\t\t\t// else if (options.type == Boolean)\n\t\t\t// \toptions.type = Field.Types.Boolean;\n\t\t\t// else if (options.type == Date)\n\t\t\t// \toptions.type = Field.Types.Datetime;\n\t\t\t\n\t\t\telse {\n\t\t\t\tthrow new Error('Unrecognised field constructor: ' + options.type);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tthis.fields[path] = new options.type(path, options);\n\t\t\n\t}, this);\n\t\n\treturn this;\n\t\n};\n\n/**\n * Registers the page with Keystone.\n * \n * ####Example:\n * \t\t\n * \t\tvar homePage = new keystone.content.Page('home');\n * \t\t// ...\n * \t\thomePage.register();\n * \t\t\n * \t\t// later...\n * \t\tvar homePage = keystone.content.page('home');\n * \n * @api public\n */\n\nPage.prototype.register = function() {\n\treturn keystone.content.page(this.key, this);\n};\n\n/**\n * Populates a data structure based on defined fields\n * \n * @api public\n */\n\nPage.prototype.populate = function(data) {\n\t\n\tif (!utils.isObject(data)) {\n\t\tdata = {};\n\t}\n\t\n\t// TODO: implement schema\n\t\n\treturn data;\n\t\n};\n\n/**\n * Validates a data structure based on defined fields\n * \n * @api public\n */\n\nPage.prototype.validate = function(data) {\n\t\n\tif (!_.isObject(data)) {\n\t\tdata = {};\n\t}\n\t\n\t// TODO: implement schema\n\t\n\treturn data;\n\t\n};\n\n/**\n * Cleans a data structure so only the defined fields are present\n * \n * @api public\n */\n\nPage.prototype.clean = function(data) {\n\t\n\tif (!_.isObject(data)) {\n\t\tdata = {};\n\t}\n\t\n\t// TODO: implement schema\n\t\n\treturn data;\n\t\n};\n\n\n/*!\n * Export class\n */\n\nexports = module.exports = Page;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/content/type.js":"/**\n * Type Class\n * @api private\n */\n\nvar Type = function(path, options) { //eslint-disable-line no-unused-vars\n\t// TODO\n};\n\n\n/*!\n * Export class\n */\n\nmodule.exports = exports = Type;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/content/types/index.js":"exports.Text = require('./text');\nexports.Html = require('./html');\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/content/types/text.js":"/*!\n * Module dependencies.\n */\n\nvar util = require('util'),\n\tsuper_ = require('../type');\n\n/**\n * Text ContentType Constructor\n * @extends Field\n * @api public\n */\n\nfunction text(path, options) {\n\ttext.super_.call(path, options);\n}\n\n/*!\n * Inherit from Type\n */\n\nutil.inherits(text, super_);\n\n\n/*!\n * Export class\n */\n\nmodule.exports = exports = text;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/content/types/html.js":"/*!\n * Module dependencies.\n */\n\nvar util = require('util'),\n\tsuper_ = require('../type');\n\n/**\n * HTML ContentType Constructor\n * @extends Field\n * @api public\n */\n\nfunction html(path, options) {\n\thtml.super_.call(path, options);\n}\n\n/*!\n * Inherit from Type\n */\n\nutil.inherits(html, super_);\n\n\n/*!\n * Export class\n */\n\nmodule.exports = exports = html;\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/security/csrf.js":"var crypto = require('crypto');\nvar scmp = require('scmp');\nvar utils = require('keystone-utils');\n\nexports.TOKEN_KEY = '_csrf';\nexports.LOCAL_KEY = 'csrf_token_key';\nexports.LOCAL_VALUE = 'csrf_token_value';\nexports.SECRET_KEY = exports.TOKEN_KEY + '_secret';\nexports.SECRET_LENGTH = 10;\nexports.CSRF_HEADER_KEY = 'x-csrf-token';\nexports.XSRF_HEADER_KEY = 'x-xsrf-token';\nexports.XSRF_COOKIE_KEY = 'XSRF-TOKEN';\n\nfunction tokenize(salt, secret) {\n\treturn salt + crypto.createHash('sha1').update(salt + secret).digest('base64');\n}\n\nexports.createSecret = function() {\n\treturn crypto.pseudoRandomBytes(exports.SECRET_LENGTH).toString('base64');\n};\n\nexports.getSecret = function(req) {\n\treturn req.session[exports.SECRET_KEY] || (req.session[exports.SECRET_KEY] = exports.createSecret());\n};\n\nexports.createToken = function(req) {\n\treturn tokenize(utils.randomString(exports.SECRET_LENGTH), exports.getSecret(req));\n};\n\nexports.getToken = function(req, res) {\n\tres.locals[exports.LOCAL_VALUE] = res.locals[exports.LOCAL_VALUE] || exports.createToken(req);\n\tres.cookie(exports.XSRF_COOKIE_KEY, res.locals[exports.LOCAL_VALUE]);\n\treturn res.locals[exports.LOCAL_VALUE];\n};\n\nexports.requestToken = function(req) {\n\tif (req.body && req.body[exports.TOKEN_KEY]) {\n\t\treturn req.body[exports.TOKEN_KEY];\n\t} else if (req.query && req.query[exports.TOKEN_KEY]) {\n\t\treturn req.query[exports.TOKEN_KEY];\n\t} else if (req.headers && req.headers[exports.XSRF_HEADER_KEY]) {\n\t\treturn req.headers[exports.XSRF_HEADER_KEY];\t\n\t} else if (req.headers && req.headers[exports.CSRF_HEADER_KEY]) {\n\t\treturn req.headers[exports.CSRF_HEADER_KEY];\t\t\n\t}\n\treturn '';\n};\n\nexports.validate = function(req, token) {\n\tif (arguments.length === 1) {\n\t\ttoken = exports.requestToken(req);\n\t}\n\tif (typeof token !== 'string') {\n\t\treturn false;\n\t}\n\treturn scmp(token, tokenize(token.slice(0, exports.SECRET_LENGTH), req.session[exports.SECRET_KEY]));\n};\n\nexports.middleware = {\n\t\n\tinit: function(req, res, next) {\n\t\tres.locals[exports.LOCAL_KEY] = exports.LOCAL_VALUE;\n\t\texports.getToken(req, res);\n\t\tnext();\n\t},\n\t\n\tvalidate: function(req, res, next) {\n\t\t\n\t\t// Bail on safe methods\n\t\tif (req.method === 'GET' || req.method === 'HEAD' || req.method === 'OPTIONS') {\n\t\t\treturn next();\n\t\t}\n\t\t\n\t\t// Validate token\n\t\tif (exports.validate(req)) {\n\t\t\tnext();\n\t\t} else {\n\t\t\tres.statusCode = 403;\n\t\t\tnext(new Error('CSRF token mismatch'));\n\t\t}\n\t\n\t}\n\t\n};\n","/home/travis/build/npmtest/node-npmtest-keystone/keystone/lib/session.js":"var crypto = require('crypto');\nvar keystone = require('../');\nvar scmp = require('scmp');\nvar utils = require('keystone-utils');\n\n/**\n * Creates a hash of str with Keystone's cookie secret.\n * Only hashes the first half of the string.\n */\nfunction hash(str) {\n\t// force type\n\tstr = '' + str;\n\t// get the first half\n\tstr = str.substr(0, Math.round(str.length / 2));\n\t// hash using sha256\n\treturn crypto\n\t\t.createHmac('sha256', keystone.get('cookie secret'))\n\t\t.update(str)\n\t\t.digest('base64')\n\t\t.replace(/\\=+$/, '');\n}\n\n/**\n * Signs in a user using user obejct\n *\n * @param {Object} user - user object\n * @param {Object} req - express request object\n * @param {Object} res - express response object\n * @param {function()} onSuccess callback, is passed the User instance\n */\n\nfunction signinWithUser(user, req, res, onSuccess) {\n\tif (arguments.length < 4) {\n\t\tthrow new Error('keystone.session.signinWithUser requires user, req and res objects, and an onSuccess callback.');\n\t}\n\tif ('object' !== typeof user) {\n\t\tthrow new Error('keystone.session.signinWithUser requires user to be an object.');\n\t}\n\tif ('object' !== typeof req) {\n\t\tthrow new Error('keystone.session.signinWithUser requires req to be an object.');\n\t}\n\tif ('object' !== typeof res) {\n\t\tthrow new Error('keystone.session.signinWithUser requires res to be an object.');\n\t}\n\tif ('function' !== typeof onSuccess) {\n\t\tthrow new Error('keystone.session.signinWithUser requires onSuccess to be a function.');\n\t}\n\treq.session.regenerate(function() {\n\t\treq.user = user;\n\t\treq.session.userId = user.id;\n\t\t// if the user has a password set, store a persistence cookie to resume sessions\n\t\tif (keystone.get('cookie signin') && user.password) {\n\t\t\tvar userToken = user.id + ':' + hash(user.password);\n\t\t\tres.cookie('keystone.uid', userToken, { signed: true, httpOnly: true });\n\t\t}\n\t\tonSuccess(user);\n\t});\n}\n\nexports.signinWithUser = signinWithUser;\n\nvar postHookedSigninWithUser = function(user, req, res, onSuccess, onFail) {\n\tkeystone.callHook(user, 'post:signin', function(err) {\n\t\tif (err) {\n\t\t\treturn onFail(err);\n\t\t}\n\t\texports.signinWithUser(user, req, res, onSuccess, onFail);\n\t});\n};\n\n/**\n * Signs in a user user matching the lookup filters\n *\n * @param {Object} lookup - must contain email and password\n * @param {Object} req - express request object\n * @param {Object} res - express response object\n * @param {function()} onSuccess callback, is passed the User instance\n * @param {function()} onFail callback\n */\n\nvar doSignin = function(lookup, req, res, onSuccess, onFail) {\n\tif (!lookup) {\n\t\treturn onFail(new Error('session.signin requires a User ID or Object as the first argument'));\n\t}\n\tvar User = keystone.list(keystone.get('user model'));\n\tif ('string' === typeof lookup.email && 'string' === typeof lookup.password) {\n\t\t// ensure that it is an email, we don't want people being able to sign in by just using \"\\.\" and a haphazardly correct password.\n\t\tif (!utils.isEmail(lookup.email)) {\n\t\t\treturn onFail(new Error('Incorrect email or password'));\n\t\t}\n\t\t// create regex for email lookup with special characters escaped\n\t\tvar emailRegExp = new RegExp('^' + utils.escapeRegExp(lookup.email) + '$', 'i');\n\t\t// match email address and password\n\t\tUser.model.findOne({ email: emailRegExp }).exec(function(err, user) {\n\t\t\tif (user) {\n\t\t\t\tuser._.password.compare(lookup.password, function(err, isMatch) {\n\t\t\t\t\tif (!err && isMatch) {\n\t\t\t\t\t\tpostHookedSigninWithUser(user, req, res, onSuccess, onFail);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonFail(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tonFail(err);\n\t\t\t}\n\t\t});\n\t} else {\n\t\tlookup = '' + lookup;\n\t\t// match the userId, with optional password check\n\t\tvar userId = (lookup.indexOf(':') > 0) ? lookup.substr(0, lookup.indexOf(':')) : lookup;\n\t\tvar passwordCheck = (lookup.indexOf(':') > 0) ? lookup.substr(lookup.indexOf(':') + 1) : false;\n\t\tUser.model.findById(userId).exec(function(err, user) {\n\t\t\tif (user && (!passwordCheck || scmp(passwordCheck, hash(user.password)))) {\n\t\t\t\tpostHookedSigninWithUser(user, req, res, onSuccess, onFail);\n\t\t\t} else {\n\t\t\t\tonFail(err);\n\t\t\t}\n\t\t});\n\t}\n};\n\nexports.signin = function(lookup, req, res, onSuccess, onFail) {\n\tkeystone.callHook({}, 'pre:signin', function(err) {\n\t\tif (err) {\n\t\t\treturn onFail(err);\n\t\t}\n\t\tdoSignin(lookup, req, res, onSuccess, onFail);\n\t});\n};\n\n/**\n * Signs the current user out and resets the session\n *\n * @param {Object} req - express request object\n * @param {Object} res - express response object\n * @param {function()} next callback\n */\n\nexports.signout = function(req, res, next) {\n\tkeystone.callHook(req.user, 'pre:signout', function(err) {\n\t\tif (err) {\n\t\t\tconsole.log(\"An error occurred in signout 'pre' middleware\", err);\n\t\t}\n\t\tres.clearCookie('keystone.uid');\n\t\treq.user = null;\n\t\treq.session.regenerate(function(err) {\n\t\t\tif (err) {\n\t\t\t\treturn next(err);\n\t\t\t}\n\t\t\tkeystone.callHook({}, 'post:signout', function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tconsole.log(\"An error occurred in signout 'post' middleware\", err);\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t});\n\t\t});\n\t});\n};\n\n/**\n * Middleware to ensure session persistence across server restarts\n *\n * Looks for a userId cookie, and if present, and there is no user signed in,\n * automatically signs the user in.\n *\n * @param {Object} req - express request object\n * @param {Object} res - express response object\n * @param {function()} next callback\n */\n\nexports.persist = function(req, res, next) {\n\tvar User = keystone.list(keystone.get('user model'));\n\tif (!req.session) {\n\t\tconsole.error('\\nKeystoneJS Runtime Error:\\n\\napp must have session middleware installed. Try adding \"express-session\" to your express instance.\\n');\n\t\tprocess.exit(1);\n\t}\n\tif (keystone.get('cookie signin') && !req.session.userId && req.signedCookies['keystone.uid'] && req.signedCookies['keystone.uid'].indexOf(':') > 0) {\n\t\texports.signin(req.signedCookies['keystone.uid'], req, res, function() {\n\t\t\tnext();\n\t\t}, function(err) {\n\t\t\tnext(err);\n\t\t});\n\t} else if (req.session.userId) {\n\t\tUser.model.findById(req.session.userId).exec(function(err, user) {\n\t\t\tif (err) return next(err);\n\t\t\treq.user = user;\n\t\t\tnext();\n\t\t});\n\t} else {\n\t\tnext();\n\t}\n};\n\n/**\n * Middleware to enable access to Keystone\n *\n * Bounces the user to the signin screen if they are not signed in or do not have permission.\n *\n * req.user is the user returned by the database. It's type is Keystone.List.\n *\n * req.user.canAccessKeystone denotes whether the user has access to the admin panel.\n * If you're having issues double check your user model. Setting `canAccessKeystone` to true in\n * the database will not be reflected here if it is virtual.\n * See http://mongoosejs.com/docs/guide.html#virtuals\n *\n * @param {Object} req - express request object\n * @param req.user - The user object Keystone.List\n * @param req.user.canAccessKeystone {Boolean|Function}\n * @param {Object} res - express response object\n * @param {function()} next callback\n */\n\nexports.keystoneAuth = function(req, res, next) {\n\tif (!req.user || !req.user.canAccessKeystone) {\n\t\tvar from = new RegExp('^\\/keystone\\/?$', 'i').test(req.url) ? '' : '?from=' + req.url;\n\t\treturn res.redirect(keystone.get('signin url') + from);\n\t}\n\tnext();\n};\n"}